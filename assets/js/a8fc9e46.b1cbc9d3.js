"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[9493],{20006:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"pro/channel_state_events","title":"Channel state events","description":"Centrifugo PRO has a feature to enable channel state event webhooks to be sent to your configured backend endpoint:","source":"@site/docs/pro/channel_events.md","sourceDirName":"pro","slug":"/pro/channel_state_events","permalink":"/docs/pro/channel_state_events","draft":false,"unlisted":false,"editUrl":"https://github.com/centrifugal/centrifugal.dev/edit/main/docs/pro/channel_events.md","tags":[],"version":"current","frontMatter":{"id":"channel_state_events","sidebar_label":"Channel state events","title":"Channel state events"},"sidebar":"Pro","previous":{"title":"Token revocation API","permalink":"/docs/pro/token_revocation"},"next":{"title":"Cache empty events","permalink":"/docs/pro/channel_cache_empty"}}');var a=t(74848),o=t(28453);const i={id:"channel_state_events",sidebar_label:"Channel state events",title:"Channel state events"},r=void 0,c={},l=[];function d(e){const n={a:"a",admonition:"admonition",code:"code",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Centrifugo PRO has a feature to enable channel state event webhooks to be sent to your configured backend endpoint:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["channel ",(0,a.jsx)(n.code,{children:"occupied"})," event - called whenever first subscriber occupies the channel"]}),"\n",(0,a.jsxs)(n.li,{children:["channel ",(0,a.jsx)(n.code,{children:"vacated"})," event - called whenever last subscriber leaves the channel"]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{title:"Preview state",type:"info",children:(0,a.jsxs)(n.p,{children:["This feature is ",(0,a.jsx)(n.strong,{children:"in the preview state now"}),". We still need some time before it will be ready for usage in production. But the feature is available for evaluation."]})}),"\n",(0,a.jsxs)(n.p,{children:["To enable the feature you must use ",(0,a.jsx)(n.code,{children:"redis"})," engine. Also, only channels with ",(0,a.jsx)(n.code,{children:"presence"})," enabled may deliver channel state notifications. When enabling channel state proxy Centrifugo PRO starts using another approach to create Redis keys for presence for namespaces where channel state events enabled, this is an important implementation detail."]}),"\n",(0,a.jsxs)(n.p,{children:["So the minimal config can look like this (",(0,a.jsx)(n.code,{children:"occupied"})," and ",(0,a.jsx)(n.code,{children:"vacated"})," events for channels in ",(0,a.jsx)(n.code,{children:"chat"})," namespace will be sent to ",(0,a.jsx)(n.code,{children:"channel.proxy.state.endpoint"}),"):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",metastring:"title=config.json",children:'{\n  "engine": {\n    "type": "redis"\n  },\n  "channel": {\n    "proxy": {\n      "state": {\n        "endpoint": "http://localhost:3000/centrifugo/channel_events"\n      }\n    },\n    "namespaces": [\n      {\n        "name": "chat",\n        "presence": true,\n        "state_proxy_enabled": true\n      }\n    ]\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The proxy endpoint is an extension of ",(0,a.jsx)(n.a,{href:"/docs/server/proxy",children:"Centrifugo OSS proxy"})," and proto definitions may be found in the same ",(0,a.jsx)(n.a,{href:"https://github.com/centrifugal/centrifugo/blob/master/internal/proxyproto/proxy.proto",children:"proxy.proto"})," file - see ",(0,a.jsx)(n.code,{children:"NotifyChannelState"})," rpc. Example of the payload your backend request handler will receive:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n    "events": [\n        {"channel": "chat:index", "type": "occupied", "time_ms": 1697206286533},\n    ]\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Payload may contain a batch of events, that's why ",(0,a.jsx)(n.code,{children:"events"})," is an array \u2013 this is important for achieving a high event throughput. Your backend must be fast enough to keep up with the events rate and volume, otherwise event queues will grow and eventually new events will be dropped by Centrifugo PRO."]}),"\n",(0,a.jsxs)(n.p,{children:["Respond with empty object without ",(0,a.jsx)(n.code,{children:"error"})," set to let Centrifugo PRO know that events were processed successfully."]}),"\n",(0,a.jsxs)(n.p,{children:["If last channel client resubscribes to a channel fast (during 5 secs) \u2013 then Centrifugo PRO won't send ",(0,a.jsx)(n.code,{children:"vacated"})," events. If client does not resubscribe during 5 secs - event will be sent. So ",(0,a.jsx)(n.code,{children:"vacated"})," events always delivered with a delay. This is implemented in such way to avoid unnecessary webhooks for quick reconnect scenarios."]}),"\n",(0,a.jsx)(n.p,{children:"Centrifugo PRO does the best effort delivering channel state events, making retries when the backend endpoint is unavailable (with exponential backoff), also survives cases when Centrifugo node dies unexpectedly. But there are rare scenarios, when notifications may be lost \u2013 like when data lost in Redis. For such cases we recommend syncing the state periodically looking at channel presence information using server API \u2013 this depends on the use case though."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var s=t(96540);const a={},o=s.createContext(a);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);