"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[2430],{28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var o=s(96540);const r={},i=o.createContext(r);function t(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),o.createElement(i.Provider,{value:n},e.children)}},92618:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>t,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"server/consumers","title":"Built-in API command async consumers","description":"In server API chapter we\'ve shown how to execute various Centrifugo server API commands (publish, broadcast, etc.) over HTTP or GRPC. In many cases you will call those APIs from your application business logic synchronously. But to deal with temporary network and availability issues, and achieve reliable execution of API commands upon changes in your primary application database you may want to use queuing techniques and call Centrifugo API asynchronously.","source":"@site/docs/server/consumers.md","sourceDirName":"server","slug":"/server/consumers","permalink":"/docs/server/consumers","draft":false,"unlisted":false,"editUrl":"https://github.com/centrifugal/centrifugal.dev/edit/main/docs/server/consumers.md","tags":[],"version":"current","frontMatter":{"id":"consumers","sidebar_label":"Async consumers","title":"Built-in API command async consumers"},"sidebar":"Guides","previous":{"title":"Engines and scalability","permalink":"/docs/server/engines"},"next":{"title":"History and recovery","permalink":"/docs/server/history_and_recovery"}}');var r=s(74848),i=s(28453);const t={id:"consumers",sidebar_label:"Async consumers",title:"Built-in API command async consumers"},a=void 0,c={},l=[{value:"Supported consumers",id:"supported-consumers",level:2},{value:"How it works",id:"how-it-works",level:2},{value:"Common consumer options",id:"common-consumer-options",level:2},{value:"PostgreSQL outbox consumer",id:"postgresql-outbox-consumer",level:2},{value:"PostgreSQL consumer options",id:"postgresql-consumer-options",level:3},{value:"Kafka consumer",id:"kafka-consumer",level:2},{value:"Kafka consumer options",id:"kafka-consumer-options",level:3},{value:"Publication data mode",id:"publication-data-mode",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.a,{href:"/docs/server/server_api",children:"server API"})," chapter we've shown how to execute various Centrifugo server API commands (publish, broadcast, etc.) over HTTP or GRPC. In many cases you will call those APIs from your application business logic synchronously. But to deal with temporary network and availability issues, and achieve reliable execution of API commands upon changes in your primary application database you may want to use queuing techniques and call Centrifugo API asynchronously."]}),"\n",(0,r.jsx)(n.p,{children:"Asynchronous delivery of real-time events upon changes in primary database may be done is several ways. Some companies use transactional outbox pattern, some using techniques like Kafka Connect with CDC (Change Data Capture) approach. The fact Centrifugo provides API allows users to implement any of those techniques and build worker which will send API commands to Centrifugo reliably."}),"\n",(0,r.jsx)(n.p,{children:"But Centrifugo also provides some built-in asynchronous consumers to simplify the integration process."}),"\n",(0,r.jsx)(n.h2,{id:"supported-consumers",children:"Supported consumers"}),"\n",(0,r.jsx)(n.p,{children:"The following built-in async consumers are available at this point:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Consumer ",(0,r.jsx)(n.a,{href:"#postgresql-outbox-consumer",children:"from PostgreSQL outbox table"})," (since Centrifugo v5.2.0)"]}),"\n",(0,r.jsxs)(n.li,{children:["Consumer ",(0,r.jsx)(n.a,{href:"#kafka-consumer",children:"from Kafka topics"})," (since Centrifugo v5.2.0)"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,r.jsxs)(n.p,{children:["Consumers expect to consume messages which represent Centrifugo ",(0,r.jsx)(n.a,{href:"/docs/server/server_api",children:"server API commands"}),". I.e. while in synchronous server API you are using HTTP or GRPC to send commands \u2013 with asynchronous consumers you are inserting API command to PostgreSQL outbox table, or delivering to Kafka topic \u2013 and it will be soon consumed and processed asynchronously by Centrifugo."]}),"\n",(0,r.jsxs)(n.p,{children:["Async consumers only process commands which modify state \u2013 such as ",(0,r.jsx)(n.a,{href:"/docs/server/server_api#publish",children:"publish"}),", ",(0,r.jsx)(n.a,{href:"/docs/server/server_api#broadcast",children:"broadcast"}),", ",(0,r.jsx)(n.a,{href:"/docs/server/server_api#unsubscribe",children:"unsubscribe"}),", ",(0,r.jsx)(n.a,{href:"/docs/server/server_api#disconnect",children:"disconnect"}),", etc. Sending read commands for async execution simply does not make any sense and they will be ignored. Also, ",(0,r.jsx)(n.a,{href:"/docs/server/server_api#batch",children:"batch"})," method is not supported."]}),"\n",(0,r.jsxs)(n.p,{children:["Centrifugo ",(0,r.jsx)(n.strong,{children:"only supports JSON payloads for asynchronous commands coming to consumers for now"}),". If you need binary format \u2013 reach out with your use case."]}),"\n",(0,r.jsxs)(n.p,{children:["If Centrifugo encounters an error while processing consumed messages \u2013 then internal errors will be retried, all other errors logged on ",(0,r.jsx)(n.code,{children:"error"})," level \u2013 and the message will be marked as processed. The processing logic for ",(0,r.jsx)(n.a,{href:"/docs/server/server_api#broadcast",children:"broadcast"})," API is special: if any of the publications to any channel from broadcast ",(0,r.jsx)(n.code,{children:"channels"})," array failed \u2013 then the entire broadcast command will be retried. To prevent duplicate messages being published during such retries \u2013 consider using ",(0,r.jsx)(n.code,{children:"idempotency_key"})," in the broadcast command."]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["Our ",(0,r.jsx)(n.a,{href:"/docs/tutorial/outbox_cdc",children:"Chat/Messenger tutorial"})," shows PostgreSQL outbox and Kafka consumer in action. It also shows techniques to avoid duplicate messages (idempotent publications) and deal with late message delivery (idempotent processing on client side). Whether you need those techniques \u2013 depends on the nature of app. Various real-time features may require different ways of sending real-time events. Both synchronous API calls and async calls have its own advantages and trade-offs. We also talk about this in ",(0,r.jsx)(n.a,{href:"/blog/2023/08/19/asynchronous-message-streaming-to-centrifugo-with-benthos",children:"Asynchronous message streaming to Centrifugo with Benthos"})," blog post."]})}),"\n",(0,r.jsx)(n.h2,{id:"common-consumer-options",children:"Common consumer options"}),"\n",(0,r.jsxs)(n.p,{children:["Consumers can be set in the configuration using ",(0,r.jsx)(n.code,{children:"consumers"})," array:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "consumers": [\n    {\n      "enabled": true,\n      "name": "xxx",\n      "type": "postgresql",\n      "postgresql": {...}\n    },\n    {\n      "enabled": true,\n      "name": "yyy",\n      "type": "kafka",\n      "kafka": {...}\n    }\n  ]\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"On top level each consumer object has the following fields:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"enabled"})," - boolean (default: ",(0,r.jsx)(n.code,{children:"false"}),"), when set to ",(0,r.jsx)(n.code,{children:"true"})," allows enabling the configured consumer"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"name"})," - string (required), described name of consumer. Must be unique for each consumer and match the regex ",(0,r.jsx)(n.code,{children:"^[a-zA-Z0-9_]{2,}"})," - i.e. latin symbols, digits and underscores and be at least 2 symbols. This name will be used for logging purposes, metrics, also to override some options with environment variables."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"type"})," - string (required), type of consumer. At this point can be ",(0,r.jsx)(n.code,{children:"postgresql"})," or ",(0,r.jsx)(n.code,{children:"kafka"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["To provide ",(0,r.jsx)(n.code,{children:"consumers"})," over environment variable provide ",(0,r.jsx)(n.code,{children:"CENTRIFUGO_CONSUMERS"})," var with JSON array serialized to string. It's also possible to override some specific consumer options over environment variables \u2013 see below."]}),"\n",(0,r.jsx)(n.h2,{id:"postgresql-outbox-consumer",children:"PostgreSQL outbox consumer"}),"\n",(0,r.jsxs)(n.p,{children:["Centrifugo can natively integrate with PostgreSQL table for ",(0,r.jsx)(n.a,{href:"https://microservices.io/patterns/data/transactional-outbox.html",children:"Transactional outbox"})," pattern. The table in PostgreSQL must have predefined format Centrifugo expects:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE IF NOT EXISTS centrifugo_outbox (\n\tid BIGSERIAL PRIMARY KEY,\n\tmethod text NOT NULL,\n\tpayload JSONB NOT NULL,\n\tpartition INTEGER NOT NULL default 0,\n\tcreated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Then configure consumer of ",(0,r.jsx)(n.code,{children:"postgresql"})," type in Centrifugo config:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  ...\n  "consumers": [\n    {\n      "enabled": true,\n      "name": "my_postgresql_consumer",\n      "type": "postgresql",\n      "postgresql": {\n        "dsn": "postgresql://user:password@localhost:5432/db",\n        "outbox_table_name": "centrifugo_outbox",\n        "num_partitions": 1,\n        "partition_select_limit": 100,\n        "partition_poll_interval": "300ms"\n      }\n    }\n  ]\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Here is how you can insert row in outbox table to publish into Centrifugo channel:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:'INSERT INTO centrifugo_outbox (method, payload, partition)\nVALUES (\'publish\', \'{"channel": "updates", "data": {"text": "Hello, world!"}}\', 0);\n'})}),"\n",(0,r.jsx)(n.p,{children:"Centrifugo supports LISTEN/NOTIFY mechanism of PostgreSQL to be notified about new data in the outbox table. To enable it you need first create a trigger in PostgreSQL:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE OR REPLACE FUNCTION centrifugo_notify_partition_change()\nRETURNS TRIGGER AS $$\nBEGIN\n    PERFORM pg_notify('centrifugo_partition_change', NEW.partition::text);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE OR REPLACE TRIGGER centrifugo_notify_partition_trigger\nAFTER INSERT ON chat_outbox\nFOR EACH ROW\nEXECUTE FUNCTION centrifugo_notify_partition_change();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["And then update consumer config \u2013 add ",(0,r.jsx)(n.code,{children:'"partition_notification_channel"'})," option to it:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  ...\n  "consumers": [\n    {\n      "enabled": true,\n      "name": "my_postgresql_consumer",\n      "type": "postgresql",\n      "postgresql": {\n        ...\n        "partition_notification_channel": "centrifugo_partition_change"\n      }\n    }\n  ]\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"postgresql-consumer-options",children:"PostgreSQL consumer options"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumers.postgresql.dsn"})," - string (required), DSN to PostgreSQL database, ex. ",(0,r.jsx)(n.code,{children:'"postgresql://user:password@localhost:5432/db"'}),". To override ",(0,r.jsx)(n.code,{children:"dsn"})," over environment variables use ",(0,r.jsx)(n.code,{children:"CENTRIFUGO_CONSUMERS_<CONSUMER_NAME>_POSTGRESQL_DSN"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumers.postgresql.outbox_table_name"})," - string (required), the name of outbox table in selected database, ex. ",(0,r.jsx)(n.code,{children:'"centrifugo_outbox"'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumers.postgresql.num_partitions"})," - integer (default: ",(0,r.jsx)(n.code,{children:"1"}),"), the number of partitions to use. Centrifugo keeps strict order of commands per-partition by default. This option provides a way to create concurrent consumers each consuming from different partition of outbox table. Note, that partition numbers in start with ",(0,r.jsx)(n.code,{children:"0"}),", so when using ",(0,r.jsx)(n.code,{children:"1"})," as ",(0,r.jsx)(n.code,{children:"num_partitions"})," insert data with ",(0,r.jsx)(n.code,{children:"partition"})," == ",(0,r.jsx)(n.code,{children:"0"})," to the outbox table."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumers.postgresql.partition_select_limit"})," - integer (default: ",(0,r.jsx)(n.code,{children:"100"}),") \u2013 max number of commands to select in one query to outbox table."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumers.postgresql.partition_poll_interval"})," - duration (default: ",(0,r.jsx)(n.code,{children:'"300ms"'}),") - polling interval for each partition"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumers.postgresql.partition_notification_channel"})," - string (default: ",(0,r.jsx)(n.code,{children:'""'}),") - optional name of LISTEN/NOTIFY channel to trigger consuming upon data added to outbox partition."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumers.postgresql.tls"})," - ",(0,r.jsx)(n.a,{href:"/docs/server/tls#unified-tls-config-object",children:"TLSConfig"})," to configure PostgreSQL client TLS."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"kafka-consumer",children:"Kafka consumer"}),"\n",(0,r.jsx)(n.p,{children:"Another built-in consumer \u2013 is Kafka topics consumer. To configure Centrifugo to consume Kafka topic:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'  ...\n  "consumers": [\n    {\n      "enabled": true,\n      "name": "my_kafka_consumer",\n      "type": "kafka",\n      "kafka": {\n        "brokers": ["localhost:9092"],\n        "topics": ["postgres.public.chat_cdc"],\n        "consumer_group": "centrifugo"\n      }\n    }\n  ]\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Then simply put message in the following format to Kafka topic:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "method": "publish",\n  "payload": {\n    "channel": "mychannel",\n    "data": {}\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"\u2013 and it will be consumed by Centrifugo and reliably processed."}),"\n",(0,r.jsx)(n.h3,{id:"kafka-consumer-options",children:"Kafka consumer options"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumers.kafka.brokers"})," - ",(0,r.jsx)(n.code,{children:"array[string]"})," (required), points Centrifugo to Kafka brokers. To override ",(0,r.jsx)(n.code,{children:"brokers"})," over environment variables use ",(0,r.jsx)(n.code,{children:"CENTRIFUGO_CONSUMERS_<CONSUMER_NAME>_KAFKA_BROKERS"})," \u2013 string with broker addresses separated by space."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumers.kafka.topics"})," - array of string (required), tells which topics to consume"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumers.kafka.consumer_group"})," - string (required), sets the name of consumer group to use"]}),"\n",(0,r.jsxs)(n.li,{children:["consumers.kafka.",(0,r.jsx)(n.code,{children:"max_poll_records"})," - integer (default: ",(0,r.jsx)(n.code,{children:"100"}),") - sets the maximum number of records to fetch from Kafka during a single poll operation."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumers.kafka.sasl_mechanism"})," - only ",(0,r.jsx)(n.code,{children:'"plain"'})," is now supported"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumers.kafka.sasl_user"})," - string, user for plain SASL auth. To override ",(0,r.jsx)(n.code,{children:"sasl_user"})," over environment variables use ",(0,r.jsx)(n.code,{children:"CENTRIFUGO_CONSUMERS_<CONSUMER_NAME>_KAFKA_SASL_USER"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumers.kafka.sasl_password"})," - string, password for plain SASL auth. To override ",(0,r.jsx)(n.code,{children:"sasl_password"})," over environment variables use ",(0,r.jsx)(n.code,{children:"CENTRIFUGO_CONSUMERS_<CONSUMER_NAME>_KAFKA_SASL_PASSWORD"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumers.kafka.tls"})," - ",(0,r.jsx)(n.a,{href:"/docs/server/tls#unified-tls-config-object",children:"TLSConfig"})," to configure Kafka client TLS."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"publication-data-mode",children:"Publication data mode"}),"\n",(0,r.jsx)(n.p,{children:"Publication data mode for Kafka consumer simplifies integrating Centrifugo with existing Kafka topics. By default, Centrifugo can integrate with Kafka topics but requires a special payload format, where each message in the topic represented a Centrifugo API command. This approach works well for Kafka topics specifically set up for Centrifugo."}),"\n",(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.strong,{children:"Publication Data Mode"})," is enabled, Centrifugo expects messages in Kafka topics to contain data ready for direct publication, rather than server API commands. It is also possible to use special Kafka headers to specify the channels to which the data should be published."]}),"\n",(0,r.jsx)(n.p,{children:"The primary goal of this mode is to simplify Centrifugo's integration with existing Kafka topics, making it easier to deliver real-time messages to clients without needing to restructure the topic's payload format."}),"\n",(0,r.jsx)(n.p,{children:"BTW, don't forget that since Centrifugo allows configuring an array of asynchronous consumers, it is possible to use Kafka consumers in different modes simultaneously."}),"\n",(0,r.jsx)(n.p,{children:"To enable publication data mode:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'  "consumers": [\n    {\n      "enabled": true,\n      "name": "my_kafka_consumer",\n      "type": "kafka",\n      "kafka": {\n        "brokers": ["localhost:9092"],\n        "topics": ["my_topic"],\n        "consumer_group": "centrifugo",\n        "publication_data_mode": {\n          "enabled": true,\n          "channels_header": "x-centrifugo-channels"\n          "idempotency_key_header": "x-centrifugo-idempotency-key"\n        }\n      }\n    }\n  ]\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"As you can see, channels to forward publication to may be provided as a value of a configured header. So you don't need to change payloads in topic to transform them to real-time messages with Centrifugo."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);