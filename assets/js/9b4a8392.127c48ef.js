"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[3249],{1016:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/throttling-07d51ebeea022e4f37529186cb5b7ccb.png"},1636:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"pro/rate_limiting","title":"Operation rate limits","description":"The rate limit feature allows limiting the number of operations each connection or user can issue during a configured time interval. This is useful to protect the system from misusing, detecting and disconnecting abusive or broken (due to the bug in the frontend application) clients which add unwanted load on a server.","source":"@site/versioned_docs/version-5/pro/rate_limiting.md","sourceDirName":"pro","slug":"/pro/rate_limiting","permalink":"/docs/5/pro/rate_limiting","draft":false,"unlisted":false,"editUrl":"https://github.com/centrifugal/centrifugal.dev/edit/main/versioned_docs/version-5/pro/rate_limiting.md","tags":[],"version":"5","frontMatter":{"id":"rate_limiting","title":"Operation rate limits"},"sidebar":"Pro","previous":{"title":"Analytics with ClickHouse","permalink":"/docs/5/pro/analytics"},"next":{"title":"Push notification API","permalink":"/docs/5/pro/push_notifications"}}');var r=i(74848),s=i(28453);const o={id:"rate_limiting",title:"Operation rate limits"},c=void 0,l={},a=[{value:"In-memory per connection rate limit",id:"in-memory-per-connection-rate-limit",level:2},{value:"In-memory per user rate limit",id:"in-memory-per-user-rate-limit",level:2},{value:"Redis per user rate limit",id:"redis-per-user-rate-limit",level:2},{value:"Disconnecting abusive or misbehaving connections",id:"disconnecting-abusive-or-misbehaving-connections",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"The rate limit feature allows limiting the number of operations each connection or user can issue during a configured time interval. This is useful to protect the system from misusing, detecting and disconnecting abusive or broken (due to the bug in the frontend application) clients which add unwanted load on a server."}),"\n",(0,r.jsx)(n.p,{children:"With rate limit properly configured you can protect your Centrifugo installation to some degree without sophisticated third-party solution. Centrifugo PRO protection works best in combination with protection on infrastructure level though."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Throttling",src:i(1016).A+"",width:"4043",height:"875"})}),"\n",(0,r.jsx)(n.h2,{id:"in-memory-per-connection-rate-limit",children:"In-memory per connection rate limit"}),"\n",(0,r.jsxs)(n.p,{children:["In-memory rate limit is an efficient way to limit number of operations allowed on a per-connection basis \u2013 i.e. inside each individual real-time connection. Our rate limit implementation uses ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Token_bucket",children:"token bucket"})," algorithm internally."]}),"\n",(0,r.jsx)(n.p,{children:"The list of operations which can be rate limited on a per-connection level is:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"subscribe"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"publish"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"history"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"presence"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"presence_stats"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"refresh"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"sub_refresh"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rpc"})," (with optional method resolution)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In addition, Centrifugo allows defining two special buckets containers:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"total"})," \u2013 define it to limit the total number of commands per interval (all commands sent from client count), these buckets will always be checked if defined, every command from the client always consumes token from ",(0,r.jsx)(n.code,{children:"total"})," buckets"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"default"})," - define it if you don't want to configure some command buckets explicitly, default buckets will be used in case command buckets is not configured explicitly."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n    ...\n    "client_command_rate_limit": {\n        "enabled": true,\n\n        "default": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 60\n                },\n            ]\n        },\n        "total": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 20\n                },\n                {\n                    "interval": "60s",\n                    "rate": 50\n                },\n            ]\n        },\n        "publish": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 1\n                },\n            ]\n        },\n        "rpc": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 10\n                }\n            ],\n            "method_override": [\n                {\n                    "method": "update_user_status",\n                    "buckets": [\n                        {\n                            "interval": "20s",\n                            "rate": 1\n                        }\n                    ]\n                }\n            ]\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"Centrifugo real-time SDKs written in a way that if client receives an error during connect \u2013 it will try to reconnect to a server with backoff algorithm. The same for subscribing to channels (i.e. error from subscribe command) \u2013 subscription request will be retried with a backoff. Refresh and subscription refresh will be also retried automatically by SDK upon errors after in several seconds. Retries of other commands should be handled manually from the client side if needed \u2013 though usually you should choose rate limit limits in a way that normal users of your app never hit the limits."})}),"\n",(0,r.jsx)(n.h2,{id:"in-memory-per-user-rate-limit",children:"In-memory per user rate limit"}),"\n",(0,r.jsx)(n.p,{children:"Another type of rate limit in Centrifugo PRO is a per user ID in-memory rate limit. Like per client rate limit this one is also very efficient since also uses in-memory token buckets. The difference is that instead of rate limit per individual client this type of rate limit takes user ID into account."}),"\n",(0,r.jsx)(n.p,{children:"This type of rate limit only checks commands coming from authenticated users \u2013 i.e. with non-empty user ID set. Requests from anonymous users can't be rate limited with it."}),"\n",(0,r.jsxs)(n.p,{children:["The list of operations which can be rate limited is similar to the in-memory rate limit described above. But with ",(0,r.jsx)(n.strong,{children:"additional"})," ",(0,r.jsx)(n.code,{children:"connect"})," method:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"total"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"default"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"connect"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"subscribe"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"publish"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"history"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"presence"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"presence_stats"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"refresh"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"sub_refresh"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rpc"})," (with optional method resolution)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The configuration is very similar:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n    ...\n    "user_command_rate_limit": {\n        "enabled": true,\n\n        "default": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 60\n                },\n            ]\n        },\n        "publish": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 1\n                }\n            ]\n        },\n        "rpc": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 10\n                }\n            ],\n            "method_override": [\n                {\n                    "method": "update_user_status",\n                    "buckets": [\n                        {\n                            "interval": "20s",\n                            "rate": 1\n                        }\n                    ]\n                }\n            ]\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"redis-per-user-rate-limit",children:"Redis per user rate limit"}),"\n",(0,r.jsx)(n.p,{children:"The next type of rate limit in Centrifugo PRO is a distributed per user ID rate limit with Redis as a bucket state storage. In this case limits are global for the entire Centrifugo cluster. If one user executed two commands on different Centrifugo nodes, Centrifugo consumes two tokens from the same bucket kept in Redis. Since this rate limit goes to Redis to check limits, it adds some latency to a command processing. Our implementation tries to provide good throughput characteristics though \u2013 in our tests single Redis instance can handle more than 100k limit check requests per second. And it's possible to scale Redis in the same ways as for Centrifugo Redis Engine."}),"\n",(0,r.jsxs)(n.p,{children:["This type of rate limit only checks commands coming from authenticated users \u2013 i.e. with non-empty user ID set. Requests from anonymous users can't be rate limited with it. The implementation also uses ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Token_bucket",children:"token bucket"})," algorithm internally."]}),"\n",(0,r.jsxs)(n.p,{children:["The list of operations which can be rate limited is similar to the in-memory user command rate limit described above. But ",(0,r.jsx)(n.strong,{children:"without"})," special bucket ",(0,r.jsx)(n.code,{children:"total"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"default"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"connect"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"subscribe"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"publish"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"history"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"presence"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"presence_stats"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"refresh"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"sub_refresh"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rpc"})," (with optional method resolution)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The configuration is very similar:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n    ...\n    "redis_user_command_rate_limit": {\n        "enabled": true,\n        "redis_address": "localhost:6379",\n\n        "default": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 60\n                },\n            ]\n        },\n        "publish": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 1\n                }\n            ]\n        },\n        "rpc": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 10\n                }\n            ],\n            "method_override": [\n                {\n                    "method": "update_user_status",\n                    "buckets": [\n                        {\n                            "interval": "20s",\n                            "rate": 1\n                        }\n                    ]\n                }\n            ]\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Redis configuration for rate limit feature matches Centrifugo Redis engine configuration. So Centrifugo supports client-side consistent sharding to scale Redis, Redis Sentinel, Redis Cluster for rate limit feature too."}),"\n",(0,r.jsxs)(n.p,{children:["It's also possible to reuse Centrifugo Redis engine by setting ",(0,r.jsx)(n.code,{children:"use_redis_from_engine"})," option instead of custom rate limit Redis configuration declaration, like this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n    ...\n    "engine": "redis",\n    "redis_address": "localhost:6379",\n    "redis_user_command_rate_limit": {\n        "enabled": true,\n        "use_redis_from_engine": true,\n        ...\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"In this case rate limit will simply connect to Redis instances configured for an Engine."}),"\n",(0,r.jsx)(n.h2,{id:"disconnecting-abusive-or-misbehaving-connections",children:"Disconnecting abusive or misbehaving connections"}),"\n",(0,r.jsx)(n.p,{children:"Above we showed how you can define rate limit strategies to protect server resources and prevent execution of many commands inside the connection and from certain user."}),"\n",(0,r.jsx)(n.p,{children:"But there are scenarios when abusive or broken connections may generate a significant load on the server just by calling commands and getting error responses due to rate limit or due to other reasons (like malformed command). Centrifugo PRO provides a way to configure error limits per connection to deal with this case."}),"\n",(0,r.jsxs)(n.p,{children:["Error limits are configured as in-memory buckets operating on a per-connection level. When these buckets are full due to lots of errors for an individual connection Centrifugo disconnects the client (with advice to not reconnect, so our SDKs may follow it). This way it's possible to get rid of the connection and rely on HTTP infrastracture tools to deal with client reconnections. Since WebSocket or other our transports (except unidirectional GRPC, but it's usually not available to the public port) are HTTP-based (or start with HTTP request in WebSocket Upgrade case) \u2013 developers can use Nginx ",(0,r.jsx)(n.code,{children:"limit_req_zone"})," directive, Cloudflare rules, iptables, and so on, to protect Centrifugo from unwanted connections."]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"Centrifugo PRO does not count internal errors for the error limit buckets \u2013 as internal errors is usually not a client's fault."})}),"\n",(0,r.jsx)(n.p,{children:"The configuration on error limits per connection may look like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n    ...\n    "client_error_limits": {\n        "enabled": true,\n        "total": {\n            "buckets" : [\n                {\n                    "interval": "5s",\n                    "rate": 20\n                }\n            ]\n        }\n    }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>c});var t=i(96540);const r={},s=t.createContext(r);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);