"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[926],{45493:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>a});var i=t(85893),r=t(11151);const o={id:"throttling",title:"Operation throttling"},s=void 0,c={id:"pro/throttling",title:"Operation throttling",description:"The throttling feature allows limiting the number of operations each connection or user can issue during a configured time interval. This is useful to protect the system from misusing, detecting and disconnecting abusive or broken (due to the bug in the frontend application) clients which add unwanted load on a server.",source:"@site/versioned_docs/version-4/pro/throttling.md",sourceDirName:"pro",slug:"/pro/throttling",permalink:"/docs/4/pro/throttling",draft:!1,unlisted:!1,editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/versioned_docs/version-4/pro/throttling.md",tags:[],version:"4",frontMatter:{id:"throttling",title:"Operation throttling"},sidebar:"Pro",previous:{title:"Analytics with ClickHouse",permalink:"/docs/4/pro/analytics"},next:{title:"Push notification API",permalink:"/docs/4/pro/push_notifications"}},l={},a=[{value:"In-memory per connection throttling",id:"in-memory-per-connection-throttling",level:2},{value:"In-memory per user throttling",id:"in-memory-per-user-throttling",level:2},{value:"Redis per user throttling",id:"redis-per-user-throttling",level:2},{value:"Disconnecting abusive or misbehaving connections",id:"disconnecting-abusive-or-misbehaving-connections",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"The throttling feature allows limiting the number of operations each connection or user can issue during a configured time interval. This is useful to protect the system from misusing, detecting and disconnecting abusive or broken (due to the bug in the frontend application) clients which add unwanted load on a server."}),"\n",(0,i.jsx)(n.p,{children:"With throttling properly configured you can protect your Centrifugo installation to some degree without sophisticated third-party solution. Centrifugo PRO protection works best in combination with protection on infrastructure level though."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Throttling",src:t(54195).Z+"",width:"4043",height:"875"})}),"\n",(0,i.jsx)(n.h2,{id:"in-memory-per-connection-throttling",children:"In-memory per connection throttling"}),"\n",(0,i.jsxs)(n.p,{children:["In-memory throttling is an efficient way to limit number of operations allowed on a per-connection basis \u2013 i.e. inside each individual real-time connection. Our throttling implementation uses ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Token_bucket",children:"token bucket"})," algorithm internally."]}),"\n",(0,i.jsx)(n.p,{children:"The list of operations which can be throttled on a per-connection level is:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"subscribe"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"publish"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"history"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"presence"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"presence_stats"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"refresh"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"sub_refresh"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rpc"})," (with optional method resolution)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In addition, Centrifugo allows defining two special buckets containers:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"total"})," \u2013 define it to limit the total number of commands per interval (all commands sent from client count), these buckets will always be checked if defined, every command from the client always consumes token from ",(0,i.jsx)(n.code,{children:"total"})," buckets"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"default"})," - define it if you don't want to configure some command buckets explicitly, default buckets will be used in case command buckets is not configured explicitly."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n    ...\n    "client_command_throttling": {\n        "enabled": true,\n\n        "default": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 60\n                },\n            ]\n        },\n        "total": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 20\n                },\n                {\n                    "interval": "60s",\n                    "rate": 50\n                },\n            ]\n        },\n        "publish": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 1\n                },\n            ]\n        },\n        "rpc": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 10\n                }\n            ],\n            "method_override": [\n                {\n                    "method": "updateActiveStatus",\n                    "buckets": [\n                        {\n                            "interval": "20s",\n                            "rate": 1\n                        }\n                    ]\n                }\n            ]\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Centrifugo real-time SDKs written in a way that if client receives an error during connect \u2013 it will try to reconnect to a server with backoff algorithm. The same for subscribing to channels (i.e. error from subscribe command) \u2013 subscription request will be retried with a backoff. Refresh and subscription refresh will be also retried automatically by SDK upon errors after in several seconds. Retries of other commands should be handled manually from the client side if needed \u2013 though usually you should choose throttling limits in a way that normal users of your app never hit the limits."})}),"\n",(0,i.jsx)(n.h2,{id:"in-memory-per-user-throttling",children:"In-memory per user throttling"}),"\n",(0,i.jsx)(n.p,{children:"Another type of throttling in Centrifugo PRO is a per user ID in-memory throttling. Like per client throttling this one is also very efficient since also uses in-memory token buckets. The difference is that instead of throttling per individual client this type of throttling takes user ID into account."}),"\n",(0,i.jsx)(n.p,{children:"This type of throttling only checks commands coming from authenticated users \u2013 i.e. with non-empty user ID set. Requests from anonymous users can't be throttled with it."}),"\n",(0,i.jsxs)(n.p,{children:["The list of operations which can be throttled is similar to the in-memory throttling described above. But with ",(0,i.jsx)(n.strong,{children:"additional"})," ",(0,i.jsx)(n.code,{children:"connect"})," method:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"total"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"default"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"connect"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"subscribe"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"publish"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"history"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"presence"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"presence_stats"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"refresh"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"sub_refresh"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rpc"})," (with optional method resolution)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The configuration is very similar:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n    ...\n    "user_command_throttling": {\n        "enabled": true,\n\n        "default": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 60\n                },\n            ]\n        },\n        "publish": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 1\n                }\n            ]\n        },\n        "rpc": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 10\n                }\n            ],\n            "method_override": [\n                {\n                    "method": "updateActiveStatus",\n                    "buckets": [\n                        {\n                            "interval": "20s",\n                            "rate": 1\n                        }\n                    ]\n                }\n            ]\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"redis-per-user-throttling",children:"Redis per user throttling"}),"\n",(0,i.jsx)(n.p,{children:"The next type of throttling in Centrifugo PRO is a distributed per user ID throttling with Redis as a bucket state storage. In this case limits are global for the entire Centrifugo cluster. If one user executed two commands on different Centrifugo nodes, Centrifugo consumes two tokens from the same bucket kept in Redis. Since this throttling goes to Redis to check limits, it adds some latency to a command processing. Our implementation tries to provide good throughput characteristics though \u2013 in our tests single Redis instance can handle more than 100k limit check requests per second. And it's possible to scale Redis in the same ways as for Centrifugo Redis Engine."}),"\n",(0,i.jsxs)(n.p,{children:["This type of throttling only checks commands coming from authenticated users \u2013 i.e. with non-empty user ID set. Requests from anonymous users can't be throttled with it. The implementation also uses ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Token_bucket",children:"token bucket"})," algorithm internally."]}),"\n",(0,i.jsxs)(n.p,{children:["The list of operations which can be throttled is similar to the in-memory user command throttling described above. But ",(0,i.jsx)(n.strong,{children:"without"})," special bucket ",(0,i.jsx)(n.code,{children:"total"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"default"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"connect"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"subscribe"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"publish"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"history"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"presence"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"presence_stats"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"refresh"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"sub_refresh"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rpc"})," (with optional method resolution)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The configuration is very similar:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n    ...\n    "redis_user_command_throttling": {\n        "enabled": true,\n        "redis_address": "localhost:6379",\n\n        "default": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 60\n                },\n            ]\n        },\n        "publish": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 1\n                }\n            ]\n        },\n        "rpc": {\n            "buckets": [\n                {\n                    "interval": "1s",\n                    "rate": 10\n                }\n            ],\n            "method_override": [\n                {\n                    "method": "updateActiveStatus",\n                    "buckets": [\n                        {\n                            "interval": "20s",\n                            "rate": 1\n                        }\n                    ]\n                }\n            ]\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Redis configuration for throttling feature matches Centrifugo Redis engine configuration. So Centrifugo supports client-side consistent sharding to scale Redis, Redis Sentinel, Redis Cluster for throttling feature too."}),"\n",(0,i.jsxs)(n.p,{children:["It's also possible to reuse Centrifugo Redis engine by setting ",(0,i.jsx)(n.code,{children:"use_redis_from_engine"})," option instead of custom throttling Redis configuration declaration, like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n    ...\n    "engine": "redis",\n    "redis_address": "localhost:6379",\n    "redis_user_command_throttling": {\n        "enabled": true,\n        "use_redis_from_engine": true,\n        ...\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"In this case throttling will simply connect to Redis instances configured for an Engine."}),"\n",(0,i.jsx)(n.h2,{id:"disconnecting-abusive-or-misbehaving-connections",children:"Disconnecting abusive or misbehaving connections"}),"\n",(0,i.jsx)(n.p,{children:"Above we showed how you can define throttling strategies to protect server resources and prevent execution of many commands inside the connection and from certain user."}),"\n",(0,i.jsx)(n.p,{children:"But there are scenarios when abusive or broken connections may generate a significant load on the server just by calling commands and getting error responses due to throttling or due to other reasons (like malformed command). Centrifugo PRO provides a way to configure error limits per connection to deal with this case."}),"\n",(0,i.jsxs)(n.p,{children:["Error limits are configured as in-memory buckets operating on a per-connection level. When these buckets are full due to lots of errors for an individual connection Centrifugo disconnects the client (with advice to not reconnect, so our SDKs may follow it). This way it's possible to get rid of the connection and rely on HTTP infrastracture tools to deal with client reconnections. Since WebSocket or other our transports (except unidirectional GRPC, but it's usually not available to the public port) are HTTP-based (or start with HTTP request in WebSocket Upgrade case) \u2013 developers can use Nginx ",(0,i.jsx)(n.code,{children:"limit_req_zone"})," directive, Cloudflare rules, iptables, and so on, to protect Centrifugo from unwanted connections."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Centrifugo PRO does not count internal errors for the error limit buckets \u2013 as internal errors is usually not a client's fault."})}),"\n",(0,i.jsx)(n.p,{children:"The configuration on error limits per connection may look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n    ...\n    "client_error_limits": {\n        "enabled": true,\n        "total": {\n            "buckets" : [\n                {\n                    "interval": "5s",\n                    "rate": 20\n                }\n            ]\n        }\n    }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},54195:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/throttling-07d51ebeea022e4f37529186cb5b7ccb.png"},11151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>s});var i=t(67294);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);