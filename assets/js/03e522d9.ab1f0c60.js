"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[2624],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>k});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),k=r,m=c["".concat(s,".").concat(k)]||c[k]||u[k]||o;return n?a.createElement(m,i(i({ref:t},d),{},{components:n})):a.createElement(m,i({ref:t},d))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},44310:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const o={id:"token_revocation",title:"Token revocation API"},i=void 0,l={unversionedId:"pro/token_revocation",id:"pro/token_revocation",title:"Token revocation API",description:"One more protective instrument in Centrifugo PRO is API to manage token revocations.",source:"@site/docs/pro/token_revocation.md",sourceDirName:"pro",slug:"/pro/token_revocation",permalink:"/docs/pro/token_revocation",draft:!1,editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/docs/pro/token_revocation.md",tags:[],version:"current",frontMatter:{id:"token_revocation",title:"Token revocation API"},sidebar:"Pro",previous:{title:"User blocking API",permalink:"/docs/pro/user_block"},next:{title:"Channel state events",permalink:"/docs/pro/channel_state_events"}},s={},p=[{value:"How it works",id:"how-it-works",level:2},{value:"Configure",id:"configure",level:2},{value:"Redis persistence engine",id:"redis-persistence-engine",level:3},{value:"Database persistence engine",id:"database-persistence-engine",level:3},{value:"Revoke token API",id:"revoke-token-api",level:2},{value:"revoke_token",id:"revoke_token",level:3},{value:"revoke_token params",id:"revoke_token-params",level:4},{value:"revoke_token result",id:"revoke_token-result",level:4},{value:"Invalidate user tokens API",id:"invalidate-user-tokens-api",level:2},{value:"invalidate_user_tokens",id:"invalidate_user_tokens",level:3},{value:"invalidate_user_tokens params",id:"invalidate_user_tokens-params",level:4},{value:"invalidate_user_tokens result",id:"invalidate_user_tokens-result",level:4}],d={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"One more protective instrument in Centrifugo PRO is API to manage token revocations."),(0,r.kt)("p",null,"At the moment Centrifugo provides two ways to revoke tokens:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Revoke token by ID: based on ",(0,r.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.7"},"jti")," claim in the case of JWT."),(0,r.kt)("li",{parentName:"ol"},"Revoke all user's tokens issued before certain time: based on ",(0,r.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.6"},"iat")," in the case of JWT.")),(0,r.kt)("p",null,"When token is revoked client with such token will be disconnected from Centrifugo shortly. And attempt to connect with a revoked token won't succeed."),(0,r.kt)("h2",{id:"how-it-works"},"How it works"),(0,r.kt)("p",null,"By default, information about token revocations shared throughout Centrifugo cluster and kept in a process memory. So token revocation information will be lost upon Centrifugo restart."),(0,r.kt)("p",null,"But it's possible to enable revocation information persistence by configuring a persistence storage \u2013 in this case token revocation information will survive Centrifugo restarts."),(0,r.kt)("p",null,"Centrifugo also automatically expires entries in the storage to keep working set reasonably small. Keeping pool of revoked tokens small allows avoiding expensive database lookups on every check \u2013 information is loaded periodically from the database and all checks performed over in-memory data structure \u2013 thus token revocation checks are cheap and have a small impact on the overall system performance."),(0,r.kt)("h2",{id:"configure"},"Configure"),(0,r.kt)("p",null,"Token revocation features (both revocation by token ID and user token invalidation by issue time) are enabled by default in Centrifugo PRO (as soon as your JWTs has ",(0,r.kt)("inlineCode",{parentName:"p"},"jti")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"iat")," claims you will be able to use revocation APIs). By default revocation information kept in a process memory."),(0,r.kt)("p",null,"There are two types of persistent engines supported at the moment:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"redis")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"database"))),(0,r.kt)("h3",{id:"redis-persistence-engine"},"Redis persistence engine"),(0,r.kt)("p",null,"Revocation data can be kept in Redis. To enable this configuration should be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n    ...\n    "token_revoke": {\n        "persistence_engine": "redis",\n        "redis_address": "localhost:6379"\n    },\n    "user_tokens_invalidate": {\n        "persistence_engine": "redis",\n        "redis_address": "localhost:6379"\n    }\n}\n')),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"Unlike many other Redis features in Centrifugo consistent sharding is not supported for revocation data. The reason is that we don't want to loose revocation information when additional Redis node added. So only one Redis shard can be provided for ",(0,r.kt)("inlineCode",{parentName:"p"},"token_revoke")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"user_tokens_invalidate")," features. This should be fine given that working set of revoked entities should be reasonably small and old entries expire. If you try to set several Redis shards here Centrifugo will exit with an error on start.")),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"One more thing you may notice is that Redis configuration here does not have ",(0,r.kt)("inlineCode",{parentName:"p"},"use_redis_from_engine")," option. The reason is that since Redis is not shardable here reusing Redis configuration here could cause problems at the moment of main Redis scaling \u2013 which we want to avoid thus require explicit configuration here.")),(0,r.kt)("h3",{id:"database-persistence-engine"},"Database persistence engine"),(0,r.kt)("p",null,"Revocation data can be kept in the relational database. Only PostgreSQL is supported."),(0,r.kt)("p",null,"To enable this configuration should be like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n    ...\n    "database": {\n        "dsn": "postgresql://postgres:pass@127.0.0.1:5432/postgres"\n    },\n    "token_revoke": {\n        "persistence_engine": "database"\n    },\n    "user_tokens_invalidate": {\n        "persistence_engine": "database"\n    }\n}\n')),(0,r.kt)("h2",{id:"revoke-token-api"},"Revoke token API"),(0,r.kt)("h3",{id:"revoke_token"},"revoke_token"),(0,r.kt)("p",null,"Allows revoking individual tokens. For example, this may be useful when token leakage has been detected and you want to revoke access for a particular tokens. BTW Centrifugo PRO provides ",(0,r.kt)("inlineCode",{parentName:"p"},"user_connections")," API which has an information about tokens for active users connections (if set in JWT). "),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"This API assumes that JWTs you are using contain ",(0,r.kt)("inlineCode",{parentName:"p"},'"jti"')," claim which is a unique token ID (according to ",(0,r.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.7"},"RFC"),").  ")),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'curl --header "Content-Type: application/json" \\\n  --header "X-API-Key: <API_KEY>" \\\n  --request POST \\\n  --data \'{"uid": "xxx-xxx-xxx", "expire_at": 1635845122}\' \\\n  http://localhost:8000/api/revoke_token\n')),(0,r.kt)("h4",{id:"revoke_token-params"},"revoke_token params"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter name"),(0,r.kt)("th",{parentName:"tr",align:null},"Parameter type"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uid"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Token unique ID (JTI claim in case of JWT)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expire_at"),(0,r.kt)("td",{parentName:"tr",align:null},"int"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"Unix time in the future when revocation information should expire (Unix seconds). While optional ",(0,r.kt)("strong",{parentName:"td"},"we recommend to use a reasonably small expiration time (matching the expiration time of your JWTs)")," to keep working set of revocations small (since Centrifugo nodes periodically load all entries from the database table to construct in-memory cache).")))),(0,r.kt)("h4",{id:"revoke_token-result"},"revoke_token result"),(0,r.kt)("p",null,"Empty object at the moment."),(0,r.kt)("h2",{id:"invalidate-user-tokens-api"},"Invalidate user tokens API"),(0,r.kt)("h3",{id:"invalidate_user_tokens"},"invalidate_user_tokens"),(0,r.kt)("p",null,"Allows revoking all tokens for a user which were issued before a certain time. For example, this may be useful after user changed a password in an application."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"This API assumes that JWTs you are using contain ",(0,r.kt)("inlineCode",{parentName:"p"},'"iat"')," claim which is a time token was issued at (according to ",(0,r.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.6"},"RFC"),").  ")),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'curl --header "Content-Type: application/json" \\\n  --header "X-API-Key: <API_KEY>" \\\n  --request POST \\\n  --data \'{"user": "test", "issued_before": 1635845022, "expire_at": 1635845122}\' \\\n  http://localhost:8000/api/invalidate_user_tokens\n')),(0,r.kt)("h4",{id:"invalidate_user_tokens-params"},"invalidate_user_tokens params"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter name"),(0,r.kt)("th",{parentName:"tr",align:null},"Parameter type"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"user"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"User ID to invalidate tokens for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"issued_before"),(0,r.kt)("td",{parentName:"tr",align:null},"int"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"All tokens issued at before this Unix time will be considered revoked (in case of JWT this requires ",(0,r.kt)("inlineCode",{parentName:"td"},"iat")," to be properly set in JWT), if not provided server uses current time")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expire_at"),(0,r.kt)("td",{parentName:"tr",align:null},"int"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"Unix time in the future when revocation information should expire (Unix seconds). While optional ",(0,r.kt)("strong",{parentName:"td"},"we recommend to use a reasonably small expiration time (matching the expiration time of your JWTs)")," to keep working set of revocations small (since Centrifugo nodes periodically load all entries from the database table to construct in-memory cache).")))),(0,r.kt)("h4",{id:"invalidate_user_tokens-result"},"invalidate_user_tokens result"),(0,r.kt)("p",null,"Empty object."))}u.isMDXComponent=!0}}]);