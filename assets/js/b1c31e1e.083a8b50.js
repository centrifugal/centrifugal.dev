"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[5688],{14785:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var i=n(85893),s=n(11151);const a={title:"Proper real-time document state synchronization within Centrifugal ecosystem",tags:["centrifugo","centrifuge","websocket","docsync"],description:"A simple yet cool example of document state synchronization on top of Centrifugal stack. The end goal is to effectively and reliably synchronize document state to application users \u2013 to avoid race condition between state load and updates coming from the real-time subscription.",author:"Alexander Emelin",authorTitle:"Founder of Centrifugal Labs",authorImageURL:"/img/alexander_emelin.jpeg",image:"/img/docsync_cover.jpg",hide_table_of_contents:!1},o=void 0,r={permalink:"/blog/2024/06/03/real-time-document-state-sync",editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/blog/2024-06-03-real-time-document-state-sync.md",source:"@site/blog/2024-06-03-real-time-document-state-sync.md",title:"Proper real-time document state synchronization within Centrifugal ecosystem",description:"A simple yet cool example of document state synchronization on top of Centrifugal stack. The end goal is to effectively and reliably synchronize document state to application users \u2013 to avoid race condition between state load and updates coming from the real-time subscription.",date:"2024-06-03T00:00:00.000Z",tags:[{label:"centrifugo",permalink:"/blog/tags/centrifugo"},{label:"centrifuge",permalink:"/blog/tags/centrifuge"},{label:"websocket",permalink:"/blog/tags/websocket"},{label:"docsync",permalink:"/blog/tags/docsync"}],readingTime:11.13,hasTruncateMarker:!1,authors:[{name:"Alexander Emelin",title:"Founder of Centrifugal Labs",imageURL:"/img/alexander_emelin.jpeg"}],frontMatter:{title:"Proper real-time document state synchronization within Centrifugal ecosystem",tags:["centrifugo","centrifuge","websocket","docsync"],description:"A simple yet cool example of document state synchronization on top of Centrifugal stack. The end goal is to effectively and reliably synchronize document state to application users \u2013 to avoid race condition between state load and updates coming from the real-time subscription.",author:"Alexander Emelin",authorTitle:"Founder of Centrifugal Labs",authorImageURL:"/img/alexander_emelin.jpeg",image:"/img/docsync_cover.jpg",hide_table_of_contents:!1},unlisted:!1,prevItem:{title:"Performance optimizations of WebSocket compression in Go application",permalink:"/blog/2024/08/19/optimizing-websocket-compression"},nextItem:{title:"Experimenting with real-time data compression by simulating a football match events",permalink:"/blog/2024/05/30/real-time-data-compression-experiments"}},l={authorsImageUrls:[void 0]},c=[{value:"Complexities in state sync",id:"complexities-in-state-sync",level:2},{value:"Gap in time",id:"gap-in-time",level:3},{value:"Re-sync upon lost continuity",id:"re-sync-upon-lost-continuity",level:3},{value:"Late delivery of real-time updates",id:"late-delivery-of-real-time-updates",level:3},{value:"Core principles of solution",id:"core-principles-of-solution",level:2},{value:"Top-level API of RealTimeDocument",id:"top-level-api-of-realtimedocument",level:2},{value:"Implementing solution",id:"implementing-solution",level:2},{value:"Let&#39;s apply it",id:"lets-apply-it",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("img",{src:"/img/docsync_cover.jpg"}),"\n",(0,i.jsx)(t.p,{children:"Centrifugo and its main building block Centrifuge library for Go both provide a way for clients to receive a stream of events in channels using Subscription objects. Also, there is an automatic history recovery feature which allows clients catching up with missed publications after the reconnect to the WebSocket server and restore the state of a real-time component. While the continuity in the stream is not broken clients can avoid re-fetching a state from the main application database \u2013 which optimizes a scenario when many real-time connections reconnect all within a short time interval (for example, during a load balancer restart) by reducing the excessive load on the application database."}),"\n",(0,i.jsx)(t.p,{children:"Usually, our users who use recovery features load the document state from the backend, then establish a real-time Subscription to apply changes to the component state coming from the real-time channel. After that the component stays synchronized, even after network issues \u2013 due to Centrifugo recovery feature the document state becomes actual again since client catches up the state from the channel history stream."}),"\n",(0,i.jsx)(t.p,{children:"There are several hidden complexities in the process though and things left for users to implement. We want to address those here."}),"\n",(0,i.jsxs)(t.p,{children:["In the post we assume that you are using a channnel with history configured and recovery on, i.e. using a namespace with ",(0,i.jsx)(t.code,{children:"history_size"}),", ",(0,i.jsx)(t.code,{children:"history_ttl"})," and ",(0,i.jsx)(t.code,{children:"force_recovery"})," on, see more details in ",(0,i.jsx)(t.a,{href:"/docs/server/history_and_recovery",children:"History and recovery\n"})," doc chapter."]}),"\n",(0,i.jsx)(t.h2,{id:"complexities-in-state-sync",children:"Complexities in state sync"}),"\n",(0,i.jsx)(t.h3,{id:"gap-in-time",children:"Gap in time"}),"\n",(0,i.jsx)(t.p,{children:"The first edge case comes from the fact that there is a possible gap in time between initial loading of the state from the main app database and real-time subscription establishment. Some messages could be published in between of state loading and real-time subscription establishment. So there is a chance that due to this gap in time the component will live in the inconsistent state until the next application page reload. For many apps this is not critical at all, or due to message rates happens very rarely. But in this post we will look at the possible approach to avoid such a case."}),"\n",(0,i.jsx)(t.p,{children:"Or imagine a situation when state is loaded, but real-time subscription is delayed due to some temporary error. This increases a gap in time and a chance to miss an intermediary update."}),"\n",(0,i.jsx)(t.p,{children:"Centrifugo channel stream offsets are not binded to the application business models in any way, so it's not possible to initially subscribe to the real-time channel and receive all updates happened since the snapshot of the document loaded from the database. There is a way to solve this though, we will cover it shortly."}),"\n",(0,i.jsx)(t.h3,{id:"re-sync-upon-lost-continuity",children:"Re-sync upon lost continuity"}),"\n",(0,i.jsxs)(t.p,{children:["Another complexity which is left to the user is the need to react on ",(0,i.jsx)(t.code,{children:"recovered: false"})," flag provided by the SDK when client can not catch up the state upo re-subscription. This may happen due to channel history retention configuration, or simply because history was lost. In this case our SDKs provide users ",(0,i.jsx)(t.code,{children:"wasRecovering: true"})," and ",(0,i.jsx)(t.code,{children:"recovered: false"})," flags, and we suggest re-fetching the document state from the backend in such cases. But while you re-fetch the state you are still receiving real-time updates from the subscription \u2013 which leads us to something similar to the problem described above, same race conditions may happen leaving the component in the inconsistent state until reload."]}),"\n",(0,i.jsx)(t.h3,{id:"late-delivery-of-real-time-updates",children:"Late delivery of real-time updates"}),"\n",(0,i.jsx)(t.p,{children:"One more possible problem to discuss is a late delivery of real-time messages."}),"\n",(0,i.jsx)(t.p,{children:"When you want to reliably stream document changes to Centrifugo (without loosing any update, due to temporary network issues for example) and keep the order of changes (to not occasionally apply property addition and deletion is different order on the client side) your best bet is using transactional outbox or CDC approaches. So that changes in the database are made atomic and there is a guarantee that the update will be soon issued to the real-time channel of Centrifuge-based server or Centrifugo. Usually transactional outbox or CDC can also maintain correct order of event processing, thus correct order of publising to the real-time channel."}),"\n",(0,i.jsx)(t.p,{children:"But this means that upon loading a real-time component it may receive non-actual real-time updates from the real-time subscription \u2013 due to outbox table or CDC processing lag. We need a way for the client side to understand whether the update must be applied to the document state or not. Sometimes it's possible to understand due to the nature of component. Like receiving an update with some identifier which already exists in the object on client side. But what if update contains deletion of some property of object? This will mean that object may rollback to non-actual state, then will receive next real-time updates which will move it to back to the actual state. We want to avoid such modifications leading to temporary state glitches at all. Not all cases allow having idempotent real-time updates."}),"\n",(0,i.jsx)(t.p,{children:"Even when you are not using outbox/CDC you can still hit a situation of late real-time message delivery. Let's suppose you publish messages to Centrifugal channel synchronously over server publish API reducing the chance of having a lag from the outbox/CDC processing. But the lag may still present. Because while message travelling towards subscriber through Centrifugo, subscriber can load a more freshy initial state from the main database and subscribe to the real-time channel."}),"\n",(0,i.jsx)(t.h2,{id:"core-principles-of-solution",children:"Core principles of solution"}),"\n",(0,i.jsxs)(t.p,{children:["In this post we will write a ",(0,i.jsx)(t.code,{children:"RealTimeDocument"})," JavaScript class designed to synchronize a document state. This class handles initial data loading, real-time updates, and state re-synchronization when required. It should solve the problems described above."]}),"\n",(0,i.jsx)(t.p,{children:"The good thing is that this helper class is compact enough to be implemented in any programming language, so you can apply it (or the required part of it) for other languages where we already have real-time SDKs."}),"\n",(0,i.jsx)(t.p,{children:"We will build the helper on top of several core principles:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The document has an incremental version which is managed atomically and transactionally on the backend."}),"\n",(0,i.jsxs)(t.li,{children:["Initial state loading returns document state together with the current version, loading happens with at least ",(0,i.jsx)(t.code,{children:"read committed"})," transactional isolation level (default in many databases, ex. PostgreSQL)"]}),"\n",(0,i.jsx)(t.li,{children:"All real-time updates published to the document channel have the version attached, and updates are published to the channel in the correct version order."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["We already discussed the approach in our ",(0,i.jsx)(t.a,{href:"/docs/tutorial/intro",children:"Grand tutorial"})," \u2013 but now want to generalize it as a re-usable pattern."]}),"\n",(0,i.jsxs)(t.p,{children:["After writing a ",(0,i.jsx)(t.code,{children:"RealTimeDocument"})," wrapper we will apply it to a simple example of synchronizing counter increments across multiple devices reliably to demonstrate it works. Eventually we get best from two worlds \u2013 leveraging Centrifugo publication cache to avoid excessive load on the backend upon massive reconnect and proper document state in all scenarios."]}),"\n",(0,i.jsx)(t.h2,{id:"top-level-api-of-realtimedocument",children:"Top-level API of RealTimeDocument"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"const subscription = centrifuge.newSubscription('counter', {});\n\nconst realTimeDocument = new RealTimeDocument({\n    subscription, // Wraps Subscription.\n    load: async (): Promise<{ document: any; version: number }> => {\n        // Must load the actual document state and version from the database.\n        // Ex. return { document: result.document, version: result.version };\n    },\n    applyUpdate: (currentDocument: any, update: any): any => {\n        // Must apply update to the document.\n        // currentDocument.value += update.increment;\n        // return currentDocument;\n    },\n    compareVersion: (currentVersion: number, update: any): number | null => {\n        // Must compare versions in real-time publication and current doc version.\n        // const newVersion = publication.data.version;\n        // return newVersion > currentVersion ? newVersion : null;\n    },\n    onChange: (document: any) => {\n        // Will be called once the document is loaded for the first time and every time\n        // the document state is updated. This is where application may render things\n        // based on the document data.\n    }\n});\n\nrealTimeDocument.startSync();\n"})}),"\n",(0,i.jsx)(t.h2,{id:"implementing-solution",children:"Implementing solution"}),"\n",(0,i.jsx)(t.p,{children:"To address the gap between state load and real-time subscription establishment the obvious solution which is possible with Centrifugal stack is to make the real-time subscription first, and only after that load the state from the backend. This eliminates the possibility to miss messages. But until the state is loaded we need to buffer real-time publications and then apply them to the loaded state."}),"\n",(0,i.jsx)(t.p,{children:"Here is where the concept of having incremental document version helps \u2013 we can collect messages in the buffer, and then apply only those with version greater than current document version. So that the object will have the correct state after the initial load."}),"\n",(0,i.jsx)(t.p,{children:"Here is how we can process real-time publications:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"this.#subscription.on('publication', (ctx) => {\n    if (!this.#isLoaded) {\n        // Buffer messages until initial state is loaded.\n        this.#messageBuffer.push(ctx);\n        return;\n    }\n    // Process new messages immediately if initial state is already loaded.\n    const newVersion = this.#compareVersion(ctx.data, this.#version);\n    if (newVersion === null) {\n        // Skip real-time publication, non actual version.\n        return;\n    }\n    this.#document = this.#applyUpdate(this.#document, ctx.data);\n    this.#version = newVersion;\n    this.#onChange(this.#document);\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["And we also need to handle ",(0,i.jsx)(t.code,{children:"subscribed"})," event properly and load the initial document state from the backend:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"this.#subscription.on('subscribed', (ctx) => {\n    if (ctx.wasRecovering) {\n        if (ctx.recovered) {\n            // Successfully re-attached to a stream, nothing else to do.\n        } else {\n            // Re-syncing due to failed recovery.\n            this.#reSync();\n        }\n    } else {\n        // Load data for the first time.\n        this.#loadDocumentApplyBuffered();\n    }\n})\n"})}),"\n",(0,i.jsxs)(t.p,{children:["For the initial load ",(0,i.jsx)(t.code,{children:"this.#loadDocumentApplyBuffered()"})," will be called. Here is how it may look like:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"async #loadDocumentApplyBuffered() {\n    try {\n        const result = await this.#load();\n        this.#document = result.document;\n        this.#version = result.version;\n        this.#isLoaded = true;\n        this.#processBufferedMessages();\n    } catch (error) {\n        // Retry the loading, in the final snippet it's implemented\n        // and uses exponential backoff for the retry process.\n    }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["After loading the state we prosess buffered real-time publications inside ",(0,i.jsx)(t.code,{children:"#processBufferedMessages"})," method:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"#processBufferedMessages() {\n    this.#messageBuffer.forEach((msg) => {\n        const newVersion = this.#compareVersion(msg, this.#version);\n        if (newVersion) { // Otherwise, skip buffered publication.\n            this.#document = this.#applyUpdate(this.#document, msg.data);\n            this.#version = newVersion;\n        }\n    });\n    // Clear the buffer after processing.\n    this.#messageBuffer = [];\n    // Only call onChange with final document state.\n    this.#onChange(this.#document);\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This way the initial state is loaded correctly. Note also, that version comparisons also help with handling late delivered real-time updates \u2013 we now simply skip them inside ",(0,i.jsx)(t.code,{children:"on('publication')"})," callback."]}),"\n",(0,i.jsx)(t.p,{children:"Let's go back and look how to manage stream continuity loss:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"if (ctx.recovered) {\n    // Successfully re-attached to a stream, nothing else to do.\n} else {\n    // Re-syncing due to failed recovery.\n    this.#reSync();\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In this case we call ",(0,i.jsx)(t.code,{children:"#reSync"})," method:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"#reSync() {\n    this.#isLoaded = false; // Reset the flag to collect new messages to the buffer.\n    this.#messageBuffer = [];\n    this.#loadDocumentApplyBuffered();\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["It basically clears up the class state and calls ",(0,i.jsx)(t.code,{children:"#loadDocumentApplyBuffered"})," again \u2013 repeating the initial sync procedure."]}),"\n",(0,i.jsxs)(t.p,{children:["That's it. Here is ",(0,i.jsx)(t.a,{href:"https://raw.githubusercontent.com/centrifugal/centrifuge/master/_examples/document_sync/rtdocument.js",children:"a full code"})," for the ",(0,i.jsx)(t.code,{children:"RealTimeDocument"})," class. Note, it also contains backoff implementation to handle possible error while loading the document state from the backend endpoint."]}),"\n",(0,i.jsx)(t.h2,{id:"lets-apply-it",children:"Let's apply it"}),"\n",(0,i.jsxs)(t.p,{children:["I've made a ",(0,i.jsx)(t.a,{href:"https://github.com/centrifugal/centrifuge/tree/master/_examples/document_sync",children:"POC"})," with Centrifuge library to make sure this works."]}),"\n",(0,i.jsxs)(t.p,{children:["In that example I tried to apply ",(0,i.jsx)(t.code,{children:"RealTimeDocument"})," class to synchronize state of the counter. Periodically timer is incremented on a random value in range [0,9] on the backend and these increments are published to the real-time channel. Note, I could simply publish counter value in every publication over WebSocket \u2013 but intentionally decided to send counter increments instead. To make sure nothing is lost during state synchronization so counter value is always correct on the client side."]}),"\n",(0,i.jsx)(t.p,{children:"Here is a demo:"}),"\n",(0,i.jsx)("div",{class:"vimeo-full-width",children:(0,i.jsx)("iframe",{src:"/img/docsync.mp4",frameBorder:"0",allow:"autoplay; fullscreen",allowFullScreen:!0})}),"\n",(0,i.jsxs)(t.p,{children:["Let's look at how ",(0,i.jsx)(t.code,{children:"RealTimeDocument"})," class was used in the example:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"const counterContainer = document.getElementById(\"counter\");\n\nconst client = new Centrifuge('ws://localhost:8000/connection/websocket', {});\nconst subscription = client.newSubscription('counter', {});\n\nconst realTimeDocument = new RealTimeDocument({\n    subscription,\n    load: async () => {\n        const response = await fetch('/api/counter');\n        const result = await response.json();\n        return { document: result.value, version: result.version };\n    },\n    applyUpdate: (document, update) => {\n        document += update.increment\n        return document\n    },\n    compareVersion: (currentVersion, update) => {\n        const newVersion = update.version;\n        return newVersion > currentVersion ? newVersion : null;\n    },\n    onChange: (document) => {\n        counterContainer.textContent = document;\n    },\n    debug: true,\n});\nclient.connect();\n\n// Note \u2013 we can call sync even before connect.\nrealTimeDocument.startSync();\n"})}),"\n",(0,i.jsx)(t.p,{children:"Things to observe:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["We return ",(0,i.jsx)(t.code,{children:'{"version":4823,"value":21656}'})," from ",(0,i.jsx)(t.code,{children:"/api/counter"})]}),"\n",(0,i.jsxs)(t.li,{children:["Send ",(0,i.jsx)(t.code,{children:'{"version":4824,"increment":9}'})," over real-time channel"]}),"\n",(0,i.jsx)(t.li,{children:"Counter updated every 250 milliseconds, history size is 20, retention 10 seconds"}),"\n",(0,i.jsxs)(t.li,{children:["Upon going offline for a short period we see that ",(0,i.jsx)(t.code,{children:"/api/counter"})," endpoint not called at all - state fully cought up from Centrifugo history stream"]}),"\n",(0,i.jsx)(t.li,{children:"Upon going offline for a longer period Centrifugo was not able to recover the state, so we re-fetched data from scratch and attached to the stream again."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(t.p,{children:["In this post, we walked through a practical implementation of a ",(0,i.jsx)(t.code,{children:"RealTimeDocument"})," class using Centrifugal stack for the real-time state synchronization to achieve proper eventually consistent state of the document when using real-time updates. We mentioned possible gotchas when trying to sync the state in real-time and described a generic solution to it."]}),"\n",(0,i.jsx)(t.p,{children:"You don't need to always follow the solution here. As I mentioned it's possible that your app does not require handling all these edge cases, or they could be handled in alternative ways \u2013 this heavily depends on your app business logic."}),"\n",(0,i.jsxs)(t.p,{children:["Note, that with some changes you can make ",(0,i.jsx)(t.code,{children:"RealTimeDocument"})," class to behave properly and support graceful degradation behaviour. If there are issues with real-time subscription you can still load the document and display it, and then re-sync the state as soon as a real-time system becomes available (successful subscription)."]})]})}function h(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>o});var i=n(67294);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);