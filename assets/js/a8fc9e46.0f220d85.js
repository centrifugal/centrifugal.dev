"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[9493],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(96540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},90848:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"pro/channel_state_events","title":"Channel state events","description":"Centrifugo PRO channel state events send occupied and vacated webhooks when subscribers join or leave channels. Requires Redis engine.","source":"@site/docs/pro/channel_events.md","sourceDirName":"pro","slug":"/pro/channel_state_events","permalink":"/docs/pro/channel_state_events","draft":false,"unlisted":false,"editUrl":"https://github.com/centrifugal/centrifugal.dev/edit/main/docs/pro/channel_events.md","tags":[],"version":"current","frontMatter":{"description":"Centrifugo PRO channel state events send occupied and vacated webhooks when subscribers join or leave channels. Requires Redis engine.","id":"channel_state_events","sidebar_label":"Channel state events","title":"Channel state events"},"sidebar":"Pro","previous":{"title":"Token revocation API","permalink":"/docs/pro/token_revocation"},"next":{"title":"Cache empty events","permalink":"/docs/pro/channel_cache_empty"}}');var a=t(74848),i=t(28453);const r={description:"Centrifugo PRO channel state events send occupied and vacated webhooks when subscribers join or leave channels. Requires Redis engine.",id:"channel_state_events",sidebar_label:"Channel state events",title:"Channel state events"},o=void 0,c={},l=[];function d(e){const n={a:"a",admonition:"admonition",code:"code",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Centrifugo PRO has a feature to enable channel state event webhooks to be sent to your configured backend endpoint:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["channel ",(0,a.jsx)(n.code,{children:"occupied"})," event - called whenever first subscriber occupies the channel"]}),"\n",(0,a.jsxs)(n.li,{children:["channel ",(0,a.jsx)(n.code,{children:"vacated"})," event - called whenever last subscriber leaves the channel"]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{title:"Preview state",type:"info",children:(0,a.jsxs)(n.p,{children:["This feature is ",(0,a.jsx)(n.strong,{children:"in the preview state now"}),". We still need some time before it will be ready for usage in production. But the feature is available for evaluation."]})}),"\n",(0,a.jsxs)(n.p,{children:["To enable the feature you must use ",(0,a.jsx)(n.code,{children:"redis"})," engine. Also, only channels with ",(0,a.jsx)(n.code,{children:"presence"})," enabled may deliver channel state notifications. When enabling channel state proxy Centrifugo PRO starts using another approach to create Redis keys for presence for namespaces where channel state events enabled, this is an important implementation detail."]}),"\n",(0,a.jsx)(n.admonition,{type:"caution",children:(0,a.jsxs)(n.p,{children:["When using client-side Redis sharding (multiple Redis shard addresses), changing the number of shards while the system has active state will result in temporary event loss. Some partitions will be routed to different shards after the change, but their data (presence entries, pending vacated events, event streams) remains on the old shards. This leads to missed ",(0,a.jsx)(n.code,{children:"vacated"})," events and orphaned state. The system will recover as clients reconnect and re-establish presence, but channels where all clients have already disconnected will never receive a ",(0,a.jsx)(n.code,{children:"vacated"})," event. If this is acceptable, the change can be made while the system operates. Otherwise, consider using Redis Cluster instead \u2014 it handles slot migration transparently and is fully compatible with this feature."]})}),"\n",(0,a.jsxs)(n.p,{children:["So the minimal config can look like this (",(0,a.jsx)(n.code,{children:"occupied"})," and ",(0,a.jsx)(n.code,{children:"vacated"})," events for channels in ",(0,a.jsx)(n.code,{children:"chat"})," namespace will be sent to ",(0,a.jsx)(n.code,{children:"channel.proxy.state.endpoint"}),"):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",metastring:"title=config.json",children:'{\n  "engine": {\n    "type": "redis"\n  },\n  "channel": {\n    "proxy": {\n      "state": {\n        "endpoint": "http://localhost:3000/centrifugo/channel_events"\n      }\n    },\n    "namespaces": [\n      {\n        "name": "chat",\n        "presence": true,\n        "state_proxy_enabled": true\n      }\n    ]\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The proxy endpoint is an extension of ",(0,a.jsx)(n.a,{href:"/docs/server/proxy",children:"Centrifugo OSS proxy"})," and supports both HTTP and GRPC transports. For GRPC, use the ",(0,a.jsx)(n.code,{children:"grpc://"})," prefix in the endpoint URL. Proto definitions may be found in the ",(0,a.jsx)(n.a,{href:"https://github.com/centrifugal/centrifugo/blob/master/internal/proxyproto/proxy.proto",children:"proxy.proto"})," file - see ",(0,a.jsx)(n.code,{children:"NotifyChannelState"})," rpc. Example of the payload your backend HTTP request handler will receive:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n    "events": [\n        {"channel": "chat:index", "type": "occupied", "time_ms": 1697206286533},\n    ]\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Payload may contain a batch of events, that's why ",(0,a.jsx)(n.code,{children:"events"})," is an array \u2013 this is important for achieving a high event throughput. Your backend must be fast enough to keep up with the events rate and volume, otherwise event queues will grow and eventually new events will be dropped by Centrifugo PRO."]}),"\n",(0,a.jsxs)(n.p,{children:["Respond with empty result object, without ",(0,a.jsx)(n.code,{children:"error"})," object set to let Centrifugo PRO know that events were processed successfully. If the request to the backend fails or the response contains an ",(0,a.jsx)(n.code,{children:"error"})," object, Centrifugo PRO will retry sending events with exponential backoff (from 100ms up to 20s)."]}),"\n",(0,a.jsx)(n.p,{children:"Here is an example of an HTTP handler for processing channel state events using Flask:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/centrifugo/channel_events', methods=['POST'])\ndef channel_events():\n    body = request.get_json()\n    for event in body.get('events', []):\n        channel = event['channel']\n        event_type = event['type']\n        time_ms = event['time_ms']\n        if event_type == 'occupied':\n            print(f'Channel {channel} occupied at {time_ms}')\n            # First subscriber joined the channel - allocate resources, etc.\n        elif event_type == 'vacated':\n            print(f'Channel {channel} vacated at {time_ms}')\n            # Last subscriber left the channel - clean up resources, etc.\n    return jsonify({'result': {}})\n\nif __name__ == '__main__':\n    app.run(port=3000)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["When the last subscriber leaves a channel, Centrifugo PRO delays the ",(0,a.jsx)(n.code,{children:"vacated"})," event by a configurable interval (default ",(0,a.jsx)(n.code,{children:"5s"}),") before sending it. If a client resubscribes during this interval, the ",(0,a.jsx)(n.code,{children:"vacated"})," event is cancelled. This avoids unnecessary webhooks for quick reconnect scenarios. These are configurable via ",(0,a.jsx)(n.code,{children:"channel_state"})," options. ",(0,a.jsx)(n.code,{children:"num_partitions"})," (default ",(0,a.jsx)(n.code,{children:"128"}),") sets the number of isolated partitions used to serialize channel state events in the system."]}),"\n",(0,a.jsx)(n.admonition,{type:"caution",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"num_partitions"})," must not be changed after the system is already operating with active channels. Changing it alters the channel-to-partition mapping, which means existing state in Redis (presence data, pending vacated events, event streams) becomes orphaned on old partitions. This will result in missed ",(0,a.jsx)(n.code,{children:"vacated"})," events for currently occupied channels and possible spurious ",(0,a.jsx)(n.code,{children:"occupied"}),"/",(0,a.jsx)(n.code,{children:"vacated"})," pairs as clients reconnect. The system will recover as clients reconnect and rebuild presence state, but channels where all clients have already disconnected will never receive a ",(0,a.jsx)(n.code,{children:"vacated"})," event. If this is acceptable, the change can be made while the system operates. Otherwise, plan the value before going to production and keep it fixed."]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "engine": {\n    "type": "redis",\n    "redis": {\n      "channel_state": {\n        "vacated_event_delay": "10s",\n        "num_partitions": 128\n      }\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"caution",children:(0,a.jsxs)(n.p,{children:["Redis used for channel state events should be configured with ",(0,a.jsx)(n.code,{children:"maxmemory-policy noeviction"})," (or a ",(0,a.jsx)(n.code,{children:"volatile-*"})," policy). The feature relies on several Redis keys without TTL (event streams, pending vacated queues, expiration tracking sets). If Redis evicts these keys under memory pressure, events will be permanently lost \u2014 occupied channels may never receive ",(0,a.jsx)(n.code,{children:"vacated"})," events. Consider using a ",(0,a.jsx)(n.a,{href:"/docs/server/engines#presence_manager",children:"separate presence manager"})," with a dedicated Redis instance for namespaces with channel state events enabled \u2014 this isolates memory usage from the main engine Redis and gives you full control over eviction policy."]})}),"\n",(0,a.jsx)(n.p,{children:"For example, to use a dedicated Redis instance for presence with channel state events:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "engine": {\n    "type": "redis"\n  },\n  "presence_manager": {\n    "enabled": true,\n    "type": "redis",\n    "redis": {\n      "address": "localhost:6380"\n    }\n  },\n  "channel": {\n    "proxy": {\n      "state": {\n        "endpoint": "http://localhost:3000/centrifugo/channel_events"\n      }\n    },\n    "namespaces": [\n      {\n        "name": "chat",\n        "presence": true,\n        "state_proxy_enabled": true\n      }\n    ]\n  }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Centrifugo PRO does the best effort delivering channel state events, making retries when the backend endpoint is unavailable (with exponential backoff), also survives cases when Centrifugo node dies unexpectedly. But there are scenarios when events may be lost \u2014 some of them are described above (Redis eviction, configuration changes). Even as best-effort notifications, channel state events can be very useful for applications \u2014 for example, to lazily clean up resources or update external state when channels become empty. For cases where stronger consistency is required, we recommend periodically syncing state by querying channel presence information using the server API."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);