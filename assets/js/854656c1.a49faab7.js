"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[3041],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},49086:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"transports/overview","title":"Real-time transports","description":"Centrifugo supports a variety of transports to deliver real-time messages to clients.","source":"@site/versioned_docs/version-5/transports/overview.md","sourceDirName":"transports","slug":"/transports/overview","permalink":"/docs/5/transports/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/centrifugal/centrifugal.dev/edit/main/versioned_docs/version-5/transports/overview.md","tags":[],"version":"5","frontMatter":{"id":"overview","title":"Real-time transports"},"sidebar":"Transports","next":{"title":"Client SDK API","permalink":"/docs/5/transports/client_api"}}');var s=t(74848),r=t(28453);const o={id:"overview",title:"Real-time transports"},a=void 0,c={},l=[{value:"Bidirectional",id:"bidirectional",level:2},{value:"Unidirectional",id:"unidirectional",level:2},{value:"PING/PONG behavior",id:"pingpong-behavior",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",img:"img",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Centrifugo supports a variety of transports to deliver real-time messages to clients."}),"\n",(0,s.jsx)(n.admonition,{title:"Every transport is a persistent connection",type:"info",children:(0,s.jsx)(n.p,{children:"Here we describe supported transports between your application frontend and Centrifugo itself. Every Centrifugo transport is a persistent connection so the server can push data towards clients at any moment."})}),"\n",(0,s.jsx)(n.p,{children:"The important distinction here is that all supported transports belong to one of two possible groups:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Bidirectional"}),"\n",(0,s.jsx)(n.li,{children:"Unidirectional"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"bidirectional",children:"Bidirectional"}),"\n",(0,s.jsx)(n.p,{children:"Bidirectional transports are capable to serve all Centrifugo features. These transports are the main Centrifugo focus and where Centrifugo really shines."}),"\n",(0,s.jsxs)(n.p,{children:["Bidirectional transports come with a cost that developers need to use a special client connector library (SDK) which speaks Centrifugo ",(0,s.jsx)(n.a,{href:"/docs/5/transports/client_protocol",children:"client protocol"}),". The reason why we need a special client connector library is that a bidirectional connection is asynchronous \u2013 it's required to match requests to responses, properly manage connection state, handle request queueing/timeouts/errors, etc. And of course to multiplex subscriptions to different channels over a single connection."]}),"\n",(0,s.jsxs)(n.p,{children:["Centrifugo has several official ",(0,s.jsx)(n.a,{href:"/docs/5/transports/client_sdk",children:"client SDKs"})," for popular environments. All of them work over ",(0,s.jsx)(n.a,{href:"/docs/5/transports/websocket",children:"WebSocket"})," transport. Our Javascript SDK also offers bidirectional fallbacks over ",(0,s.jsx)(n.a,{href:"/docs/5/transports/http_stream",children:"HTTP-Streaming"}),", ",(0,s.jsx)(n.a,{href:"/docs/5/transports/sse",children:"Server-Sent Events (SSE)"}),", ",(0,s.jsx)(n.a,{href:"/docs/5/transports/sockjs",children:"SockJS"}),", and has an experimental support for ",(0,s.jsx)(n.a,{href:"/docs/5/transports/webtransport",children:"WebTransport"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"unidirectional",children:"Unidirectional"}),"\n",(0,s.jsx)(n.p,{children:"Unidirectional transports suit well for simple use-cases with stable subscriptions, usually known at connection time."}),"\n",(0,s.jsxs)(n.p,{children:["The advantage is that unidirectional transports do not require special client connectors - developers can use native browser APIs (like ",(0,s.jsx)(n.a,{href:"/docs/5/transports/uni_websocket",children:"WebSocket"}),", ",(0,s.jsx)(n.a,{href:"/docs/5/transports/uni_sse",children:"EventSource/SSE"}),", ",(0,s.jsx)(n.a,{href:"/docs/5/transports/uni_http_stream",children:"HTTP-streaming"}),"), or ",(0,s.jsx)(n.a,{href:"/docs/5/transports/uni_grpc",children:"GRPC"})," generated code to receive real-time updates from Centrifugo. Thus avoiding dependency to a client connector that abstracts bidirectional communication."]}),"\n",(0,s.jsxs)(n.p,{children:["The drawback is that with unidirectional transports you are not inheriting all Centrifugo features out of the box (like dynamic subscriptions/unsubscriptions, automatic message recovery on reconnect, possibility to send RPC calls over persistent connection). But some of the missing client APIs can be mimicked by using calls to Centrifugo ",(0,s.jsx)(n.a,{href:"/docs/5/server/server_api",children:"server API"})," (i.e. over client -> application backend -> Centrifugo)."]}),"\n",(0,s.jsxs)(n.p,{children:["Learn more about ",(0,s.jsx)(n.a,{href:"/docs/5/transports/uni_client_protocol",children:"unidirectional protocol"})," and available unidirectional transports."]}),"\n",(0,s.jsx)(n.h2,{id:"pingpong-behavior",children:"PING/PONG behavior"}),"\n",(0,s.jsx)(n.p,{children:"Centrifugo server periodically sends pings to clients and expects pong from clients that works over bidirectional transports. Sending ping and receiving pong allows to find broken connections faster. Centrifugo sends pings on the Centrifugo client protocol level, thus it's possible for clients to handle ping messages on the client side to make sure connection is not broken (our bidirectional SDKs do this automatically)."}),"\n",(0,s.jsxs)(n.p,{children:["By default Centrifugo sends pings every 25 seconds. This may be changed using ",(0,s.jsx)(n.code,{children:"ping_interval"})," option (",(0,s.jsx)(n.a,{href:"/docs/5/server/configuration#setting-time-duration-options",children:"duration"}),", default ",(0,s.jsx)(n.code,{children:'"25s"'}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["Centrifugo expects pong message from bidirectional client SDK after sending ping to it. By default, it waits no more than 8 seconds before closing a connection. This may be changed using ",(0,s.jsx)(n.code,{children:"pong_timeout"})," option (",(0,s.jsx)(n.a,{href:"/docs/5/server/configuration#setting-time-duration-options",children:"duration"}),", default ",(0,s.jsx)(n.code,{children:'"8s"'}),")."]}),"\n",(0,s.jsx)(n.p,{children:"In most cases default ping/pong intervals are fine so you don't really need to tweak them. Reducing timeouts may help you to find non-gracefully closed connections faster, but will increase network traffic and CPU resource usage since ping/pongs are sent faster."}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ping_interval"})," must be greater than ",(0,s.jsx)(n.code,{children:"pong_timeout"})," in the current implementation."]})}),"\n",(0,s.jsx)(n.p,{children:"Here is a scheme how ping/pong works in bidirectional and unidirectional client scenarios:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(95076).A+"",width:"2396",height:"1435"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},95076:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/ping_pong-4f67ec945077864d9accb516406fb6d0.png"}}]);