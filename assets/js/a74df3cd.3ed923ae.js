"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[6567],{96265:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>t});var i=s(85893),o=s(11151);const a={id:"channels",title:"Channels and namespaces"},r=void 0,l={id:"server/channels",title:"Channels and namespaces",description:"Upon connecting to a server clients can subscribe to channels. Channel is one of the core concepts of Centrifugo. Most of the time when integrating Centrifugo you will work with channels and decide what is the best channel configuration for your application.",source:"@site/versioned_docs/version-4/server/channels.md",sourceDirName:"server",slug:"/server/channels",permalink:"/docs/4/server/channels",draft:!1,unlisted:!1,editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/versioned_docs/version-4/server/channels.md",tags:[],version:"4",frontMatter:{id:"channels",title:"Channels and namespaces"},sidebar:"Guides",previous:{title:"Client JWT authentication",permalink:"/docs/4/server/authentication"},next:{title:"Channel permission model",permalink:"/docs/4/server/channel_permissions"}},c={},t=[{value:"What is channel",id:"what-is-channel",level:2},{value:"Channel name rules",id:"channel-name-rules",level:2},{value:"namespace boundary (<code>:</code>)",id:"namespace-boundary-",level:3},{value:"user channel boundary (<code>#</code>)",id:"user-channel-boundary-",level:3},{value:"private channel prefix (<code>$</code>)",id:"private-channel-prefix-",level:3},{value:"Channel is just a string",id:"channel-is-just-a-string",level:3},{value:"Channel namespaces",id:"channel-namespaces",level:2},{value:"Channel options",id:"channel-options",level:2},{value:"presence",id:"presence",level:3},{value:"join_leave",id:"join_leave",level:3},{value:"force_push_join_leave",id:"force_push_join_leave",level:3},{value:"history_size",id:"history_size",level:3},{value:"history_ttl",id:"history_ttl",level:3},{value:"force_positioning",id:"force_positioning",level:3},{value:"force_recovery",id:"force_recovery",level:3},{value:"allow_subscribe_for_client",id:"allow_subscribe_for_client",level:3},{value:"allow_subscribe_for_anonymous",id:"allow_subscribe_for_anonymous",level:3},{value:"allow_publish_for_subscriber",id:"allow_publish_for_subscriber",level:3},{value:"allow_publish_for_client",id:"allow_publish_for_client",level:3},{value:"allow_publish_for_anonymous",id:"allow_publish_for_anonymous",level:3},{value:"allow_history_for_subscriber",id:"allow_history_for_subscriber",level:3},{value:"allow_history_for_client",id:"allow_history_for_client",level:3},{value:"allow_history_for_anonymous",id:"allow_history_for_anonymous",level:3},{value:"allow_presence_for_subscriber",id:"allow_presence_for_subscriber",level:3},{value:"allow_presence_for_client",id:"allow_presence_for_client",level:3},{value:"allow_presence_for_anonymous",id:"allow_presence_for_anonymous",level:3},{value:"allow_user_limited_channels",id:"allow_user_limited_channels",level:3},{value:"channel_regex",id:"channel_regex",level:3},{value:"proxy_subscribe",id:"proxy_subscribe",level:3},{value:"proxy_publish",id:"proxy_publish",level:3},{value:"proxy_sub_refresh",id:"proxy_sub_refresh",level:3},{value:"subscribe_proxy_name",id:"subscribe_proxy_name",level:3},{value:"publish_proxy_name",id:"publish_proxy_name",level:3},{value:"sub_refresh_proxy_name",id:"sub_refresh_proxy_name",level:3},{value:"Channel config examples",id:"channel-config-examples",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Upon connecting to a server clients can subscribe to channels. Channel is one of the core concepts of Centrifugo. Most of the time when integrating Centrifugo you will work with channels and decide what is the best channel configuration for your application."}),"\n",(0,i.jsx)(n.h2,{id:"what-is-channel",children:"What is channel"}),"\n",(0,i.jsx)(n.p,{children:"Centrifugo is a PUB/SUB system - it has publishers and subscribers. Channel is a route for publications. Clients can subscribe to a channel to receive all real-time messages published to a channel. A channel subscriber can also ask for a channel online presence or channel history information."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"pub_sub",src:s(34478).Z+"",width:"2924",height:"1231"})}),"\n",(0,i.jsxs)(n.p,{children:["Channel is just a string - ",(0,i.jsx)(n.code,{children:"news"}),", ",(0,i.jsx)(n.code,{children:"comments"}),", ",(0,i.jsx)(n.code,{children:"personal_feed"})," are valid channel names. Though this string has some ",(0,i.jsx)(n.a,{href:"#channel-name-rules",children:"predefined rules"})," as we will see below. You can define different channel behavior using a set of available ",(0,i.jsx)(n.a,{href:"#channel-options",children:"channel options"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Channels are ephemeral \u2013 you don't need to create them explicitly. Channels created automatically by Centrifugo as soon as the first client subscribes to a channel. As soon as the last subscriber leaves a channel - it's automatically cleaned up."}),"\n",(0,i.jsxs)(n.p,{children:["Channel can belong to a channel namespace. ",(0,i.jsx)(n.a,{href:"#channel-namespaces",children:"Channel namespacing"})," is a mechanism to define different behavior for different channels in Centrifugo. Using namespaces is a recommended way to manage channels \u2013 to turn on only those channel options which are required for a specific real-time feature you are implementing on top of Centrifugo."]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:["When using channel namespaces make sure you defined a namespace in configuration. Subscription attempts to a channel within a non-defined namespace will result into ",(0,i.jsx)(n.a,{href:"/docs/4/server/codes#unknown-channel",children:"102: unknown channel"})," errors."]})}),"\n",(0,i.jsx)(n.h2,{id:"channel-name-rules",children:"Channel name rules"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Only ASCII symbols must be used in a channel string"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Channel name length limited by ",(0,i.jsx)(n.code,{children:"255"})," characters by default (controlled by configuration option ",(0,i.jsx)(n.code,{children:"channel_max_length"}),")."]}),"\n",(0,i.jsx)(n.p,{children:"Several symbols in channel names reserved for Centrifugo internal needs:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:":"})," \u2013 for namespace channel boundary (see below)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"#"})," \u2013 for user channel boundary (see below)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$"})," \u2013 for private channel prefix (see below)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"*"})," \u2013 for the future Centrifugo needs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"&"})," \u2013 for the future Centrifugo needs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/"})," \u2013 for the future Centrifugo needs"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"namespace-boundary-",children:["namespace boundary (",(0,i.jsx)(n.code,{children:":"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:":"})," \u2013 is a channel namespace boundary. Namespaces are used to set custom options to a group of channels. Each channel belonging to the same namespace will have the same channel options. Read more about about ",(0,i.jsx)(n.a,{href:"#channel-namespaces",children:"namespaces"})," and ",(0,i.jsx)(n.a,{href:"#channel-options",children:"channel options"})," below."]}),"\n",(0,i.jsxs)(n.p,{children:["If the channel is ",(0,i.jsx)(n.code,{children:"public:chat"})," - then Centrifugo will apply options to this channel from the channel namespace with the name ",(0,i.jsx)(n.code,{children:"public"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["A namespace is part of the channel name. If a user subscribed to a channel with namespace, like ",(0,i.jsx)(n.code,{children:"public:chat"})," \u2013 then you need to publish messages into ",(0,i.jsx)(n.code,{children:"public:chat"})," channel to be delivered to the user. We often see some confusion from developers trying to publish messages into ",(0,i.jsx)(n.code,{children:"chat"})," and thinking that namespace is somehow stripped upon subscription. It's not true."]})}),"\n",(0,i.jsxs)(n.h3,{id:"user-channel-boundary-",children:["user channel boundary (",(0,i.jsx)(n.code,{children:"#"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"#"})," \u2013 is a user channel boundary. This is a separator to create personal channels for users (we call this ",(0,i.jsx)(n.em,{children:"user-limited channels"}),") without the need to provide a subscription token."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, if the channel is ",(0,i.jsx)(n.code,{children:"news#42"})," then the only user with ID ",(0,i.jsx)(n.code,{children:"42"})," can subscribe to this channel (Centrifugo knows user ID because clients provide it in connection credentials with connection JWT)."]}),"\n",(0,i.jsxs)(n.p,{children:["If you want to create a user-limited channel in namespace ",(0,i.jsx)(n.code,{children:"personal"})," then you can use a name like ",(0,i.jsx)(n.code,{children:"personal:user#42"})," for example."]}),"\n",(0,i.jsxs)(n.p,{children:["Moreover, you can provide several user IDs in channel name separated by a comma: ",(0,i.jsx)(n.code,{children:"dialog#42,43"})," \u2013 in this case only the user with ID ",(0,i.jsx)(n.code,{children:"42"})," and user with ID ",(0,i.jsx)(n.code,{children:"43"})," will be able to subscribe on this channel."]}),"\n",(0,i.jsx)(n.p,{children:"This is useful for channels with a static list of allowed users, for example for single user personal messages channel, for dialog channel between certainly defined users. As soon as you need to manage access to a channel dynamically for many users this channel type does not suit well."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["User-limited channels must be enabled for a channel namespace using ",(0,i.jsx)(n.a,{href:"#allow_user_limited_channels",children:"allow_user_limited_channels"})," option. See below more information about channel options and channel namespaces."]})}),"\n",(0,i.jsxs)(n.h3,{id:"private-channel-prefix-",children:["private channel prefix (",(0,i.jsx)(n.code,{children:"$"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["Centrifugo v4 has this option to achieve compatibility with previous Centrifugo versions. Previously (in Centrifugo v1, v2 and v3) only channels starting with ",(0,i.jsx)(n.code,{children:"$"})," could be subscribed with a subscription JWT. In Centrifugo v4 that's not the case anymore \u2013 clients can subscribe to any channel with a subscription token (if the token is valid \u2013 then subscription to a channel is accepted)."]}),"\n",(0,i.jsxs)(n.p,{children:["But for namespaces with ",(0,i.jsx)(n.code,{children:"allow_subscribe_for_client"})," option enabled Centrifugo does not allow subscribing on channels starting with ",(0,i.jsx)(n.code,{children:"private_channel_prefix"})," (",(0,i.jsx)(n.code,{children:"$"})," by default) without a subscription token. This limitation exists to help users migrate to Centrifugo v4 without security risks."]}),"\n",(0,i.jsx)(n.h3,{id:"channel-is-just-a-string",children:"Channel is just a string"}),"\n",(0,i.jsxs)(n.p,{children:["Keep in mind that a channel is uniquely identified by its string representation. Do not expect that channels ",(0,i.jsx)(n.code,{children:"$news"})," and ",(0,i.jsx)(n.code,{children:"news"})," are the same. They are different because strings are not equal. So if a user subscribed to ",(0,i.jsx)(n.code,{children:"$news"})," then user won't receive messages published to ",(0,i.jsx)(n.code,{children:"news"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Channels ",(0,i.jsx)(n.code,{children:"dialog#42,43"})," and ",(0,i.jsx)(n.code,{children:"dialog#43,42"})," are two different channels too. Centrifugo only applies permission checks when a user subscribes to a channel. So if user-limited channels are enabled then the user with ID ",(0,i.jsx)(n.code,{children:"42"})," will be able to subscribe on both ",(0,i.jsx)(n.code,{children:"dialog#42,43"})," and ",(0,i.jsx)(n.code,{children:"dialog#43,42"}),". But Centrifugo does no magic regarding channel strings when keeping channel->to->subscribers map. So if the user subscribed on ",(0,i.jsx)(n.code,{children:"dialog#42,43"})," you must publish messages to exactly that channel: ",(0,i.jsx)(n.code,{children:"dialog#42,43"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The same applies to channels with namespaces. Do not expect that channels ",(0,i.jsx)(n.code,{children:"chat:index"})," and ",(0,i.jsx)(n.code,{children:"index"})," are the same \u2013 they are different, moreover, belong to different namespaces. We'll look at the concept of channel namespaces in Centrifugo shortly."]}),"\n",(0,i.jsx)(n.h2,{id:"channel-namespaces",children:"Channel namespaces"}),"\n",(0,i.jsx)(n.p,{children:"It's possible to configure a list of channel namespaces. Namespaces are optional but very useful."}),"\n",(0,i.jsx)(n.p,{children:"A namespace allows setting custom options for channels starting with the namespace name. This provides great control over channel behavior so you have a flexible way to define different channel options for different real-time features in the application."}),"\n",(0,i.jsx)(n.p,{children:"Namespace has a name, and the same channel options (with the same defaults) as described above."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"name"})," - unique namespace name (name must consist of letters, numbers, underscores, or hyphens and be more than 2 symbols length i.e. satisfy regexp ",(0,i.jsx)(n.code,{children:"^[-a-zA-Z0-9_]{2,}$"}),")."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["If you want to use namespace options for a channel - you must include namespace name into channel name with ",(0,i.jsx)(n.code,{children:":"})," as a separator:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"public:messages"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"gossips:messages"})}),"\n",(0,i.jsxs)(n.p,{children:["Where ",(0,i.jsx)(n.code,{children:"public"})," and ",(0,i.jsx)(n.code,{children:"gossips"})," are namespace names. Centrifugo looks for ",(0,i.jsx)(n.code,{children:":"})," symbol in the channel name, if found \u2013 extracts the namespace name, and applies namespace options while processing protocol commands from a client."]}),"\n",(0,i.jsxs)(n.p,{children:["All things together here is an example of ",(0,i.jsx)(n.code,{children:"config.json"})," which includes some top-level channel options set and has 2 additional channel namespaces configured:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "token_hmac_secret_key": "very-long-secret-key",\n  "api_key": "secret-api-key",\n  \n  "presence": true,\n  "history_size": 10,\n  "history_ttl": "30s",\n  \n  "namespaces": [\n    {\n      "name": "facts",\n      "history_size": 10,\n      "history_ttl": "300s"\n    },\n    {\n      "name": "gossips"\n    }\n  ]\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Channel ",(0,i.jsx)(n.code,{children:"news"})," will use globally defined channel options."]}),"\n",(0,i.jsxs)(n.li,{children:["Channel ",(0,i.jsx)(n.code,{children:"facts:sport"})," will use ",(0,i.jsx)(n.code,{children:"facts"})," namespace options."]}),"\n",(0,i.jsxs)(n.li,{children:["Channel ",(0,i.jsx)(n.code,{children:"gossips:sport"})," will use ",(0,i.jsx)(n.code,{children:"gossips"})," namespace options."]}),"\n",(0,i.jsxs)(n.li,{children:["Channel ",(0,i.jsx)(n.code,{children:"xxx:hello"})," will result into subscription error since there is no ",(0,i.jsx)(n.code,{children:"xxx"})," namespace defined in the configuration above."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Channel namespaces also work with private channels and user-limited channels"}),". For example, if you have a namespace called ",(0,i.jsx)(n.code,{children:"dialogs"})," then the private channel can be constructed as ",(0,i.jsx)(n.code,{children:"$dialogs:gossips"}),", user-limited channel can be constructed as ",(0,i.jsx)(n.code,{children:"dialogs:dialog#1,2"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["There is ",(0,i.jsx)(n.strong,{children:"no inheritance"})," in channel options and namespaces \u2013 for example, you defined ",(0,i.jsx)(n.code,{children:"presence: true"})," on a top level of configuration and then defined a namespace \u2013 that namespace won't have online presence enabled - you must enable it for a namespace explicitly."]})}),"\n",(0,i.jsx)(n.p,{children:"There are many options which can be set for channel namespace (on top-level and to named one) to modify behavior of channels belonging to a namespace. Below we describe all these options."}),"\n",(0,i.jsx)(n.h2,{id:"channel-options",children:"Channel options"}),"\n",(0,i.jsx)(n.p,{children:"Channel behavior can be modified by using channel options. Channel options can be defined on configuration top-level and for every namespace."}),"\n",(0,i.jsx)(n.h3,{id:"presence",children:"presence"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"presence"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 enable/disable online presence information for channels in a namespace."]}),"\n",(0,i.jsx)(n.p,{children:"Online presence is information about clients currently subscribed to the channel. It contains each subscriber's client ID, user ID, connection info, and channel info. By default, this option is off so no presence information will be available for channels."}),"\n",(0,i.jsxs)(n.p,{children:["Let's say you have a channel ",(0,i.jsx)(n.code,{children:"chat:index"})," and 2 users (with ID ",(0,i.jsx)(n.code,{children:"2694"})," and ",(0,i.jsx)(n.code,{children:"56"}),") subscribed to it. And user ",(0,i.jsx)(n.code,{children:"2694"})," has 2 connections to Centrifugo in different browser tabs. In presence data you may see sth like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'curl --header "Content-Type: application/json" \\\n  --header "Authorization: apikey <API_KEY>" \\\n  --request POST \\\n  --data \'{"method": "presence", "params": {"channel": "chat:index"}}\' \\\n  http://localhost:8000/api\n{\n    "result": {\n        "presence": {\n            "66fdf8d1-06f0-4375-9fac-db959d6ee8d6": {\n                "user": "2694",\n                "client": "66fdf8d1-06f0-4375-9fac-db959d6ee8d6",\n                "conn_info": {"name": "Alex"}\n            },\n            "d4516dd3-0b6e-4cfe-84e8-0342fd2bb20c": {\n                "user": "2694",\n                "client": "d4516dd3-0b6e-4cfe-84e8-0342fd2bb20c",\n                "conn_info": {"name": "Alex"}\n            }\n            "g3216dd3-1b6e-tcfe-14e8-1342fd2bb20c": {\n                "user": "56",\n                "client": "g3216dd3-1b6e-tcfe-14e8-1342fd2bb20c",\n                "conn_info": {"name": "Alice"}\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To call presence API from the client connection side client must have permission to do so. See ",(0,i.jsx)(n.a,{href:"/docs/4/server/channel_permissions#presence-permission-model",children:"presence permission model"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"Enabling channel online presence adds some overhead since Centrifugo needs to maintain an additional data structure (in a process memory or in a broker memory/disk). So only use it for channels where presence is required."})}),"\n",(0,i.jsxs)(n.p,{children:["See more details about ",(0,i.jsx)(n.a,{href:"/docs/4/getting-started/design#online-presence-considerations",children:"online presence design"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"join_leave",children:"join_leave"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"join_leave"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 enable/disable sending join and leave messages when the client subscribes to a channel (unsubscribes from a channel). Join/leave event includes information about the connection that triggered an event \u2013 client ID, user ID, connection info, and channel info (similar to entry inside presence information)."]}),"\n",(0,i.jsxs)(n.p,{children:["Enabling ",(0,i.jsx)(n.code,{children:"join_leave"})," means that Join/Leave messages will start being emitted, but by default they are not delivered to clients subscribed to a channel. You need to force this using namespace option ",(0,i.jsx)(n.a,{href:"#forcepushjoinleave",children:"force_push_join_leave"})," or explicitly provide intent from a client-side (in this case client must have permission to call presence API)."]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:'Keep in mind that join/leave messages can generate a huge number of messages in a system if turned on for channels with a large number of active subscribers. If you have channels with a large number of subscribers consider avoiding using this feature. It\'s hard to say what is "large" for you though \u2013 just estimate the load based on the fact that each subscribe/unsubscribe event in a channel with N subscribers will result into N messages broadcasted to all. If all clients reconnect at the same time the amount of generated messages is N^2.'})}),"\n",(0,i.jsx)(n.p,{children:"Join/leave messages distributed only with at most once delivery guarantee."}),"\n",(0,i.jsx)(n.h3,{id:"force_push_join_leave",children:"force_push_join_leave"}),"\n",(0,i.jsxs)(n.p,{children:["Boolean, default ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"When on all clients will receive join/leave events for a channel in a namespace automatically \u2013 without explicit intent to consume join/leave messages from the client side."}),"\n",(0,i.jsx)(n.p,{children:"If pushing join/leave is not forced then client can provide a corresponding Subscription option to enable it \u2013 but it should have permissions to access channel presence (by having an explicit capability or if allowed on a namespace level)."}),"\n",(0,i.jsx)(n.h3,{id:"history_size",children:"history_size"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"history_size"})," (integer, default ",(0,i.jsx)(n.code,{children:"0"}),") \u2013 history size (amount of messages) for channels. As Centrifugo keeps all history messages in process memory (or in a broker memory) it's very important to limit the maximum amount of messages in channel history with a reasonable value. ",(0,i.jsx)(n.code,{children:"history_size"})," defines the maximum amount of messages that Centrifugo will keep for ",(0,i.jsx)(n.strong,{children:"each"})," channel in the namespace. As soon as history has more messages than defined by history size \u2013 old messages will be evicted."]}),"\n",(0,i.jsxs)(n.p,{children:["Setting only ",(0,i.jsx)(n.code,{children:"history_size"})," ",(0,i.jsx)(n.strong,{children:"is not enough to enable history in channels"})," \u2013 you also need to wisely configure ",(0,i.jsx)(n.code,{children:"history_ttl"})," option (see below)."]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"Enabling channel history adds some overhead (both memory and CPU) since Centrifugo needs to maintain an additional data structure (in a process memory or a broker memory/disk). So only use history for channels where it's required."})}),"\n",(0,i.jsx)(n.h3,{id:"history_ttl",children:"history_ttl"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"history_ttl"})," (",(0,i.jsx)(n.a,{href:"/docs/4/server/configuration#setting-time-duration-options",children:"duration"}),", default ",(0,i.jsx)(n.code,{children:"0s"}),") \u2013 interval how long to keep channel history messages (with seconds precision)."]}),"\n",(0,i.jsx)(n.p,{children:"As all history is storing in process memory (or in a broker memory) it is also very important to get rid of old history data for unused (inactive for a long time) channels."}),"\n",(0,i.jsx)(n.p,{children:"By default history TTL duration is zero \u2013 this means that channel history is disabled."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Again \u2013 to turn on history you should wisely configure both ",(0,i.jsx)(n.code,{children:"history_size"})," and ",(0,i.jsx)(n.code,{children:"history_ttl"})," options"]}),"."]}),"\n",(0,i.jsx)(n.p,{children:"For example for top-level channels (which do not belong to a namespace):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n    ...\n    "history_size": 10,\n    "history_ttl": "60s"\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Let's look at example. You enabled history for a namespace ",(0,i.jsx)(n.code,{children:"chat"})," and sent two messages in channel ",(0,i.jsx)(n.code,{children:"chat:index"}),". Then history will contain sth like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'curl --header "Content-Type: application/json" \\\n  --header "Authorization: apikey <API_KEY>" \\\n  --request POST \\\n  --data \'{"method": "history", "params": {"channel": "chat:index", "limit": 100}}\' \\\n  http://localhost:8000/api\n{\n    "result": {\n        "publications": [\n            {\n                "data": {\n                    "input": "1"\n                },\n                "offset": 1\n            },\n            {\n                "data": {\n                    "input": "2"\n                },\n                "offset": 2\n            }\n        ],\n        "epoch": "gWuY",\n        "offset": 2\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To call history API from the client connection side client must have permission to do so. See ",(0,i.jsx)(n.a,{href:"/docs/4/server/channel_permissions#history-permission-model",children:"history permission model"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["See additional information about offsets and epoch in ",(0,i.jsx)(n.a,{href:"/docs/4/server/history_and_recovery",children:"History and recovery"})," chapter."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["History persistence properties are dictated by Centrifugo ",(0,i.jsx)(n.a,{href:"/docs/4/server/engines",children:"engine"})," used. For example, when using memory engine history is only kept till Centrifugo node restart. In Redis engine case persistence is determined by a Redis server persistence configuration (same for KeyDB and Tarantool)."]})}),"\n",(0,i.jsx)(n.h3,{id:"force_positioning",children:"force_positioning"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"force_positioning"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 when the ",(0,i.jsx)(n.code,{children:"force_positioning"})," option is on Centrifugo forces all subscriptions in a namespace to be ",(0,i.jsx)(n.code,{children:"positioned"}),". I.e. Centrifugo will try to compensate at most once delivery of PUB/SUB broker checking client position inside a stream."]}),"\n",(0,i.jsxs)(n.p,{children:["If Centrifugo detects a bad position of the client (i.e. potential message loss) it disconnects a client with the ",(0,i.jsx)(n.code,{children:"Insufficient state"})," disconnect code. Also, when the position option is enabled Centrifugo exposes the current stream top ",(0,i.jsx)(n.code,{children:"offset"})," and current ",(0,i.jsx)(n.code,{children:"epoch"})," in subscribe reply making it possible for a client to manually recover its state upon disconnect using history API."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"force_positioning"})," option must be used in conjunction with reasonably configured message history for a channel i.e. ",(0,i.jsx)(n.code,{children:"history_size"})," and ",(0,i.jsx)(n.code,{children:"history_ttl"})," ",(0,i.jsx)(n.strong,{children:"must be set"})," (because Centrifugo uses channel history to check client position in a stream)."]}),"\n",(0,i.jsx)(n.p,{children:"If positioning is not forced then client can provide a corresponding Subscription option to enable it \u2013 but it should have permissions to access channel history (by having an explicit capability or if allowed on a namespace level)."}),"\n",(0,i.jsx)(n.h3,{id:"force_recovery",children:"force_recovery"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"force_recovery"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 when the ",(0,i.jsx)(n.code,{children:"position"})," option is on Centrifugo forces all subscriptions in a namespace to be ",(0,i.jsx)(n.code,{children:"recoverable"}),". When enabled Centrifugo will try to recover missed publications in channels after a client reconnects for some reason (bad internet connection for example). Also when the recovery feature is on Centrifugo automatically enables properties of the ",(0,i.jsx)(n.code,{children:"force_positioning"})," option described above."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"force_recovery"})," option must be used in conjunction with reasonably configured message history for channel i.e. ",(0,i.jsx)(n.code,{children:"history_size"})," and ",(0,i.jsx)(n.code,{children:"history_ttl"})," ",(0,i.jsx)(n.strong,{children:"must be set"})," (because Centrifugo uses channel history to recover messages)."]}),"\n",(0,i.jsx)(n.p,{children:"If recovery is not forced then client can provide a corresponding Subscription option to enable it \u2013 but it should have permissions to access channel history (by having an explicit capability or if allowed on a namespace level)."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Not all real-time events require this feature turned on so think wisely when you need this. When this option is turned on your application should be designed in a way to tolerate duplicate messages coming from a channel (currently Centrifugo returns recovered publications in order and without duplicates but this is an implementation detail that can be theoretically changed in the future). See more details about how recovery works in ",(0,i.jsx)(n.a,{href:"/docs/4/server/history_and_recovery",children:"special chapter"}),"."]})}),"\n",(0,i.jsx)(n.h3,{id:"allow_subscribe_for_client",children:"allow_subscribe_for_client"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"allow_subscribe_for_client"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 when on all non-anonymous clients will be able to subscribe to any channel in a namespace. To additionally allow anonymous users to subscribe turn on ",(0,i.jsx)(n.code,{children:"allow_subscribe_for_anonymous"})," (see below)."]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"Turning this option on effectively makes namespace public \u2013 no subscribe permissions will be checked (only the check that current connection is authenticated - i.e. has non-empty user ID). Make sure this is really what you want in terms of channels security."})}),"\n",(0,i.jsx)(n.h3,{id:"allow_subscribe_for_anonymous",children:"allow_subscribe_for_anonymous"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"allow_subscribe_for_anonymous"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 turn on if anonymous clients (with empty user ID) should be able to subscribe on channels in a namespace."]}),"\n",(0,i.jsx)(n.h3,{id:"allow_publish_for_subscriber",children:"allow_publish_for_subscriber"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"allow_publish_for_subscriber"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") - when the ",(0,i.jsx)(n.code,{children:"allow_publish_for_subscriber"})," option is enabled client can publish into a channel in namespace directly from the client side over real-time connection but only if client subscribed to that channel."]}),"\n",(0,i.jsx)(n.admonition,{type:"danger",children:(0,i.jsxs)(n.p,{children:["Keep in mind that in this case subscriber can publish any payload to a channel \u2013 Centrifugo does not validate input at all. Your app backend won't receive those messages - publications just go through Centrifugo towards channel subscribers. Consider always validate messages which are being published to channels (i.e. using server API to publish after validating input on the backend side, or using ",(0,i.jsx)(n.a,{href:"/docs/4/server/proxy#publish-proxy",children:"publish proxy"})," - see ",(0,i.jsx)(n.a,{href:"/docs/4/getting-started/design#idiomatic-usage",children:"idiomatic usage"}),")."]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"allow_publish_for_subscriber"})," (or ",(0,i.jsx)(n.code,{children:"allow_publish_for_client"})," mentioned below) option still can be useful to send something without backend-side validation and saving it into a database \u2013 for example, this option may be handy for demos and quick prototyping real-time app ideas."]}),"\n",(0,i.jsx)(n.h3,{id:"allow_publish_for_client",children:"allow_publish_for_client"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"allow_publish_for_client"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 when on allows clients to publish messages into channels directly (from a client-side). It's like ",(0,i.jsx)(n.code,{children:"allow_publish_for_subscriber"})," \u2013 but client should not be a channel subscriber to publish."]}),"\n",(0,i.jsx)(n.admonition,{type:"danger",children:(0,i.jsxs)(n.p,{children:["Keep in mind that in this case client can publish any payload to a channel \u2013 Centrifugo does not validate input at all. Your app backend won't receive those messages - publications just go through Centrifugo towards channel subscribers. Consider always validate messages which are being published to channels (i.e. using server API to publish after validating input on the backend side, or using ",(0,i.jsx)(n.a,{href:"/docs/4/server/proxy#publish-proxy",children:"publish proxy"})," - see ",(0,i.jsx)(n.a,{href:"/docs/4/getting-started/design#idiomatic-usage",children:"idiomatic usage"}),")."]})}),"\n",(0,i.jsx)(n.h3,{id:"allow_publish_for_anonymous",children:"allow_publish_for_anonymous"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"allow_publish_for_anonymous"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 turn on if anonymous clients should be able to publish into channels in a namespace."]}),"\n",(0,i.jsx)(n.h3,{id:"allow_history_for_subscriber",children:"allow_history_for_subscriber"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"allow_history_for_subscriber"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 allows clients who subscribed on a channel to call history API from that channel."]}),"\n",(0,i.jsx)(n.h3,{id:"allow_history_for_client",children:"allow_history_for_client"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"allow_history_for_client"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 allows all clients to call history information in a namespace."]}),"\n",(0,i.jsx)(n.h3,{id:"allow_history_for_anonymous",children:"allow_history_for_anonymous"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"allow_history_for_anonymous"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 turn on if anonymous clients should be able to call history from channels in a namespace."]}),"\n",(0,i.jsx)(n.h3,{id:"allow_presence_for_subscriber",children:"allow_presence_for_subscriber"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"allow_presence_for_subscriber"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 allows clients who subscribed on a channel to call presence information from that channel."]}),"\n",(0,i.jsx)(n.h3,{id:"allow_presence_for_client",children:"allow_presence_for_client"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"allow_presence_for_client"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 allows all clients to call presence information in a namespace."]}),"\n",(0,i.jsx)(n.h3,{id:"allow_presence_for_anonymous",children:"allow_presence_for_anonymous"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"allow_presence_for_anonymous"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 turn on if anonymous clients should be able to call presence from channels in a namespace."]}),"\n",(0,i.jsx)(n.h3,{id:"allow_user_limited_channels",children:"allow_user_limited_channels"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"allow_user_limited_channels"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") - allows using user-limited channels in a namespace for checking subscribe permission."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["If client subscribes to a user-limited channel while this option is off then server rejects subscription with ",(0,i.jsx)(n.code,{children:"103: permission denied"})," error."]})}),"\n",(0,i.jsx)(n.h3,{id:"channel_regex",children:"channel_regex"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"channel_regex"})," (string, default ",(0,i.jsx)(n.code,{children:'""'}),") \u2013 is an option to set a regular expression for channels allowed in the namespace. By default Centrifugo does not limit channel name variations. For example, if you have a namespace ",(0,i.jsx)(n.code,{children:"chat"}),", then channel names inside this namespace are not really limited, it can be ",(0,i.jsx)(n.code,{children:"chat:index"}),", ",(0,i.jsx)(n.code,{children:"chat:1"}),", ",(0,i.jsx)(n.code,{children:"chat:2"}),", ",(0,i.jsx)(n.code,{children:"chat:zzz"})," and so on. But if you want to be strict and know possible channel patterns you can use ",(0,i.jsx)(n.code,{children:"channel_regex"})," option. This is especially useful in namespaces where all clients can subscribe to channels."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, let's only allow digits after ",(0,i.jsx)(n.code,{children:"chat:"})," for channel names in a ",(0,i.jsx)(n.code,{children:"chat"})," namespace:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "namespaces": [\n    {\n      "name": "chat",\n      "allow_subscribe_for_client": true,\n      "channel_regex": "^[\\d+]$"\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"danger",children:(0,i.jsxs)(n.p,{children:["Note, that we are skipping ",(0,i.jsx)(n.code,{children:"chat:"})," part in regex. Since namespace prefix is the same for all channels in a namespace we only match the rest (after the prefix) of channel name."]})}),"\n",(0,i.jsx)(n.p,{children:"Channel regex only checked for client-side subscriptions, if you are using server-side subscriptions Centrifugo won't check the regex."}),"\n",(0,i.jsxs)(n.p,{children:["Centrifugo uses Go language ",(0,i.jsx)(n.a,{href:"https://pkg.go.dev/regexp",children:"regexp"})," package for regular expressions."]}),"\n",(0,i.jsx)(n.h3,{id:"proxy_subscribe",children:"proxy_subscribe"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"proxy_subscribe"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 turns on subscribe proxy, more info in ",(0,i.jsx)(n.a,{href:"/docs/4/server/proxy",children:"proxy chapter"})]}),"\n",(0,i.jsx)(n.h3,{id:"proxy_publish",children:"proxy_publish"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"proxy_publish"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 turns on publish proxy, more info in ",(0,i.jsx)(n.a,{href:"/docs/4/server/proxy",children:"proxy chapter"})]}),"\n",(0,i.jsx)(n.h3,{id:"proxy_sub_refresh",children:"proxy_sub_refresh"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"proxy_sub_refresh"})," (boolean, default ",(0,i.jsx)(n.code,{children:"false"}),") \u2013 turns on sub refresh proxy, more info in ",(0,i.jsx)(n.a,{href:"/docs/4/server/proxy",children:"proxy chapter"})]}),"\n",(0,i.jsx)(n.h3,{id:"subscribe_proxy_name",children:"subscribe_proxy_name"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"subscribe_proxy_name"})," (string, default ",(0,i.jsx)(n.code,{children:'""'}),") \u2013 turns on subscribe proxy when ",(0,i.jsx)(n.a,{href:"/docs/4/server/proxy#granular-proxy-mode",children:"granular proxy mode"})," is used. Note that ",(0,i.jsx)(n.code,{children:"proxy_subscribe"})," option defined above is ignored in granular proxy mode."]}),"\n",(0,i.jsx)(n.h3,{id:"publish_proxy_name",children:"publish_proxy_name"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"publish_proxy_name"})," (string, default ",(0,i.jsx)(n.code,{children:'""'}),") \u2013 turns on publish proxy when ",(0,i.jsx)(n.a,{href:"/docs/4/server/proxy#granular-proxy-mode",children:"granular proxy mode"})," is used. Note that ",(0,i.jsx)(n.code,{children:"proxy_publish"})," option defined above is ignored in granular proxy mode."]}),"\n",(0,i.jsx)(n.h3,{id:"sub_refresh_proxy_name",children:"sub_refresh_proxy_name"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"sub_refresh_proxy_name"})," (string, default ",(0,i.jsx)(n.code,{children:'""'}),") \u2013 turns on sub refresh proxy when ",(0,i.jsx)(n.a,{href:"/docs/4/server/proxy#granular-proxy-mode",children:"granular proxy mode"})," is used. Note that ",(0,i.jsx)(n.code,{children:"proxy_sub_refresh"})," option defined above is ignored in granular proxy mode."]}),"\n",(0,i.jsx)(n.h2,{id:"channel-config-examples",children:"Channel config examples"}),"\n",(0,i.jsx)(n.p,{children:"Let's look at how to set some of these options in a config. In this example we turning on presence, history features, forcing publication recovery. Also allowing all client connections (including anonymous users) to subscribe to channels and call publish, history, presence APIs if subscribed."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n    "token_hmac_secret_key": "my-secret-key",\n    "api_key": "secret-api-key",\n    "presence": true,\n    "history_size": 10,\n    "history_ttl": "300s",\n    "force_recovery": true,\n    "allow_subscribe_for_client": true,\n    "allow_subscribe_for_anonymous": true,\n    "allow_publish_for_subscriber": true,\n    "allow_publish_for_anonymous": true,\n    "allow_history_for_subscriber": true,\n    "allow_history_for_anonymous": true,\n    "allow_presence_for_subscriber": true,\n    "allow_presence_for_anonymous": true\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here we set channel options on config top-level \u2013 these options will affect channels without namespace. In many cases defining namespaces is a recommended approach so you can manage options for every real-time feature separately. With namespaces the above config may transform to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n    "token_hmac_secret_key": "my-secret-key",\n    "api_key": "secret-api-key",\n    "namespaces": [\n        {\n            "name": "feed",\n            "presence": true,\n            "history_size": 10,\n            "history_ttl": "300s",\n            "force_recovery": true,\n            "allow_subscribe_for_client": true,\n            "allow_subscribe_for_anonymous": true,\n            "allow_publish_for_subscriber": true,\n            "allow_publish_for_anonymous": true,\n            "allow_history_for_subscriber": true,\n            "allow_history_for_anonymous": true,\n            "allow_presence_for_subscriber": true,\n            "allow_presence_for_anonymous": true\n        }\n    ]\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In this case channels should be prefixed with ",(0,i.jsx)(n.code,{children:"feed:"})," to follow the behavior configured for a ",(0,i.jsx)(n.code,{children:"feed"})," namespace."]})]})}function d(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},34478:(e,n,s)=>{s.d(n,{Z:()=>i});const i=s.p+"assets/images/pub_sub-5477abf6fb38219fc0848d9c9c3dc2b1.png"},11151:(e,n,s)=>{s.d(n,{Z:()=>l,a:()=>r});var i=s(67294);const o={},a=i.createContext(o);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);