"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[7531],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>c});var o=i(96540);const t={},s=o.createContext(t);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(s.Provider,{value:n},e.children)}},45619:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"transports/uni_client_protocol","title":"Unidirectional client protocol","description":"As we mentioned in overview you can avoid using Centrifugo SDKs if you stick with unidirectional approach. In this case though you will need to implement some basic parsing on client side to consume message types sent by Centrifugo into unidirectional connections.","source":"@site/versioned_docs/version-5/transports/uni_client_protocol.md","sourceDirName":"transports","slug":"/transports/uni_client_protocol","permalink":"/docs/5/transports/uni_client_protocol","draft":false,"unlisted":false,"editUrl":"https://github.com/centrifugal/centrifugal.dev/edit/main/versioned_docs/version-5/transports/uni_client_protocol.md","tags":[],"version":"5","frontMatter":{"id":"uni_client_protocol","title":"Unidirectional client protocol","sidebar_label":"Unidirectional protocol"},"sidebar":"Transports","previous":{"title":"Client protocol","permalink":"/docs/5/transports/client_protocol"},"next":{"title":"WebSocket","permalink":"/docs/5/transports/uni_websocket"}}');var t=i(74848),s=i(28453);const r={id:"uni_client_protocol",title:"Unidirectional client protocol",sidebar_label:"Unidirectional protocol"},c=void 0,l={},a=[{value:"Unidirectional message types",id:"unidirectional-message-types",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["As we mentioned in overview you can avoid using Centrifugo SDKs if you stick with ",(0,t.jsx)(n.a,{href:"/docs/5/transports/overview#unidirectional",children:"unidirectional approach"}),". In this case though you will need to implement some basic parsing on client side to consume message types sent by Centrifugo into unidirectional connections."]}),"\n",(0,t.jsx)(n.p,{children:"At this point Centrifugo supports unidirectional WebSocket, HTTP streaming, SSE (EventSource), GRPC transports \u2013 and all of them inherit the same protocol structure described here."}),"\n",(0,t.jsx)(n.h3,{id:"unidirectional-message-types",children:"Unidirectional message types"}),"\n",(0,t.jsxs)(n.p,{children:["In case of unidirectional transports Centrifugo will send ",(0,t.jsx)(n.code,{children:"Push"})," frames to the connection. Push frames defined by ",(0,t.jsx)(n.a,{href:"https://github.com/centrifugal/protocol/blob/master/definitions/client.proto",children:"client protocol schema"}),". I.e. Centrifugo reuses a part of its bidirectional protocol for unidirectional communication. Push message defined as:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"message Push {\n  string channel = 2;\n\n  Publication pub = 4;\n  Join join = 5;\n  Leave leave = 6;\n  Unsubscribe unsubscribe = 7;\n  Message message = 8;\n  Subscribe subscribe = 9;\n  Connect connect = 10;\n  Disconnect disconnect = 11;\n  Refresh refresh = 12;\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"Some numbers in Protobuf definitions skipped for backwards compatibility with previous client protocol version."})}),"\n",(0,t.jsxs)(n.p,{children:["So unidirectional connection will receive various pushes. Every push contains ",(0,t.jsx)(n.strong,{children:"one of"})," the following objects:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Publication"}),"\n",(0,t.jsx)(n.li,{children:"Join"}),"\n",(0,t.jsx)(n.li,{children:"Leave"}),"\n",(0,t.jsx)(n.li,{children:"Unsubscribe"}),"\n",(0,t.jsx)(n.li,{children:"Message"}),"\n",(0,t.jsx)(n.li,{children:"Subscribe"}),"\n",(0,t.jsx)(n.li,{children:"Connect"}),"\n",(0,t.jsx)(n.li,{children:"Disconnect"}),"\n",(0,t.jsx)(n.li,{children:"Refresh"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Some pushes belong to a ",(0,t.jsx)(n.code,{children:"channel"})," which may be set on Push top level."]}),"\n",(0,t.jsxs)(n.p,{children:["All you need to do is look at Push, process messages you are interested in and ignore others. In most cases you will be most interested in pushes which contain ",(0,t.jsx)(n.code,{children:"Connect"})," or ",(0,t.jsx)(n.code,{children:"Publication"})," messages."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, according to ",(0,t.jsx)(n.a,{href:"https://github.com/centrifugal/protocol/blob/master/definitions/client.proto",children:"protocol schema"})," Publication message type looks like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"message Publication {\n  bytes data = 4;\n  ClientInfo info = 5;\n  uint64 offset = 6;\n  map<string, string> tags = 7;\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["In JSON protocol case Centrifugo replaces ",(0,t.jsx)(n.code,{children:"bytes"})," type with embedded JSON."]})}),"\n",(0,t.jsx)(n.p,{children:"Just try using any unidirectional transport and you will quickly get the idea."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);