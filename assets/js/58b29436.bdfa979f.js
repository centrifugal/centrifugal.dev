"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[9620],{433:(e,n,t)=>{t.d(n,{Z:()=>s});var i=t(7294),a=t(6010);const o="tabItem_Ymn6";function s(e){let{children:n,hidden:t,className:s}=e;return i.createElement("div",{role:"tabpanel",className:(0,a.Z)(o,s),hidden:t},n)}},2808:(e,n,t)=>{t.d(n,{Z:()=>y});var i=t(7462),a=t(7294),o=t(6010),s=t(6775),r=t(4423),l=t(636),c=t(9200);function u(e){return function(e){var n;return(null==(n=a.Children.map(e,(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:n.filter(Boolean))??[]}(e).map((e=>{let{props:{value:n,label:t,attributes:i,default:a}}=e;return{value:n,label:t,attributes:i,default:a}}))}function p(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??u(t);return function(e){const n=(0,l.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function d(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function b(e){let{queryString:n=!1,groupId:t}=e;const i=(0,s.k6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,r._X)(o),(0,a.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(i.location.search);n.set(o,e),i.replace({...i.location,search:n.toString()})}),[o,i])]}function m(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,o=p(e),[s,r]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!d({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const i=t.find((e=>e.default))??t[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:o}))),[l,u]=b({queryString:t,groupId:i}),[m,k]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[i,o]=(0,c.Nk)(t);return[i,(0,a.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:i}),h=(()=>{const e=l??m;return d({value:e,tabValues:o})?e:null})();(0,a.useLayoutEffect)((()=>{h&&r(h)}),[h]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!d({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);r(e),u(e),k(e)}),[u,k,o]),tabValues:o}}var k=t(3735),h=t(5730);const f="tabList__CuJ",g="tabItem_LNqP";function v(e){let{className:n,block:t,selectedValue:s,selectValue:r,tabValues:l}=e;const c=[],{blockElementScrollPositionUntilNextRender:u}=(0,k.o5)(),p=e=>{const n=e.currentTarget,t=c.indexOf(n),i=l[t].value;i!==s&&(u(n),r(i))},d=e=>{var n;let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}null==(n=t)||n.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},n)},l.map((e=>{let{value:n,label:t,attributes:r}=e;return a.createElement("li",(0,i.Z)({role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,key:n,ref:e=>c.push(e),onKeyDown:d,onClick:p},r,{className:(0,o.Z)("tabs__item",g,null==r?void 0:r.className,{"tabs__item--active":s===n})}),t??n)})))}function C(e){let{lazy:n,children:t,selectedValue:i}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===i));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},o.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==i}))))}function N(e){const n=m(e);return a.createElement("div",{className:(0,o.Z)("tabs-container",f)},a.createElement(v,(0,i.Z)({},e,n)),a.createElement(C,(0,i.Z)({},e,n)))}function y(e){const n=(0,h.Z)();return a.createElement(N,(0,i.Z)({key:String(n)},e))}},1154:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>b,frontMatter:()=>r,metadata:()=>c,toc:()=>p});var i=t(7462),a=(t(7294),t(3905)),o=t(2808),s=t(433);const r={id:"client_api",title:"Client SDK API"},l=void 0,c={unversionedId:"transports/client_api",id:"transports/client_api",title:"Client SDK API",description:"Centrifugo has several client SDKs to establish a real-time connection with a server. Centrifugo SDKs use WebSocket as the main data transport and send/receive messages encoded according to our bidirectional protocol. That protocol is built on top of the Protobuf schema (both JSON and binary Protobuf formats are supported). It provides asynchronous communication, sending RPC, multiplexing subscriptions to channels, etc. Client SDK wraps the protocol and exposes a set of APIs to developers.",source:"@site/docs/transports/client_api.md",sourceDirName:"transports",slug:"/transports/client_api",permalink:"/docs/transports/client_api",draft:!1,editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/docs/transports/client_api.md",tags:[],version:"current",frontMatter:{id:"client_api",title:"Client SDK API"},sidebar:"Transports",previous:{title:"Real-time transports",permalink:"/docs/transports/overview"},next:{title:"Client real-time SDKs",permalink:"/docs/transports/client_sdk"}},u={},p=[{value:"Client connection states",id:"client-connection-states",level:2},{value:"Client common options",id:"client-common-options",level:2},{value:"Client methods",id:"client-methods",level:2},{value:"Client connection token",id:"client-connection-token",level:2},{value:"Connection PING/PONG",id:"connection-pingpong",level:2},{value:"Subscription states",id:"subscription-states",level:2},{value:"Subscription management",id:"subscription-management",level:2},{value:"Listen to channel publications",id:"listen-to-channel-publications",level:2},{value:"Subscription recovery state",id:"subscription-recovery-state",level:2},{value:"Subscription common options",id:"subscription-common-options",level:2},{value:"Subscription methods",id:"subscription-methods",level:2},{value:"Subscription token",id:"subscription-token",level:2},{value:"Server-side subscriptions",id:"server-side-subscriptions",level:2},{value:"Error codes",id:"error-codes",level:2},{value:"Unsubscribe codes",id:"unsubscribe-codes",level:2},{value:"Disconnect codes",id:"disconnect-codes",level:2},{value:"RPC",id:"rpc",level:2},{value:"Channel history API",id:"channel-history-api",level:2},{value:"Presence and presence stats API",id:"presence-and-presence-stats-api",level:2},{value:"SDK common best practices",id:"sdk-common-best-practices",level:2}],d={toc:p};function b(e){let{components:n,...r}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Centrifugo has several client SDKs to establish a real-time connection with a server. Centrifugo SDKs use WebSocket as the main data transport and send/receive messages encoded according to our bidirectional protocol. That protocol is built on top of the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/protocol/blob/master/definitions/client.proto"},"Protobuf schema")," (both JSON and binary Protobuf formats are supported). It provides asynchronous communication, sending RPC, multiplexing subscriptions to channels, etc. Client SDK wraps the protocol and exposes a set of APIs to developers."),(0,a.kt)("p",null,"This chapter describes the core concepts of client SDKs API. All our ",(0,a.kt)("a",{parentName:"p",href:"/docs/transports/client_sdk#list-of-client-sdks"},"official real-time SDKs")," follow this specification. This document describes behaviour visible to SDK user, if you want to find out low-level client protocol framing details \u2013 look at ",(0,a.kt)("a",{parentName:"p",href:"/docs/transports/client_protocol"},"client protocol")," document."),(0,a.kt)("p",null,"Most examples here are written using our Javascript real-time SDK (",(0,a.kt)("inlineCode",{parentName:"p"},"centrifuge-js"),"), but all other Centrifugo connectors have very similar semantics and APIs very close to each other."),(0,a.kt)("h2",{id:"client-connection-states"},"Client connection states"),(0,a.kt)("p",null,"Client connection has 4 states:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"disconnected")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"connecting")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"connected")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"closed"))),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("inlineCode",{parentName:"p"},"closed")," state is only implemented by SDKs where it makes sense (need to clean up allocated resources when app gracefully shuts down \u2013 for example in Java SDK we close thread executors used internally).")),(0,a.kt)("p",null,"When a new Client is created it has a ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnected")," state. To connect to a server ",(0,a.kt)("inlineCode",{parentName:"p"},"connect()")," method must be called. After calling connect Client moves to the ",(0,a.kt)("inlineCode",{parentName:"p"},"connecting")," state. If a Client can't connect to a server it attempts to create a connection with an exponential backoff algorithm (with ",(0,a.kt)("a",{parentName:"p",href:"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/"},"full jitter"),"). If a connection to a server is successful then the state becomes ",(0,a.kt)("inlineCode",{parentName:"p"},"connected"),"."),(0,a.kt)("p",null,"If a connection is lost (due to a missing network for example, or due to reconnect advice received from a server, or due to some client-side error that can't be recovered without reconnecting) Client goes to the ",(0,a.kt)("inlineCode",{parentName:"p"},"connecting")," state again. In this state Client tries to reconnect (again, with an exponential backoff algorithm)."),(0,a.kt)("p",null,"The Client's state can become ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnected"),". This happens when Client's ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnect()")," method was called by a developer. Also, this can happen due to server advice from a server, or due to a terminal problem that happened on the client-side."),(0,a.kt)("p",null,"Here is a program where we create a Client instance, set callbacks to listen to state updates and establish a connection with a server:"),(0,a.kt)(o.Z,{className:"unique-tabs",defaultValue:"javascript",values:[{label:"Javascript",value:"javascript"},{label:"Dart",value:"dart"},{label:"Swift",value:"swift"},{label:"Java",value:"java"},{label:"Go",value:"go"}],mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"javascript",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const client = new Centrifuge('ws://localhost:8000/connection/websocket', {});\n\nclient.on('connecting', function(ctx) {\n    console.log('connecting', ctx);\n});\n\nclient.on('connected', function(ctx) {\n    console.log('connected', ctx);\n});\n\nclient.on('disconnected', function(ctx) {\n    console.log('disconnected', ctx);\n});\n\nclient.connect();\n"))),(0,a.kt)(s.Z,{value:"dart",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-dart"},"final onEvent = (dynamic event) {\n    print('client event> $event');\n};\n\nfinal client = centrifuge.createClient(\n    'ws://localhost:8000/connection/websocket',\n    centrifuge.ClientConfig(),\n);\n\nclient.connecting.listen(onEvent);\nclient.connected.listen(onEvent);\nclient.disconnected.listen(onEvent);\n\nawait client.connect();\n"))),(0,a.kt)(s.Z,{value:"swift",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},'import SwiftCentrifuge\n\nclass ClientDelegate : NSObject, CentrifugeClientDelegate {\n    func onConnecting(_ c: CentrifugeClient, _ e: CentrifugeConnectingEvent) {\n        print("connecting", e.code, e.reason)\n    }\n    func onConnected(_ client: CentrifugeClient, _ e: CentrifugeConnectedEvent) {\n        print("connected with id", e.client)\n    }\n    func onDisconnected(_ client: CentrifugeClient, _ e: CentrifugeDisconnectedEvent) {\n        print("disconnected", e.code, e.reason)\n    }\n}\n\nlet config = CentrifugeClientConfig()\nlet endpoint = "ws://localhost:8000/connection/websocket"\nlet client = CentrifugeClient(endpoint: endpoint, config: config, delegate: ClientDelegate())\nclient.connect()\n'))),(0,a.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'EventListener listener = new EventListener() {\n    @Override\n    public void onConnected(Client client, ConnectedEvent event) {\n        System.out.println("connected");\n    }\n    @Override\n    public void onConnecting(Client client, ConnectingEvent event) {\n        System.out.printf("connecting: %s%n", event.getReason());\n    }\n    @Override\n    public void onDisconnected(Client client, DisconnectedEvent event) {\n        System.out.printf("disconnected %d %s", event.getCode(), event.getReason());\n    }\n};\n\nOptions opts = new Options();\n\nClient client = new Client("ws://localhost:8000/connection/websocket", opts, listener);\n\nclient.connect();\n'))),(0,a.kt)(s.Z,{value:"go",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'client := centrifuge.NewJsonClient(\n    "ws://localhost:8000/connection/websocket",\n    centrifuge.Config{},\n)\ndefer client.Close()\n\nclient.OnConnecting(func(e centrifuge.ConnectingEvent) {\n    log.Printf("Connecting - %d (%s)", e.Code, e.Reason)\n})\nclient.OnConnected(func(e centrifuge.ConnectedEvent) {\n    log.Printf("Connected with ID %s", e.ClientID)\n})\nclient.OnDisconnected(func(e centrifuge.DisconnectedEvent) {\n    log.Printf("Disconnected: %d (%s)", e.Code, e.Reason)\n})\n\n_ = client.connect()\n')))),(0,a.kt)("p",null,"In case of successful connection Client states will transition like this:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"disconnected")," (initial) -> ",(0,a.kt)("inlineCode",{parentName:"p"},"connecting")," (",(0,a.kt)("inlineCode",{parentName:"p"},"on('connecting')")," called) -> ",(0,a.kt)("inlineCode",{parentName:"p"},"connected")," (",(0,a.kt)("inlineCode",{parentName:"p"},"on('connected')")," called)."),(0,a.kt)("p",null,"In case of already connected Client temporary lost a connection with a server and then successfully reconnected:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"connected")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"connecting")," (",(0,a.kt)("inlineCode",{parentName:"p"},"on('connecting')")," called) -> ",(0,a.kt)("inlineCode",{parentName:"p"},"connected")," (",(0,a.kt)("inlineCode",{parentName:"p"},"on('connected')")," called)."),(0,a.kt)("p",null,"In case of already connected Client temporary lost a connection with a server, but got a terminal error upon reconnection:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"connected")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"connecting")," (",(0,a.kt)("inlineCode",{parentName:"p"},"on('connecting')")," called) -> ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnected")," (",(0,a.kt)("inlineCode",{parentName:"p"},"on('disconnected')")," called)."),(0,a.kt)("p",null,"In case of already connected Client came across terminal condition (for example, if during a connection token refresh application found that user has no permission to connect anymore):"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"connected")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnected")," (",(0,a.kt)("inlineCode",{parentName:"p"},"on('disconnected')")," called)."),(0,a.kt)("p",null,"Both ",(0,a.kt)("inlineCode",{parentName:"p"},"connecting")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnected")," events have numeric ",(0,a.kt)("inlineCode",{parentName:"p"},"code")," and human-readable string ",(0,a.kt)("inlineCode",{parentName:"p"},"reason")," in their context, so you can look at them and find the exact reason why the Client went to the ",(0,a.kt)("inlineCode",{parentName:"p"},"connecting")," state or to the ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnected")," state."),(0,a.kt)("p",null,"This diagram demonstrates possible Client state transitions:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Centrifugo scheme",src:t(7262).Z,width:"2352",height:"1700"})),(0,a.kt)("p",null,"You can also listen for all errors happening internally (which are not reflected by state changes, for example, transport errors happening on initial connect, transport during reconnect, connection token refresh related errors, etc) while the client works by using ",(0,a.kt)("inlineCode",{parentName:"p"},"error")," event:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"client.on('error', function(ctx) {\n    console.log('client error', ctx);\n});\n")),(0,a.kt)("p",null,"If you want to disconnect from a server call ",(0,a.kt)("inlineCode",{parentName:"p"},".disconnect()")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"client.disconnect();\n")),(0,a.kt)("p",null,"In this case ",(0,a.kt)("inlineCode",{parentName:"p"},"on('disconnected')")," will be called. You can call ",(0,a.kt)("inlineCode",{parentName:"p"},"connect()")," again when you need to establish a connection."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"closed")," state implemented in SDKs where resources like internal queues, thread executors, etc must be cleaned up when the Client is not needed anymore. All subscriptions should automatically go to the ",(0,a.kt)("inlineCode",{parentName:"p"},"unsubscribed")," state upon closing. The client is not usable after going to a ",(0,a.kt)("inlineCode",{parentName:"p"},"closed")," state."),(0,a.kt)("h2",{id:"client-common-options"},"Client common options"),(0,a.kt)("p",null,"There are several common options available when creating Client instance."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"option to set connection token and callback to get connection token upon expiration (see below ",(0,a.kt)("a",{parentName:"li",href:"#client-connection-token"},"mode details"),")"),(0,a.kt)("li",{parentName:"ul"},"option to set connect data"),(0,a.kt)("li",{parentName:"ul"},"option to configure operation timeout"),(0,a.kt)("li",{parentName:"ul"},"tweaks for reconnect backoff algorithm (min delay, max delay)"),(0,a.kt)("li",{parentName:"ul"},"configure max delay of server pings (to detect broken connection)"),(0,a.kt)("li",{parentName:"ul"},"configure headers to send in WebSocket upgrade request (except ",(0,a.kt)("inlineCode",{parentName:"li"},"centrifuge-js"),")"),(0,a.kt)("li",{parentName:"ul"},"configure client name and version for analytics purpose")),(0,a.kt)("h2",{id:"client-methods"},"Client methods"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"connect()")," \u2013 connect to a server"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"disconnect()")," - disconnect from a server"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"close()")," - close Client if not needed anymore"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"send(data)")," - send asynchronous message to a server"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"rpc(method, data)")," - send arbitrary RPC and wait for response")),(0,a.kt)("h2",{id:"client-connection-token"},"Client connection token"),(0,a.kt)("p",null,"All SDKs support connecting to Centrifugo with JWT. Initial connection token can be set in Client option upon initialization. Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const client = new Centrifuge('ws://localhost:8000/connection/websocket', {\n    token: 'JWT-GENERATED-ON-BACKEND-SIDE'\n});\n")),(0,a.kt)("p",null,"If the token sets connection expiration then the client SDK will keep the token refreshed. It does this by calling a special callback function. This callback must return a new token. If a new token with updated connection expiration is returned from callback then it's sent to Centrifugo. In case of error returned by your callback SDK will retry the operation after some jittered time."),(0,a.kt)("p",null,"An example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"async function getToken() {\n    if (!loggedIn) {\n        return \"\"; // Empty token or pre-generated token for anonymous users.\n    }\n    // Fetch your application backend.\n    const res = await fetch('http://localhost:8000/centrifugo/connection_token');\n    if (!res.ok) {\n        if (res.status === 403) {\n            // Return special error to not proceed with token refreshes,\n            // client will be disconnected.\n            throw new Centrifuge.UnauthorizedError();\n        }\n        // Any other error thrown will result into token refresh re-attempts.\n        throw new Error(`Unexpected status code ${res.status}`);\n    }\n    const data = await res.json();\n    return data.token;\n}\n\nconst client = new Centrifuge(\n    'ws://localhost:8000/connection/websocket',\n    {\n        token: 'JWT-GENERATED-ON-BACKEND-SIDE', // Optional, getToken is enough.\n        getToken: getToken\n    }\n);\n")),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"If initial token is not provided, but ",(0,a.kt)("inlineCode",{parentName:"p"},"getToken")," is specified \u2013 then SDK should assume that developer wants to use token authentication. In this case SDK should attempt to get a connection token before establishing an initial connection.")),(0,a.kt)("h2",{id:"connection-pingpong"},"Connection PING/PONG"),(0,a.kt)("p",null,"PINGs sent by a server, a client should answer with PONGs upon receiving PING. If a client does not receive PING from a server for a long time (ping interval + configured delay) \u2013 the connection is considered broken and will be re-established."),(0,a.kt)("h2",{id:"subscription-states"},"Subscription states"),(0,a.kt)("p",null,"Client allows subscribing on channels. This can be done by creating ",(0,a.kt)("inlineCode",{parentName:"p"},"Subscription")," object."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const sub = centrifuge.newSubscription(channel);\nsub.subscribe();\n")),(0,a.kt)("p",null,"When a",(0,a.kt)("inlineCode",{parentName:"p"},"newSubscription")," method is called Client allocates a new Subscription instance and saves it in the internal subscription registry. Having a registry of allocated subscriptions allows SDK to manage resubscribes upon reconnecting to a server. Centrifugo connectors do not allow creating two subscriptions to the same channel \u2013 in this case, ",(0,a.kt)("inlineCode",{parentName:"p"},"newSubscription")," can throw an exception."),(0,a.kt)("p",null,"Subscription has 3 states:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"unsubscribed")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"subscribing")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"subscribed"))),(0,a.kt)("p",null,"When a new Subscription is created it has an ",(0,a.kt)("inlineCode",{parentName:"p"},"unsubscribed")," state."),(0,a.kt)("p",null,"To initiate the actual process of subscribing to a channel ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribe()")," method of Subscription instance should be called. After calling ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribe()")," Subscription moves to ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribing")," state."),(0,a.kt)("p",null,"If subscription to a channel is not successful then depending on error type subscription can automatically resubscribe (with exponential backoff) or go to an ",(0,a.kt)("inlineCode",{parentName:"p"},"unsubscribed")," state (upon non-temporary error). If subscription to a channel is successful then the state becomes ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribed"),"."),(0,a.kt)(o.Z,{className:"unique-tabs",defaultValue:"javascript",values:[{label:"Javascript",value:"javascript"},{label:"Dart",value:"dart"},{label:"Swift",value:"swift"},{label:"Java",value:"java"},{label:"Go",value:"go"}],mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"javascript",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const sub = client.newSubscription(channel);\n\nsub.on('subscribing', function(ctx) {\n    console.log('subscribing');\n});\n\nsub.on('subscribed', function(ctx) {\n    console.log('subscribed');\n});\n\nsub.on('unsubscribed', function(ctx) {\n    console.log('unsubscribed');\n});\n\nsub.subscribe();\n"))),(0,a.kt)(s.Z,{value:"dart",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-dart"},"final onSubscriptionEvent = (dynamic event) async {\n  print('subscription $channel> $event');\n};\n\nfinal subscription = client.newSubscription(channel);\n\nsubscription.subscribing.listen(onSubscriptionEvent);\nsubscription.subscribed.listen(onSubscriptionEvent);\nsubscription.unsubscribed.listen(onSubscriptionEvent);\n\nawait subscription.subscribe();\n"))),(0,a.kt)(s.Z,{value:"swift",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},'class SubscriptionDelegate : NSObject, CentrifugeSubscriptionDelegate {\n    func onSubscribing(_ s: CentrifugeSubscription, _ e: CentrifugeSubscribingEvent) {\n        print("subscribing", e.code, e.reason)\n    }\n    func onSubscribed(_ s: CentrifugeSubscription, _ e: CentrifugeSubscribedEvent) {\n        print("subscribed")\n    }\n    func onUnsubscribed(_ s: CentrifugeSubscription, _ e: CentrifugeUnsubscribedEvent) {\n        print("unsubscribed", e.code, e.reason)\n    }\n}\n\ndo {\n    sub = try self.client?.newSubscription(channel: "example", delegate: SubscriptionDelegate())\n    sub!.subscribe()\n} catch {\n    print("Can not create subscription: \\(error)")\n}\n'))),(0,a.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'SubscriptionEventListener subListener = new SubscriptionEventListener() {\n    @Override\n    public void onSubscribed(Subscription sub, SubscribedEvent event) {\n        System.out.println("subscribed to " + sub.getChannel());\n    }\n    @Override\n    public void onSubscribing(Subscription sub, SubscribingEvent event) {\n        System.out.printf("subscribing " + sub.getChannel());\n    }\n    @Override\n    public void onUnsubscribed(Subscription sub, UnsubscribedEvent event) {\n        System.out.println("unsubscribed " + sub.getChannel());\n    }\n};\n\nSubscription sub;\ntry {\n    sub = client.newSubscription("example", subListener);\n    sub.subscribe();\n} catch (DuplicateSubscriptionException e) {\n    e.printStackTrace();\n}\n'))),(0,a.kt)(s.Z,{value:"go",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'sub, err := client.NewSubscription("example")\nif err != nil {\n    log.Fatalln(err)\n}\n\nsub.OnSubscribing(func(e centrifuge.SubscribingEvent) {\n    log.Printf("Subscribing on channel %s - %d (%s)", sub.Channel, e.Code, e.Reason)\n})\nsub.OnSubscribed(func(e centrifuge.SubscribedEvent) {\n    log.Printf("Subscribed on channel %s", sub.Channel)\n})\nsub.OnUnsubscribed(func(e centrifuge.UnsubscribedEvent) {\n    log.Printf("Unsubscribed from channel %s - %d (%s)", sub.Channel, e.Code, e.Reason)\n})\n\nerr = sub.Subscribe()\nif err != nil {\n    log.Fatalln(err)\n}\n')))),(0,a.kt)("p",null,"Subscriptions also go to ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribing")," state when Client connection (i.e. transport) becomes unavailable. Upon connection re-establishement all subscriptions which are not in ",(0,a.kt)("inlineCode",{parentName:"p"},"unsubscribed")," state will resubscribe automatically."),(0,a.kt)("p",null,"In case of successful subscription states will transition like this:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"unsubscribed")," (initial) -> ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribing")," (",(0,a.kt)("inlineCode",{parentName:"p"},"on('subscribing')")," called) -> ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribed")," (",(0,a.kt)("inlineCode",{parentName:"p"},"on('subscribed')")," called)."),(0,a.kt)("p",null,"In case of connected and subscribed Client temporary lost a connection with a server and then succesfully reconnected and resubscribed:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"subscribed")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribing")," (",(0,a.kt)("inlineCode",{parentName:"p"},"on('subscribing')")," called) -> ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribed")," (",(0,a.kt)("inlineCode",{parentName:"p"},"on('subscribed')")," called)."),(0,a.kt)("p",null,"Both ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribing")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"unsubscribed")," events have numeric ",(0,a.kt)("inlineCode",{parentName:"p"},"code")," and human-readable string ",(0,a.kt)("inlineCode",{parentName:"p"},"reason")," in their context, so you can look at them and find the exact reason why Subscription went to subscribing state or to unsubscribed state."),(0,a.kt)("p",null,"This diagram demonstrates possible Subscription state transitions:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Centrifugo scheme",src:t(3305).Z,width:"2391",height:"1672"})),(0,a.kt)("p",null,"You can listen for all errors happening internally in Subscription (which are not reflected by state changes, for example, temporary subscribe errors, subscription token related errors, etc) by using ",(0,a.kt)("inlineCode",{parentName:"p"},"error")," event:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"sub.on('error', function(ctx) {\n    console.log(\"subscription error\", ctx);\n});\n")),(0,a.kt)("p",null,"If you want to unsubscribe from a channel call ",(0,a.kt)("inlineCode",{parentName:"p"},".unsubscribe()")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"sub.unsubscribe();\n")),(0,a.kt)("p",null,"In this case ",(0,a.kt)("inlineCode",{parentName:"p"},"on('unsubscribed')")," will be called. Subscription still kept in Client's registry, but no resubscription attempts will be made. You can call ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribe()")," again when you need Subscription again. Or you can remove Subscription from Client's registry (see below)."),(0,a.kt)("h2",{id:"subscription-management"},"Subscription management"),(0,a.kt)("p",null,"The client SDK provides several methods to manage the internal registry of client-side subscriptions."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"newSubscription(channel, options)")," allocates a new Subscription in the registry or throws an exception if the Subscription is already there. We will discuss common Subscription options below. "),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"getSubscription(channel)")," returns the existing Subscription by a channel from the registry (or null if it does not exist)."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"removeSubscription(sub)")," removes Subscription from Client's registry. Subscription is automatically unsubscribed before being removed. Use this to free resources if you don't need a Subscription to a channel anymore."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"subscriptions()")," returns all registered subscriptions, so you can iterate over all and do some action if required (for example, you want to unsubscribe/remove all subscriptions)."),(0,a.kt)("h2",{id:"listen-to-channel-publications"},"Listen to channel publications"),(0,a.kt)("p",null,"Of course the main point of having Subscriptions is the ability to listen for publications (i.e. messages published to a channel)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"sub.on('publication', function(ctx) {\n    console.log(\"received publication\", ctx);\n});\n")),(0,a.kt)("p",null,"Publication context has several fields:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"data")," - publication payload, this can be JSON or binary data"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"offset")," - optional offset inside history stream, this is an incremental number"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"tags")," - optional tags, this is a map with string keys and string values"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"info")," - optional information about client connection who published this (only exists if publication comes from client-side ",(0,a.kt)("inlineCode",{parentName:"li"},"publish()")," API).")),(0,a.kt)("p",null,"So minimal code where we connect to a server and listen for messages published into ",(0,a.kt)("inlineCode",{parentName:"p"},"example")," channel may look like:"),(0,a.kt)(o.Z,{className:"unique-tabs",defaultValue:"javascript",values:[{label:"Javascript",value:"javascript"},{label:"Dart",value:"dart"},{label:"Swift",value:"swift"},{label:"Java",value:"java"},{label:"Go",value:"go"}],mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"javascript",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const client = new Centrifuge('ws://localhost:8000/connection/websocket', {});\n\nconst sub = client.newSubscription('example').on('publication', function(ctx) {\n    console.log(\"received publication from a channel\", ctx.data);\n});\n\nsub.subscribe();\n\nclient.connect();\n"))),(0,a.kt)(s.Z,{value:"dart",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-dart"},"final client = centrifuge.createClient(\n    'ws://localhost:8000/connection/websocket',\n    centrifuge.ClientConfig(),\n);\n\nfinal subscription = client.newSubscription(channel);\nsubscription.publication.listen((event) {\n    print(event);\n});\nawait subscription.subscribe();\n\nawait client.connect();\n"))),(0,a.kt)(s.Z,{value:"swift",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},'import SwiftCentrifuge\n\nclass ClientDelegate : NSObject, CentrifugeClientDelegate {}\n\nlet config = CentrifugeClientConfig()\nlet endpoint = "ws://localhost:8000/connection/websocket"\nlet client = CentrifugeClient(endpoint: endpoint, config: config, delegate: ClientDelegate())\n\nclass SubscriptionDelegate : NSObject, CentrifugeSubscriptionDelegate {\n    func onPublication(_ s: CentrifugeSubscription, _ e: CentrifugePublicationEvent) {\n        print("publication", e.data)\n    }\n}\n\ndo {\n    sub = try self.client?.newSubscription(channel: "example", delegate: SubscriptionDelegate())\n    sub!.subscribe()\n} catch {\n    print("Can not create subscription: \\(error)")\n}\n\nclient.connect()\n'))),(0,a.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'EventListener listener = new EventListener() {};\nOptions opts = new Options();\nClient client = new Client("ws://localhost:8000/connection/websocket", opts, listener);\n\nSubscriptionEventListener subListener = new SubscriptionEventListener() {\n    @Override\n    public void onPublication(Subscription sub, PublicationEvent event) {\n        System.out.println("publication from " + sub.getChannel());\n    }\n};\n\nSubscription sub;\ntry {\n    sub = client.newSubscription("example", subListener);\n    sub.subscribe();\n} catch (DuplicateSubscriptionException e) {\n    e.printStackTrace();\n}\n\nclient.connect();\n'))),(0,a.kt)(s.Z,{value:"go",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'client := centrifuge.NewJsonClient(\n    "ws://localhost:8000/connection/websocket",\n    centrifuge.Config{},\n)\n// defer client.Close()\n\nsub, err := client.NewSubscription("example")\nif err != nil {\n    log.Fatalln(err)\n}\n\nsub.OnPublication(func(e centrifuge.PublicationEvent) {\n    log.Printf("Publication from channel")\n})\n\nerr = sub.Subscribe()\nif err != nil {\n    log.Fatalln(err)\n}\n\nif err = client.Connect(); err != nil {\n    log.Fatalln(err)\n}\n')))),(0,a.kt)("p",null,"Note, that we can call ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribe()")," before making a connection to a server \u2013 and this will work just fine, subscription goes to ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribing")," state and will be subscribed upon succesfull connection. And of course, it's possible to call ",(0,a.kt)("inlineCode",{parentName:"p"},".subscribe()")," after ",(0,a.kt)("inlineCode",{parentName:"p"},".connect()"),". "),(0,a.kt)("h2",{id:"subscription-recovery-state"},"Subscription recovery state"),(0,a.kt)("p",null,"Subscriptions to channels with recovery option enabled maintain stream position information internally. On every publication received this information updated and used to recover missed publications upon resubscribe (caused by reconnect for example)."),(0,a.kt)("p",null,"When you call ",(0,a.kt)("inlineCode",{parentName:"p"},"unsubscribe()")," Subscription position state is not cleared. So it's possible to call ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribe()")," later and catch up a state."),(0,a.kt)("p",null,"The recovery process result \u2013 i.e. whether all missed publications recovered or not \u2013 can be found in ",(0,a.kt)("inlineCode",{parentName:"p"},"on('subscribed')")," event context. Centrifuge protocol provides two fields:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"wasRecovering")," - boolean flag that tells whether recovery was used during subscription process resulted into subscribed state. Can be useful if you want to distinguish first subscribe attempt (when subscription does not have any position information yet)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"recovered")," - boolean flag that tells whether Centrifugo thinks that all missed publications can be successfully recovered and there is no need to load state from the main application database. It's always ",(0,a.kt)("inlineCode",{parentName:"li"},"false")," when ",(0,a.kt)("inlineCode",{parentName:"li"},"wasRecovering")," is ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),".")),(0,a.kt)("h2",{id:"subscription-common-options"},"Subscription common options"),(0,a.kt)("p",null,"There are several common options available when creating Subscription instance."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"option to set subscription token and callback to get subscription token upon expiration (see ",(0,a.kt)("a",{parentName:"li",href:"#subscription-token"},"below more details"),")"),(0,a.kt)("li",{parentName:"ul"},"option to set subscription ",(0,a.kt)("inlineCode",{parentName:"li"},"data")," (attached to every subscribe/resubscribe request)"),(0,a.kt)("li",{parentName:"ul"},"options to tweak resubscribe backoff algorithm"),(0,a.kt)("li",{parentName:"ul"},"option to start Subscription ",(0,a.kt)("inlineCode",{parentName:"li"},"since")," known Stream Position (i.e. attempt recovery on first subscribe)"),(0,a.kt)("li",{parentName:"ul"},"option to ask server to make subscription ",(0,a.kt)("inlineCode",{parentName:"li"},"positioned")," (if not forced by a server)"),(0,a.kt)("li",{parentName:"ul"},"option to ask server to make subscription ",(0,a.kt)("inlineCode",{parentName:"li"},"recoverable")," (if not forced by a server)"),(0,a.kt)("li",{parentName:"ul"},"option to ask server to push Join/Leave messages (if not forced by a server)")),(0,a.kt)("h2",{id:"subscription-methods"},"Subscription methods"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"subscribe()")," \u2013 start subscribing to a channel"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"unsubscribe()")," - unsubscribe from a channel"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"publish(data)")," - publish data to Subscription channel"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"history(options)")," - request Subscription channel history"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"presence()")," - request Subscription channel online presence information"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"presenceStats()")," - request Subscription channel online presence stats information (number of client connections and unique users in a channel).")),(0,a.kt)("h2",{id:"subscription-token"},"Subscription token"),(0,a.kt)("p",null,"All SDKs support subscribing to Centrifugo channels with JWT. Channel subscription token can be set as a Subscription option upon initialization. Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const sub = centrifuge.newSubscription(channel, {\n    token: 'JWT-GENERATED-ON-BACKEND-SIDE'\n});\nsub.subscribe();\n")),(0,a.kt)("p",null,"If token sets subscription expiration client SDK will keep token refreshed. It does this by calling special callback function. This callback must return a new token. If new token with updated subscription expiration returned from a calbback then it's sent to Centrifugo. If your callback returns an empty string \u2013 this means user has no permission to subscribe to a channel anymore and subscription will be unsubscribed. In case of error returned by your callback SDK will retry operation after some jittered time. "),(0,a.kt)("p",null,"An example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"async function getToken(ctx) {\n    // Fetch your application backend.\n    const res = await fetch('http://localhost:8000/centrifugo/subscription_token', {\n        method: 'POST',\n        headers: new Headers({ 'Content-Type': 'application/json' }),\n        body: JSON.stringify({\n            channel: ctx.channel\n        })\n    });\n    if (!res.ok) {\n        if (res.status === 403) {\n            // Return special error to not proceed with token refreshes,\n            // client will be disconnected.\n            throw new Centrifuge.UnauthorizedError();\n        }\n        // Any other error thrown will result into token refresh re-attempts.\n        throw new Error(`Unexpected status code ${res.status}`);\n    }\n    const data = await res.json();\n    return data.token;\n}\n\nconst client = new Centrifuge('ws://localhost:8000/connection/websocket', {});\n\nconst sub = centrifuge.newSubscription(channel, {\n    token: 'JWT-GENERATED-ON-BACKEND-SIDE', // Optional, getToken is enough.\n    getToken: getToken\n});\nsub.subscribe();\n")),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"If initial token is not provided, but ",(0,a.kt)("inlineCode",{parentName:"p"},"getToken")," is specified \u2013 then SDK should assume that developer wants to use token authorization for a channel subscription. In this case SDK should attempt to get a subscription token before initial subscribe.")),(0,a.kt)("h2",{id:"server-side-subscriptions"},"Server-side subscriptions"),(0,a.kt)("p",null,"We encourage using client-side subscriptions where possible as they provide a better control and isolation from connection. But in some cases you may want to use server-side subscriptions (i.e. subscriptions created by server upon connection establishment)."),(0,a.kt)("p",null,"Technically, client SDK keeps server-side subscriptions in internal registry (similar to client-side subscriptions but without possibility to control them)."),(0,a.kt)("p",null,"To listen for server-side subscription events use callbacks as shown in example below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const client = new Centrifuge('ws://localhost:8000/connection/websocket', {});\n\nclient.on('subscribed', function(ctx) {\n    // Called when subscribed to a server-side channel upon Client moving to\n    // connected state or during connection lifetime if server sends Subscribe\n    // push message.\n    console.log('subscribed to server-side channel', ctx.channel);\n});\n\nclient.on('subscribing', function(ctx) {\n    // Called when existing connection lost (Client reconnects) or Client\n    // explicitly disconnected. Client continue keeping server-side subscription\n    // registry with stream position information where applicable.\n    console.log('subscribing to server-side channel', ctx.channel);\n});\n\nclient.on('unsubscribed', function(ctx) {\n    // Called when server sent unsubscribe push or server-side subscription\n    // previously existed in SDK registry disappeared upon Client reconnect.\n    console.log('unsubscribed from server-side channel', ctx.channel);\n});\n\nclient.on('publication', function(ctx) {\n    // Called when server sends Publication over server-side subscription.\n    console.log('publication receive from server-side channel', ctx.channel, ctx.data);\n});\n\nclient.connect();\n")),(0,a.kt)("p",null,"Server-side subscription events mostly mimic events of client-side subscriptions. But again \u2013 they do not provide control to the client and managed entirely by a server side."),(0,a.kt)("p",null,"Additionally, Client has several top-level methods to call with server-side subscription related operations:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"publish(channel, data)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"history(channel, options)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"presence(channel)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"presenceStats(channel)"))),(0,a.kt)("h2",{id:"error-codes"},"Error codes"),(0,a.kt)("p",null,"Server can return error codes in range 100-1999. Error codes in interval 0-399 reserved by Centrifuge/Centrifugo server. Codes in range ","[400, 1999]"," may be returned by application code built on top of Centrifuge/Centrifugo."),(0,a.kt)("p",null,"Server errors contain a ",(0,a.kt)("inlineCode",{parentName:"p"},"temporary")," boolean flag which works as a signal that error may be fixed by a later retry."),(0,a.kt)("p",null,"Errors with codes 0-100 can be used by client-side implementation. Client-side errors may not have code attached at all since in many languages error can be distinguished by its type."),(0,a.kt)("h2",{id:"unsubscribe-codes"},"Unsubscribe codes"),(0,a.kt)("p",null,"Server may return unsubscribe codes. Server unsubscribe codes must be in range ","[2000, 2999]","."),(0,a.kt)("p",null,"Unsubscribe codes >= 2500 coming from server to client result into automatic resubscribe attempt (i.e. client goes to ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribing")," state). Codes < 2500 result into going to ",(0,a.kt)("inlineCode",{parentName:"p"},"unsubscribed")," state."),(0,a.kt)("p",null,"Client implementation can use codes <2000 for client-side specific unsubscribe reasons. "),(0,a.kt)("h2",{id:"disconnect-codes"},"Disconnect codes"),(0,a.kt)("p",null,"Server may send custom disconnect codes to a client. Custom disconnect codes must be in range ","[3000, 4999]","."),(0,a.kt)("p",null,"Client automatically reconnects upon receiving code in range 3000-3499, 4000-4499 (i.e. Client goes to ",(0,a.kt)("inlineCode",{parentName:"p"},"connecting")," state). Other codes result into going to ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnected")," state."),(0,a.kt)("p",null,"Client implementation can use codes <3000 for client-side specific disconnect reasons. "),(0,a.kt)("h2",{id:"rpc"},"RPC"),(0,a.kt)("p",null,"An SDK provides a way to send RPC to a server. RPC is a call that is not related to channels at all. It's just a way to call the server method from the client-side over the real-time connection. RPC is only available when ",(0,a.kt)("a",{parentName:"p",href:"/docs/server/proxy#rpc-proxy"},"RPC proxy")," configured (so Centrifugo proxies the RPC to your application backend)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const rpcRequest = {'key': 'value'};\nconst data = await centrifuge.namedRPC('example_method', rpcRequest);\n")),(0,a.kt)("h2",{id:"channel-history-api"},"Channel history API"),(0,a.kt)("p",null,"SDK provides a method to call publication history inside a channel (only for channels where history is enabled) to get last publications in a channel."),(0,a.kt)("p",null,"Get stream current top position:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const resp = await subscription.history();\nconsole.log(resp.offset);\nconsole.log(resp.epoch);\n")),(0,a.kt)("p",null,"Get up to 10 publications from history since known stream position:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const resp = await subscription.history({limit: 10, since: {offset: 0, epoch: '...'}});\nconsole.log(resp.publications);\n")),(0,a.kt)("p",null,"Get up to 10 publications from history since current stream beginning:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const resp = await subscription.history({limit: 10});\nconsole.log(resp.publications);\n")),(0,a.kt)("p",null,"Get up to 10 publications from history since current stream end in reversed order (last to first):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const resp = await subscription.history({limit: 10, reverse: true});\nconsole.log(resp.publications);\n")),(0,a.kt)("h2",{id:"presence-and-presence-stats-api"},"Presence and presence stats API"),(0,a.kt)("p",null,"Once subscribed client can call presence and presence stats information inside channel (only for channels where ",(0,a.kt)("a",{parentName:"p",href:"/docs/server/channels#channel-options"},"presence configured"),"):"),(0,a.kt)("p",null,"For presence (full information about active subscribers in channel):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const resp = await subscription.presence();\n// resp contains presence information - a map client IDs as keys \n// and client information as values.\n")),(0,a.kt)("p",null,"For presence stats (just a number of clients and unique users in a channel):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const resp = await subscription.presenceStats();\n// resp contains a number of clients and a number of unique users.\n")),(0,a.kt)("h2",{id:"sdk-common-best-practices"},"SDK common best practices"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Callbacks must be fast. Avoid blocking operations inside event handlers. Callbacks caused by protocol messages received from a server are called synchronously and connection read loop is blocked while such callbacks are being executed. Consider doing heavy work asynchronously."),(0,a.kt)("li",{parentName:"ul"},"Do not blindly rely on the current Client or Subscription state when making client API calls \u2013 state can change at any moment, so don't forget to handle errors."),(0,a.kt)("li",{parentName:"ul"},"Disconnect from a server when a mobile application goes to the background since a mobile OS can kill the connection at some point without any callbacks called.")))}b.isMDXComponent=!0},3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>b});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=i.createContext({}),c=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=c(e.components);return i.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},d=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),d=c(t),b=a,m=d["".concat(l,".").concat(b)]||d[b]||p[b]||o;return t?i.createElement(m,s(s({ref:n},u),{},{components:t})):i.createElement(m,s({ref:n},u))}));function b(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=d;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var c=2;c<o;c++)s[c]=t[c];return i.createElement.apply(null,s)}return i.createElement.apply(null,t)}d.displayName="MDXCreateElement"},7262:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/client_state-34264b7a7eee2792baa58bb5bb525d46.png"},3305:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/sub_state-9dbaf6d2a6868264a330b1a3f4c59b39.png"}}]);