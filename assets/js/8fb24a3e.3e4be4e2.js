"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[5496],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var i=t(96540);const a={},r=i.createContext(a);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},28482:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var i=t(72859),a=t(74848),r=t(28453);const o={title:"Building a real-time WebSocket leaderboard with Centrifugo and Redis",tags:["centrifugo","redis","react","python","tutorial"],description:"In this article, we create a real-time leaderboard using Centrifugo, Redis, React and Python. Here we show the usage of Centrifugo built-in asynchronous consumer from Redis Stream. The post additionally showcases Fossil delta compression and cache recovery mode.",author:"Alexander Emelin",authorTitle:"Founder of Centrifugal Labs",authorImageURL:"/img/alexander_emelin.jpeg",image:"/img/leaderboard.jpg",hide_table_of_contents:!1},s=void 0,d={authorsImageUrls:[void 0]},l=[{value:"How application works",id:"how-application-works",level:2},{value:"Tutorial source code",id:"tutorial-source-code",level:2},{value:"Project Structure",id:"project-structure",level:2},{value:"Building the Backend Service",id:"building-the-backend-service",level:2},{value:"Configuring Centrifugo",id:"configuring-centrifugo",level:2},{value:"Creating the Frontend React Application",id:"creating-the-frontend-react-application",level:2},{value:"Configuring Nginx",id:"configuring-nginx",level:2},{value:"Running the Application",id:"running-the-application",level:2},{value:"Adding Fossil delta compression",id:"adding-fossil-delta-compression",level:2},{value:"Adding cache recovery mode",id:"adding-cache-recovery-mode",level:2},{value:"Other possible improvements",id:"other-possible-improvements",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["Centrifugo v6.2.0 added a bunch of new asynchronous consumers and new publish API fields such as ",(0,a.jsx)(n.code,{children:"version"})," and ",(0,a.jsx)(n.code,{children:"version_epoch"}),". Here, we are covering these changes by a new tutorial."]}),"\n",(0,a.jsx)(n.p,{children:"In the tutorial, we'll build a real-time leaderboard application that updates dynamically as scores change. We'll use Centrifugo for real-time updates, Redis for storing leaderboard data, React for the frontend, and some Python to trigger ranking changes. This is a nice example of how Centrifugo can be used to create interactive, real-time applications with minimal effort."}),"\n",(0,a.jsx)("video",{width:"100%",loop:!0,autoPlay:"autoplay",muted:!0,controls:"",src:"/img/leaderboard_demo.mp4"}),"\n",(0,a.jsx)(n.h2,{id:"how-application-works",children:"How application works"}),"\n",(0,a.jsx)(n.p,{children:"Our application will:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Simulate score updates for a set of players"}),"\n",(0,a.jsx)(n.li,{children:"Keep the leaderboard data in Redis ZSET (Sorted Set) data structure"}),"\n",(0,a.jsx)(n.li,{children:"Atomically push leaderboard state to Redis STREAM data structure"}),"\n",(0,a.jsx)(n.li,{children:"Use Centrifugo to consume Redis Stream and push real-time updates to subscribed clients"}),"\n",(0,a.jsx)(n.li,{children:"Display the leaderboard with real-time updates and smooth animations when rankings change"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"tutorial-source-code",children:"Tutorial source code"}),"\n",(0,a.jsxs)(n.p,{children:["Jump directly to the tutorial source code which ",(0,a.jsx)(n.a,{href:"https://github.com/centrifugal/examples/tree/master/v6/leaderboard",children:"may be found on Github"}),". Clone the repo, ",(0,a.jsx)(n.code,{children:"cd"})," into ",(0,a.jsx)(n.code,{children:"leaderboard"})," directory and run:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"docker compose up\n"})}),"\n",(0,a.jsx)(n.h2,{id:"project-structure",children:"Project Structure"}),"\n",(0,a.jsx)(n.p,{children:"Here's the structure of our project:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"leaderboard/\n\u251c\u2500\u2500 backend/\n\u2502   \u251c\u2500\u2500 app.py                 # Python backend service\n\u2502   \u251c\u2500\u2500 Dockerfile             # Backend Docker configuration\n\u2502   \u251c\u2500\u2500 requirements.txt       # Python dependencies\n\u2502   \u2514\u2500\u2500 lua/\n\u2502       \u2514\u2500\u2500 update_leaderboard.lua  # Redis Lua script\n\u251c\u2500\u2500 centrifugo/\n\u2502   \u2514\u2500\u2500 config.json            # Centrifugo configuration\n\u251c\u2500\u2500 nginx/\n\u2502   \u2514\u2500\u2500 nginx.conf             # Nginx configuration\n\u251c\u2500\u2500 web/\n\u2502   \u251c\u2500\u2500 public/                # React public assets\n\u2502   \u251c\u2500\u2500 src/                   # React source code\n\u2502   \u251c\u2500\u2500 Dockerfile             # Frontend Docker configuration\n\u2502   \u2514\u2500\u2500 package.json           # Frontend dependencies\n\u2514\u2500\u2500 docker-compose.yml         # Docker Compose configuration\n"})}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"docker-compose.yml"})," file is used to combine all the parts together:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'version: "3.8"\n\nservices:\n  redis:\n    image: redis:7\n    ports:\n      - "6379:6379"\n\n  centrifugo:\n    image: centrifugo/centrifugo:v6.2.0\n    volumes:\n      - ./centrifugo/config.json:/centrifugo/config.json\n    command: centrifugo --config=/centrifugo/config.json\n    ports:\n      - "8000:8000"\n    depends_on:\n      redis:\n        condition: service_started\n\n  backend:\n    build: ./backend\n    depends_on:\n      redis:\n        condition: service_started\n      centrifugo:\n        condition: service_started\n\n  nginx:\n    image: nginx:alpine\n    restart: always\n    ports:\n      - 8080:80\n    volumes:\n      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf\n    depends_on:\n      backend:\n        condition: service_started\n      web:\n        condition: service_started\n\n  web:\n    build: ./web\n    volumes:\n      - ./web:/app\n      - /app/node_modules\n    ports:\n      - "3000:3000"\n    command: sh -c "npm install && npm start"\n'})}),"\n",(0,a.jsx)(n.p,{children:"Here we use Redis to keep leaderboard data because it has a nice ZSET data structure which is famous for its fit for the leaderboard's use case \u2013 it's very efficient since data is being managed in-memory, allowing for fast read and write operations."}),"\n",(0,a.jsx)(n.p,{children:"Redis also provides a Lua scripting engine that allows us to perform atomic operations on the data. We use lua scripting actively in Centrifugo Redis integrations, and here we will also utilize the power of it to atomically fill Redis STREAM which will be consumed by Centrifugo."}),"\n",(0,a.jsx)(n.h2,{id:"building-the-backend-service",children:"Building the Backend Service"}),"\n",(0,a.jsx)(n.p,{children:"The backend in this tutorial is very thin and is responsible only for simulating score updates. Here is the whole Python code which triggers ranking updates in Redis:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import time\nimport random\nimport redis\n\ndef main():\n    r = redis.Redis(host=\'redis\', port=6379)\n\n    with open(\'lua/update_leaderboard.lua\', \'r\') as f:\n        lua_script = f.read()\n\n    update_leaderboard = r.register_script(lua_script)\n\n    leader_names = [\n        "Alice", "Bob", "Charlie", "David", "Eve",\n    ]\n\n    while True:\n        leader = random.choice(leader_names)\n        increment = random.randint(1, 10)\n        channel = "leaderboard"\n        update_leaderboard(\n            keys=["leaderboard", "leaderboard-state", "leaderboard-stream"],\n            args=[leader, increment, channel]\n        )\n        time.sleep(0.2)\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,a.jsx)(n.p,{children:"This Python script:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Connects to Redis"}),"\n",(0,a.jsx)(n.li,{children:"Loads the Lua script for updating the leaderboard"}),"\n",(0,a.jsx)(n.li,{children:"Randomly selects a player and increments their score"}),"\n",(0,a.jsx)(n.li,{children:"Calls the Lua script to update the leaderboard in Redis"}),"\n",(0,a.jsx)(n.li,{children:"Repeats this process every 0.2 seconds"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Lua script in ",(0,a.jsx)(n.code,{children:"backend/lua/update_leaderboard.lua"})," is more interesting:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- Get or create state hash containing both epoch and version\nlocal leaderboard_key = KEYS[1]\nlocal state_key = KEYS[2]\nlocal stream_key = KEYS[3]\n\nlocal name = ARGV[1]\nlocal score_inc = tonumber(ARGV[2])\nlocal channel = ARGV[3]\n\n-- Increment leaderboard score\nredis.call('ZINCRBY', leaderboard_key, score_inc, name)\n\nlocal epoch = redis.call(\"HGET\", state_key, \"epoch\")\nif not epoch then\n    local t = redis.call(\"TIME\")\n    epoch = tostring(t[1])\n    redis.call(\"HSET\", state_key, \"epoch\", epoch, \"version\", 0)\nend\n-- Increment version atomically using HINCRBY\nlocal version = redis.call(\"HINCRBY\", state_key, \"version\", 1)\n-- Always update TTL regardless of whether state is new or existing\nredis.call(\"EXPIRE\", state_key, 86400) -- Set TTL (24 hours, adjust as needed)\n\n-- Get leaderboard data\nlocal members = redis.call('ZREVRANGE', leaderboard_key, 0, -1, 'WITHSCORES')\nlocal leaders = {}\nfor i = 1, #members, 2 do\n    table.insert(leaders, { name = members[i], score = tonumber(members[i+1]) })\nend\n\n-- Prepare payload for Centrifugo publish API command.\nlocal publish_payload = {\n  channel = channel,\n  data = { leaders = leaders },\n  version = version, -- a tip for Centrifugo about state version\n  version_epoch = epoch, -- a tip for Centrifugo about state epoch\n}\n\n-- Add to stream which is consumed by Centrifugo.\nlocal payload = cjson.encode(publish_payload)\nredis.call('XADD', stream_key, 'MAXLEN', '~', 10000, '*', \n  'method', 'publish', 'payload', payload)\nreturn members\n"})}),"\n",(0,a.jsx)(n.p,{children:"This Lua script:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Increments a player's score in a Redis sorted set"}),"\n",(0,a.jsx)(n.li,{children:"Maintains a HASH to give Centrifugo a tip about leaderboard state version and version epoch"}),"\n",(0,a.jsx)(n.li,{children:"Retrieves the current leaderboard data and adds it to Redis STREAM together with version and version epoch fields. It adds it in a format which Centrifugo Redis Stream consumer understands."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"1 and 3 are rather self-explaining. But why do we need to maintain leaderboard state incremental version and its epoch?"}),"\n",(0,a.jsx)(n.p,{children:"The reason is that Redis Stream concurrent consumers working with a consumer group cannot maintain message ordering. So, if you have several Centrifugo instances consuming from the same Redis Stream, they are not able to guarantee that messages are processed in the order they were added to the stream."}),"\n",(0,a.jsxs)(n.p,{children:["Starting from Centrifugo v6.2.0, we can use ",(0,a.jsx)(n.code,{children:"version"})," and ",(0,a.jsx)(n.code,{children:"version_epoch"})," fields to ensure that clients always receive the most up-to-date state of the leaderboard, even if messages are processed out of order. When Centrifugo receives publications with versions less or equal to those already seen \u2013 it skips them, so the client does not receive non-actual data. Of course, this makes sense in cases like the one in this tutorial, where we are publishing the entire state to a channel. An important note is that for version logic to work, we will need to enable Centrifugo history for channels since version information is kept by Centrifugo in the history stream meta information object."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"version"})," is an incremental number, and the logic with it should be straightforward to understand. But why do we need ",(0,a.jsx)(n.code,{children:"version_epoch"}),"? The ",(0,a.jsx)(n.code,{children:"version_epoch"})," is a string that is used to identify the generation of the data. Since Redis is an in-memory data store, it is possible that the data may be lost if the Redis server is restarted or if the data is evicted from memory. By using ",(0,a.jsx)(n.code,{children:"version_epoch"})," and tracking its change, Centrifugo avoids a situation where the ",(0,a.jsx)(n.code,{children:"version"})," counter is restarted and Centrifugo ignores all updates until ",(0,a.jsx)(n.code,{children:"version"})," reaches the number seen before. Using ",(0,a.jsx)(n.code,{children:"version_epoch"})," is optional \u2013 if it's not passed to Centrifugo, then Centrifugo only looks at the ",(0,a.jsx)(n.code,{children:"version"})," field to make the decision."]}),"\n",(0,a.jsx)(n.p,{children:"Note that while we are using a single leaderboard in this tutorial, you can extend the Lua script to support multiple leaderboards by adding a leaderboard id/name to leaderboard ZSET and state HASH keys. The Redis STREAM key will stay the same \u2013 all updates will go through it, just use different channels in the publication object."}),"\n",(0,a.jsx)(n.h2,{id:"configuring-centrifugo",children:"Configuring Centrifugo"}),"\n",(0,a.jsx)(n.p,{children:"Now let's configure Centrifugo to consume the Redis Stream and push updates to connected clients."}),"\n",(0,a.jsxs)(n.p,{children:["To do this, we need Centrifugo to consume the Redis Stream, so ",(0,a.jsx)(n.code,{children:"centrifugo/config.json"})," may look like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n   "client": {\n      "insecure": true,\n      "allowed_origins": ["*"]\n   },\n   "channel": {\n      "without_namespace": {\n         "history_size": 1,\n         "history_ttl": "24h"\n      }\n   },\n   "consumers": [\n      {\n         "enabled": true,\n         "name": "leaderboard_redis",\n         "type": "redis_stream",\n         "redis_stream": {\n            "address": "redis:6379",\n            "streams": ["leaderboard-stream"],\n            "consumer_group": "centrifugo",\n            "num_workers": 8\n         }\n      }\n   ]\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This configuration consumes the Redis Stream and also enables insecure WebSocket connections, which is handy for tutorial purposes \u2013 so we don't need to think about client authentication and channel permissions here."}),"\n",(0,a.jsx)(n.p,{children:"Another important thing here is that enabling channel history is required for version logic to work because Centrifugo keeps version data in the history meta information."}),"\n",(0,a.jsx)(n.h2,{id:"creating-the-frontend-react-application",children:"Creating the Frontend React Application"}),"\n",(0,a.jsx)(n.p,{children:"Initialize a new React application:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"npx create-react-app web\n"})}),"\n",(0,a.jsx)(n.p,{children:"Navigate to the web directory and install the dependencies:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cd web\nnpm install centrifuge motion bootstrap\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Update ",(0,a.jsx)(n.code,{children:"web/src/App.js"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'import React, { useState, useEffect } from \'react\';\nimport { motion } from \'motion/react\';\nimport { Centrifuge } from \'centrifuge\';\nimport \'bootstrap/dist/css/bootstrap.min.css\';\nimport \'./App.css\';\n\nfunction App() {\n  const [state, setState] = useState({\n    leaders: [],\n    prevOrder: {},\n    highlights: {},\n  });\n\n  useEffect(() => {\n    const centrifuge = new Centrifuge("ws://localhost:8000/connection/websocket");\n    const sub = centrifuge.newSubscription("leaderboard", {});\n\n    sub.on(\'publication\', (message) => {\n      const data = message.data;\n\n      setState(prevState => {\n        const newHighlights = {};\n        const newLeaders = data.leaders.map((leader, index) => {\n          let highlightClass = "";\n          const prevRank = prevState.prevOrder[leader.name];\n          if (prevRank !== undefined) {\n            if (prevRank > index) {\n              highlightClass = "highlight-up";\n            } else if (prevRank < index) {\n              highlightClass = "highlight-down";\n            }\n          }\n          if (highlightClass) {\n            newHighlights[leader.name] = highlightClass;\n          }\n          return leader;\n        });\n\n        const newOrder = {};\n        newLeaders.forEach((leader, index) => {\n          newOrder[leader.name] = index;\n        });\n\n        return {\n          ...prevState,\n          leaders: newLeaders,\n          prevOrder: newOrder,\n          highlights: { ...prevState.highlights, ...newHighlights },\n        };\n      });\n    });\n\n    centrifuge.connect();\n    sub.subscribe();\n\n    return () => {\n      sub.unsubscribe();\n      centrifuge.disconnect();\n    };\n  }, []);\n\n  return (\n    <div className="container mt-5">\n      <div className="card">\n        <div className="card-header">Real-time Leaderboard with Centrifugo</div>\n        <div className="card-body">\n          <table className="table table-striped">\n            <thead>\n              <tr>\n                <th scope="col" className="rank-col">Rank</th>\n                <th scope="col">Name</th>\n                <th scope="col">Score</th>\n              </tr>\n            </thead>\n            <tbody>\n              {state.leaders.map((leader, index) => (\n                <motion.tr\n                  key={leader.name}\n                  layout\n                  className={state.highlights[leader.name] || \'\'}\n                >\n                  <td className="rank-col">{index + 1}</td>\n                  <td>{leader.name}</td>\n                  <td>{leader.score}</td>\n                </motion.tr>\n              ))}\n            </tbody>\n          </table>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n'})}),"\n",(0,a.jsx)(n.p,{children:"This React component:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Connects to Centrifugo via WebSocket"}),"\n",(0,a.jsx)(n.li,{children:'Subscribes to the "leaderboard" channel'}),"\n",(0,a.jsx)(n.li,{children:"Updates the UI when new leaderboard data is received"}),"\n",(0,a.jsxs)(n.li,{children:["Uses ",(0,a.jsx)(n.code,{children:"motion"})," animations to highlight changes in rankings"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["File ",(0,a.jsx)(n.code,{children:"web/src/App.css"})," has some CSS styles to make it look better. Here we skip it for brevity."]}),"\n",(0,a.jsx)(n.h2,{id:"configuring-nginx",children:"Configuring Nginx"}),"\n",(0,a.jsx)(n.p,{children:"Finally, let's add Nginx, which is useful to have a single app endpoint that proxies requests to the React frontend and Centrifugo WebSocket connection:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-nginx",children:'server {\n    listen 80;\n    server_name localhost;\n\n    location / {\n        proxy_pass http://web:3000;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection "upgrade";\n        proxy_set_header Host $host;\n    }\n    \n    location /connection/websocket {\n        proxy_pass http://centrifugo:8000;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection "upgrade";\n        proxy_set_header Host $host;\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"running-the-application",children:"Running the Application"}),"\n",(0,a.jsx)(n.p,{children:"Now that we have all the components set up, let's run the application:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"docker compose up\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Once everything is running, you can access the application at ",(0,a.jsx)(n.a,{href:"http://localhost:8080",children:"http://localhost:8080"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"adding-fossil-delta-compression",children:"Adding Fossil delta compression"}),"\n",(0,a.jsxs)(n.p,{children:["We are sending the full state in every publication now, but only part of the data changes. Centrifugo provides a ",(0,a.jsx)(n.a,{href:"/docs/server/delta_compression",children:"Fossil delta compression algorithm"})," which can be used to reduce the amount of data sent over the network."]}),"\n",(0,a.jsx)(n.p,{children:"First, let's look at how our WebSocket session looks now by opening the WebSocket tab in Chrome Dev Tools (right-click and open the image in a new tab to see better):"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(84673).A+"",width:"3016",height:"768"})}),"\n",(0,a.jsx)(n.p,{children:"We see the full content is being sent in every message."}),"\n",(0,a.jsx)(n.p,{children:"Let's add Fossil delta compression. To do this, we need to modify the client-side subscription:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const sub = centrifuge.newSubscription(\"leaderboard\", {\n  delta: 'fossil',\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:"And extend Centrifugo config:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n   ...\n   "channel": {\n      "without_namespace": {\n        ...\n        "allowed_delta_types": ["fossil"],\n        "delta_publish": true\n      }\n   },\n   ...\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Reload the app, and see how WebSocket frames look now:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(84089).A+"",width:"3016",height:"758"})}),"\n",(0,a.jsx)(n.p,{children:"Instead of full payloads, we see deltas with much smaller data size (x2 reduction), and the Centrifugo SDK automatically applies deltas correctly under the hood, so no other changes to the application code are required."}),"\n",(0,a.jsx)(n.h2,{id:"adding-cache-recovery-mode",children:"Adding cache recovery mode"}),"\n",(0,a.jsx)(n.p,{children:"Leaderboard data is also a good candidate for Centrifugo cache recovery mode feature. We can instantly and automatically load the latest publication known data upon subscription from Centrifugo stream history."}),"\n",(0,a.jsx)(n.p,{children:"To do this, we need history to be enabled (we already have) and add a couple of extra options to the configuration:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'{\n   ...\n   "channel": {\n      "without_namespace": {\n          ...\n          "force_recovery": true, \n          "force_recovery_mode": "cache"\n      }\n   },\n   ...\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["And one more option (",(0,a.jsx)(n.code,{children:"since"})," object) to the client-side subscription to trigger recovery upon the initial subscription:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const sub = centrifuge.newSubscription(\"leaderboard\", {\n  delta: 'fossil',\n  since: {}\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:"After making this, the latest leaderboard data will be immediately displayed to the user upon subscription without the need for extra synchronization of initial state loading and real-time updates."}),"\n",(0,a.jsx)(n.p,{children:"This is how it looks from the WebSocket frame perspective:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(51271).A+"",width:"3022",height:"1006"})}),"\n",(0,a.jsx)(n.p,{children:"I.e., we see that the initial data was sent within the subscribe response. And it's in JSON string format here because we are using delta compression. If we disable delta compression, we will see the initial data just as a regular JSON object."}),"\n",(0,a.jsx)(n.h2,{id:"other-possible-improvements",children:"Other possible improvements"}),"\n",(0,a.jsx)(n.p,{children:"With Centrifugo, only with a little extra effort you can:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Add authentication to the WebSocket connection"}),"\n",(0,a.jsx)(n.li,{children:"Use Centrifugo built-in channel permissions to restrict access to channels"}),"\n",(0,a.jsx)(n.li,{children:"Use Centrifugo built-in online presence feature to show who is online"}),"\n",(0,a.jsx)(n.li,{children:"Use binary protocol to reduce the amount of data sent over the network and improve serialization performance"}),"\n",(0,a.jsx)(n.li,{children:"Provide WebSocket fallbacks based on Server-Sent Events (SSE) or HTTP-streaming"}),"\n",(0,a.jsxs)(n.li,{children:["Scale Centrifugo nodes to handle ",(0,a.jsx)(n.a,{href:"/blog/2020/02/10/million-connections-with-centrifugo",children:"millions of connections"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"In this tutorial, we've built a real-time leaderboard application using Centrifugo, Redis, and React. This demonstrates how Centrifugo can be used to create interactive, real-time applications with minimal effort."}),"\n",(0,a.jsx)(n.p,{children:"By leveraging the real-time capabilities of Centrifugo, you can create engaging, interactive applications that provide users with immediate feedback and updates."}),"\n",(0,a.jsx)(n.p,{children:"Moreover, Centrifugo comes with many optimizations to make it the most effective solution for real-time applications. For example, it may use Fossil delta compression to reduce the amount of data sent over the network, and it has a cache recovery mode to ensure that clients can recover from network interruptions without losing updates."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},51271:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/leaderboard_cache-e1b4526260ca0f8d720d2be958e67589.jpg"},72859:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025/04/28/websocket-real-time-leaderboard","editUrl":"https://github.com/centrifugal/centrifugal.dev/edit/main/blog/2025-04-28-websocket-real-time-leaderboard.md","source":"@site/blog/2025-04-28-websocket-real-time-leaderboard.md","title":"Building a real-time WebSocket leaderboard with Centrifugo and Redis","description":"In this article, we create a real-time leaderboard using Centrifugo, Redis, React and Python. Here we show the usage of Centrifugo built-in asynchronous consumer from Redis Stream. The post additionally showcases Fossil delta compression and cache recovery mode.","date":"2025-04-28T00:00:00.000Z","tags":[{"inline":true,"label":"centrifugo","permalink":"/blog/tags/centrifugo"},{"inline":true,"label":"redis","permalink":"/blog/tags/redis"},{"inline":true,"label":"react","permalink":"/blog/tags/react"},{"inline":true,"label":"python","permalink":"/blog/tags/python"},{"inline":true,"label":"tutorial","permalink":"/blog/tags/tutorial"}],"readingTime":11.605,"hasTruncateMarker":true,"authors":[{"name":"Alexander Emelin","title":"Founder of Centrifugal Labs","imageURL":"/img/alexander_emelin.jpeg","key":null,"page":null}],"frontMatter":{"title":"Building a real-time WebSocket leaderboard with Centrifugo and Redis","tags":["centrifugo","redis","react","python","tutorial"],"description":"In this article, we create a real-time leaderboard using Centrifugo, Redis, React and Python. Here we show the usage of Centrifugo built-in asynchronous consumer from Redis Stream. The post additionally showcases Fossil delta compression and cache recovery mode.","author":"Alexander Emelin","authorTitle":"Founder of Centrifugal Labs","authorImageURL":"/img/alexander_emelin.jpeg","image":"/img/leaderboard.jpg","hide_table_of_contents":false},"unlisted":false,"nextItem":{"title":"Centrifugo v6 released","permalink":"/blog/2025/01/16/centrifugo-v6-released"}}')},84089:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/leaderboard_fossil-513777bd2e4dd25c05e8f14f0af0ca91.jpg"},84673:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/leaderboard_no_fossil-ee21b6ed584231de38d4e90080d2e2e3.jpg"}}]);