"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[9650],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>t});var s=i(96540);const c={},o=s.createContext(c);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:a(e.components),s.createElement(o.Provider,{value:n},e.children)}},76510:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>r});const s=JSON.parse('{"id":"pro/capabilities","title":"Channel capabilities","description":"At this point you know that Centrifugo allows configuring channel permissions on a per-namespace level. When creating a new real-time feature it\'s recommended to create a new namespace for it and configure permissions. To achieve a better channel permission control inside a namespace Centrifugo PRO provides possibility to set capabilities on individual connection basis, or individual channel subscription basis.","source":"@site/versioned_docs/version-5/pro/capabilities.md","sourceDirName":"pro","slug":"/pro/capabilities","permalink":"/docs/5/pro/capabilities","draft":false,"unlisted":false,"editUrl":"https://github.com/centrifugal/centrifugal.dev/edit/main/versioned_docs/version-5/pro/capabilities.md","tags":[],"version":"5","frontMatter":{"id":"capabilities","title":"Channel capabilities"},"sidebar":"Pro","previous":{"title":"Cache empty events","permalink":"/docs/5/pro/channel_cache_empty"},"next":{"title":"Channel patterns","permalink":"/docs/5/pro/channel_patterns"}}');var c=i(74848),o=i(28453);const a={id:"capabilities",title:"Channel capabilities"},t=void 0,l={},r=[{value:"Connection capabilities",id:"connection-capabilities",level:2},{value:"Caps processing behavior",id:"caps-processing-behavior",level:3},{value:"Expiration considirations",id:"expiration-considirations",level:3},{value:"Revoking connection caps",id:"revoking-connection-caps",level:3},{value:"Example: wildcard match",id:"example-wildcard-match",level:3},{value:"Example: regex match",id:"example-regex-match",level:3},{value:"Example: different types of match",id:"example-different-types-of-match",level:3},{value:"Example: full access to all channels",id:"example-full-access-to-all-channels",level:3},{value:"Subscription capabilities",id:"subscription-capabilities",level:2},{value:"Expiration considirations",id:"expiration-considirations-1",level:3},{value:"Revoking subscription permissions",id:"revoking-subscription-permissions",level:3}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.p,{children:"At this point you know that Centrifugo allows configuring channel permissions on a per-namespace level. When creating a new real-time feature it's recommended to create a new namespace for it and configure permissions. To achieve a better channel permission control inside a namespace Centrifugo PRO provides possibility to set capabilities on individual connection basis, or individual channel subscription basis."}),"\n",(0,c.jsx)(n.p,{children:"Let's start by looking at connection-wide capabilities first."}),"\n",(0,c.jsx)(n.h2,{id:"connection-capabilities",children:"Connection capabilities"}),"\n",(0,c.jsx)(n.p,{children:"Connection capabilities can be set:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["in connection JWT (in ",(0,c.jsx)(n.code,{children:"caps"})," claim)"]}),"\n",(0,c.jsxs)(n.li,{children:["in connect proxy result (",(0,c.jsx)(n.code,{children:"caps"})," field)"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["For example, here we are issuing permissions to subscribe on channel ",(0,c.jsx)(n.code,{children:"news"})," and channel ",(0,c.jsx)(n.code,{children:"user_42"})," to a client:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",children:'{\n    "caps": [\n        {\n            "channels": ["news", "user_42"],\n            "allow": ["sub"]\n        }\n    ]\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"Known capabilities:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"sub"})," - subscribe to a channel to receive publications from it"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"pub"})," - publish into a channel (your backend won't be able to process the publication in this case)"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"prs"})," - call presence and presence stats API, also consume join/leave events upon subscribing"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"hst"})," - call history API, also make Subscription positioned or recoverable upon subscribing"]}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"caps-processing-behavior",children:"Caps processing behavior"}),"\n",(0,c.jsxs)(n.p,{children:["Centrifugo processes caps objects till it finds a match to a channel. At this point it applies permissions in the matched object and stops processing remaining caps. If no match found \u2013 then ",(0,c.jsx)(n.code,{children:"103 permission denied"})," returned to a client (of course if namespace does not have other permission-related options enabled). Let's consider example like this:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",metastring:'title="WRONG!"',children:'{\n    "caps": [\n        {\n            "channels": ["news"],\n            "allow": ["pub"]\n        },\n        {\n            "channels": ["news"],\n            "allow": ["sub"]\n        },\n    ]\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["Here we have two entries for channel ",(0,c.jsx)(n.code,{children:"news"}),", but when client subscribes on ",(0,c.jsx)(n.code,{children:"news"})," only the first entry will be taken into considiration by Centrifugo \u2013 so Subscription attempt will be rejected (since first cap object does not have ",(0,c.jsx)(n.code,{children:"sub"})," capability). In real life you don't really want to have cap objects with identical channels \u2013 but below we will introduce wildcard matching where understanding how caps processed becomes important."]}),"\n",(0,c.jsx)(n.p,{children:"Another example:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",metastring:'title="WRONG!"',children:'{\n    "caps": [\n        {\n            "channels": ["news", "user_42"],\n            "allow": ["sub"]\n        },\n        {\n            "channels": ["user_42"],\n            "allow": ["pub", "hst", "prs"]\n        },\n    ]\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["One could expect that client will have ",(0,c.jsx)(n.code,{children:'["sub", "pub", "hst", "prs"]'})," capabilities for a channel ",(0,c.jsx)(n.code,{children:"user_42"}),". But it's not true since Centrifugo processes caps objects and channels inside caps object in order \u2013 it finds a match to ",(0,c.jsx)(n.code,{children:"user_42"})," in first caps object, it contains only ",(0,c.jsx)(n.code,{children:'"sub"'})," capability, processing stops. So user can subscribe to a channel, but can not publish, can not call history and presence APIs even though those capabilities are mentioned in ",(0,c.jsx)(n.code,{children:"caps"})," object. The correct way to give all caps to the channel ",(0,c.jsx)(n.code,{children:"user_42"})," would be to split channels into different caps objects:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",metastring:'title="CORRECT"',children:'{\n    "caps": [\n        {\n            "channels": ["news"],\n            "allow": ["sub"]\n        },\n        {\n            "channels": ["user_42"],\n            "allow": ["sub", "pub", "hst", "prs"]\n        },\n    ]\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"The processing behaves like this to avoid potential problems with possibly conflicting matches (mostly when using wildcard and regex matching \u2013 see below) and still allow overriding capabilities for specific channels."}),"\n",(0,c.jsx)(n.h3,{id:"expiration-considirations",children:"Expiration considirations"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"In JWT auth case \u2013 capabilities in JWT will work till token expiration, that's why it's important to keep reasonably small token expiration times. We can recommend using sth like 5-10 mins as a good expiration value, but of course this is application specific."}),"\n",(0,c.jsx)(n.li,{children:"In connect proxy case \u2013 capabilities will work until client connection close (disconnect) or connection refresh triggered (with refresh proxy you can provide an updated set of capabilities)."}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"revoking-connection-caps",children:"Revoking connection caps"}),"\n",(0,c.jsx)(n.p,{children:"If at some point you need to revoke some capability from a client:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["Simplest way is to wait for a connection expiration, then upon refresh:","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["if using proxy \u2013 provide new caps in refresh proxy result, Centrifugo will update caps and unsubscribe a client from channels it does not have permissions anymore (",(0,c.jsx)(n.strong,{children:"only those obtained due to previous connection-wide capabilities"}),")."]}),"\n",(0,c.jsxs)(n.li,{children:["if JWT auth - provide new caps in connection token, Centrifugo will update caps and unsubscribe a client from channels it does not have permissions anymore (",(0,c.jsx)(n.strong,{children:"only those obtained due to previous connection-wide capabilities"}),")."]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.li,{children:"In case of using connect proxy \u2013 you can disconnect a user (or client) with a reconnect code. New capabilities will be asked upon reconnection."}),"\n",(0,c.jsx)(n.li,{children:"In case of using token auth \u2013 revoke token (Centrifugo PRO feature) and disconnect user (or client) with reconnect code. Upon reconnection user will receive an error that token revoked and will try to load a new one."}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"example-wildcard-match",children:"Example: wildcard match"}),"\n",(0,c.jsxs)(n.p,{children:["It's possible to use wildcards in channel resource names. For example, let's give a permission to subscribe on all channels in ",(0,c.jsx)(n.code,{children:"news"})," namespace."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",children:'{\n    "caps": [\n        {\n            "channels": ["news:*"],\n            "match": "wildcard",\n            "allow": ["sub"]\n        }\n    ]\n}\n'})}),"\n",(0,c.jsx)(n.admonition,{type:"note",children:(0,c.jsxs)(n.p,{children:["Match type is used for all ",(0,c.jsx)(n.code,{children:"channels"})," in caps object. If you need different matching behavior for different channels then split them on different caps objects."]})}),"\n",(0,c.jsx)(n.h3,{id:"example-regex-match",children:"Example: regex match"}),"\n",(0,c.jsx)(n.p,{children:"Or regex:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",children:'{\n    "caps": [\n        {\n            "channels": ["^posts_[\\d]+$"],\n            "match": "regex",\n            "allow": ["sub"]\n        }\n    ]\n}\n'})}),"\n",(0,c.jsx)(n.h3,{id:"example-different-types-of-match",children:"Example: different types of match"}),"\n",(0,c.jsxs)(n.p,{children:["Of course it's possible to combine different types of match inside one ",(0,c.jsx)(n.code,{children:"caps"})," array:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",children:'{\n    "caps": [\n        {\n            "channels": ["^posts_[\\d]+$"],\n            "match": "regex",\n            "allow": ["sub"]\n        }\n        {\n            "channels": ["user_42"],\n            "allow": ["sub"]\n        }\n    ]\n}\n'})}),"\n",(0,c.jsx)(n.h3,{id:"example-full-access-to-all-channels",children:"Example: full access to all channels"}),"\n",(0,c.jsx)(n.p,{children:"Let's look how to allow all permissions to a client:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",children:'{\n    "caps": [\n        {\n            "channels": ["*"],\n            "match": "wildcard",\n            "allow": ["sub", "pub", "hst", "prs"]\n        }\n    ]\n}\n'})}),"\n",(0,c.jsx)(n.admonition,{title:"Full access warn",type:"danger",children:(0,c.jsx)(n.p,{children:"Should we mention that giving full access to a client is something to wisely consider? \ud83e\udd14"})}),"\n",(0,c.jsx)(n.h2,{id:"subscription-capabilities",children:"Subscription capabilities"}),"\n",(0,c.jsx)(n.p,{children:"Subscription capabilities can be set:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["in subscription JWT (in ",(0,c.jsx)(n.code,{children:"allow"})," claim)"]}),"\n",(0,c.jsxs)(n.li,{children:["in subscribe proxy result (",(0,c.jsx)(n.code,{children:"allow"})," field)"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["Subscription token already belongs to a channel (it has a ",(0,c.jsx)(n.code,{children:"channel"})," claim). So users with a valid subscription token can subscribe to a channel. But it's possible to additionally grant channel permissions to a user for publishing and calling presence and history using ",(0,c.jsx)(n.code,{children:"allow"})," claim:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",children:'{\n    "allow": ["pub", "hst", "prs"]\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["Putting ",(0,c.jsx)(n.code,{children:"sub"})," permission to the Subscription token does not make much sense \u2013 Centrifugo only expects valid token for a subscription permission check."]}),"\n",(0,c.jsx)(n.h3,{id:"expiration-considirations-1",children:"Expiration considirations"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"In JWT auth case \u2013 capabilities in subscription JWT will work till token expiration, that's why it's important to keep reasonably small token expiration times. We can recommend using sth like 5-10 mins as a good expiration value, but of course this is application specific."}),"\n",(0,c.jsx)(n.li,{children:"In subscribe proxy case \u2013 capabilities will work until client unsubscribe (or connection close)."}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"revoking-subscription-permissions",children:"Revoking subscription permissions"}),"\n",(0,c.jsx)(n.p,{children:"If at some point you need to revoke some capability from a client:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["Simplest way is to wait for a subscription expiration, then upon refresh:","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"provide new caps in subscription token, Centrifugo will update channel caps."}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.li,{children:"In case of using subscribe proxy \u2013 you can unsubscribe a user (or client) with a resubscribe code. Or disconnect with reconnect code. New capabilities will be set up upon resubscription/reconnection."}),"\n",(0,c.jsx)(n.li,{children:"In case of using JWT auth \u2013 revoke token (Centrifugo PRO feature) and unsubscribe/disconnect user (or client) with resubscribe/reconnect code. Upon resubscription/reconnection user will receive an error that token revoked and will try to load a new one."}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}}}]);