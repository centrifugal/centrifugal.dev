"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"v5","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"Introduction":[{"type":"link","label":"Centrifugo introduction","href":"/docs/getting-started/introduction","docId":"getting-started/introduction"},{"type":"link","label":"Join community","href":"/docs/getting-started/community","docId":"getting-started/community"},{"type":"link","label":"Install Centrifugo","href":"/docs/getting-started/installation","docId":"getting-started/installation"},{"type":"link","label":"Quickstart tutorial","href":"/docs/getting-started/quickstart","docId":"getting-started/quickstart"},{"type":"link","label":"Main highlights","href":"/docs/getting-started/highlights","docId":"getting-started/highlights"},{"type":"link","label":"Integration guide","href":"/docs/getting-started/integration","docId":"getting-started/integration"},{"type":"link","label":"Design overview","href":"/docs/getting-started/design","docId":"getting-started/design"},{"type":"link","label":"Ecosystem notes","href":"/docs/getting-started/ecosystem","docId":"getting-started/ecosystem"},{"type":"link","label":"Comparing with others","href":"/docs/getting-started/comparisons","docId":"getting-started/comparisons"},{"type":"link","label":"Migrating to v5","href":"/docs/getting-started/migration_v5","docId":"getting-started/migration_v5"}],"Tutorial":[{"type":"link","label":"Real-time app from scratch","href":"/docs/tutorial/intro","docId":"tutorial/intro"},{"type":"link","label":"App layout and behavior","href":"/docs/tutorial/layout","docId":"tutorial/layout"},{"type":"link","label":"Setting up backend and database","href":"/docs/tutorial/backend","docId":"tutorial/backend"},{"type":"link","label":"Adding reverse proxy","href":"/docs/tutorial/reverse_proxy","docId":"tutorial/reverse_proxy"},{"type":"link","label":"Creating SPA frontend","href":"/docs/tutorial/frontend","docId":"tutorial/frontend"},{"type":"link","label":"Integrating Centrifugo","href":"/docs/tutorial/centrifugo","docId":"tutorial/centrifugo"},{"type":"link","label":"Missed messages recovery","href":"/docs/tutorial/recovery","docId":"tutorial/recovery"},{"type":"link","label":"Broadcast: outbox and CDC","href":"/docs/tutorial/outbox_cdc","docId":"tutorial/outbox_cdc"},{"type":"link","label":"Scale to 100k room members","href":"/docs/tutorial/scale","docId":"tutorial/scale"},{"type":"link","label":"Wrapping up \u2013 things learnt","href":"/docs/tutorial/outro","docId":"tutorial/outro"},{"type":"link","label":"Appx #1: possible improvements","href":"/docs/tutorial/improvements","docId":"tutorial/improvements"},{"type":"link","label":"Appx #2: tips and tricks","href":"/docs/tutorial/tips_and_tricks","docId":"tutorial/tips_and_tricks"}],"Guides":[{"type":"link","label":"Configure Centrifugo","href":"/docs/server/configuration","docId":"server/configuration"},{"type":"link","label":"Server API walkthrough","href":"/docs/server/server_api","docId":"server/server_api"},{"type":"link","label":"Client JWT authentication","href":"/docs/server/authentication","docId":"server/authentication"},{"type":"link","label":"Channels and namespaces","href":"/docs/server/channels","docId":"server/channels"},{"type":"link","label":"Channel permission model","href":"/docs/server/channel_permissions","docId":"server/channel_permissions"},{"type":"link","label":"Channel JWT authorization","href":"/docs/server/channel_token_auth","docId":"server/channel_token_auth"},{"type":"link","label":"Server-side subscriptions","href":"/docs/server/server_subs","docId":"server/server_subs"},{"type":"link","label":"Engines and scalability","href":"/docs/server/engines","docId":"server/engines"},{"type":"link","label":"Async consumers","href":"/docs/server/consumers","docId":"server/consumers"},{"type":"link","label":"History and recovery","href":"/docs/server/history_and_recovery","docId":"server/history_and_recovery"},{"type":"link","label":"Online presence","href":"/docs/server/presence","docId":"server/presence"},{"type":"link","label":"Proxy events to the backend","href":"/docs/server/proxy","docId":"server/proxy"},{"type":"link","label":"Proxy subscription streams","href":"/docs/server/proxy_streams","docId":"server/proxy_streams"},{"type":"link","label":"Admin web UI","href":"/docs/server/admin_web","docId":"server/admin_web"},{"type":"link","label":"Server observability","href":"/docs/server/observability","docId":"server/observability"},{"type":"link","label":"Infrastructure tuning","href":"/docs/server/infra_tuning","docId":"server/infra_tuning"},{"type":"link","label":"Load balancing","href":"/docs/server/load_balancing","docId":"server/load_balancing"},{"type":"link","label":"Configure TLS","href":"/docs/server/tls","docId":"server/tls"},{"type":"link","label":"Error and disconnect codes","href":"/docs/server/codes","docId":"server/codes"},{"type":"link","label":"Helper CLI commands","href":"/docs/server/console_commands","docId":"server/console_commands"}],"Transports":[{"type":"link","label":"Real-time transports","href":"/docs/transports/overview","docId":"transports/overview"},{"type":"category","label":"Bidirectional","collapsed":false,"items":[{"type":"link","label":"Client SDK API","href":"/docs/transports/client_api","docId":"transports/client_api"},{"type":"link","label":"Client real-time SDKs","href":"/docs/transports/client_sdk","docId":"transports/client_sdk"},{"type":"link","label":"WebSocket","href":"/docs/transports/websocket","docId":"transports/websocket"},{"type":"link","label":"HTTP streaming","href":"/docs/transports/http_stream","docId":"transports/http_stream"},{"type":"link","label":"SSE (EventSource)","href":"/docs/transports/sse","docId":"transports/sse"},{"type":"link","label":"SockJS","href":"/docs/transports/sockjs","docId":"transports/sockjs"},{"type":"link","label":"WebTransport","href":"/docs/transports/webtransport","docId":"transports/webtransport"},{"type":"link","label":"Client protocol","href":"/docs/transports/client_protocol","docId":"transports/client_protocol"}],"collapsible":true},{"type":"category","label":"Unidirectional","collapsed":false,"items":[{"type":"link","label":"Unidirectional protocol","href":"/docs/transports/uni_client_protocol","docId":"transports/uni_client_protocol"},{"type":"link","label":"WebSocket","href":"/docs/transports/uni_websocket","docId":"transports/uni_websocket"},{"type":"link","label":"HTTP streaming","href":"/docs/transports/uni_http_stream","docId":"transports/uni_http_stream"},{"type":"link","label":"SSE (EventSource)","href":"/docs/transports/uni_sse","docId":"transports/uni_sse"},{"type":"link","label":"GRPC","href":"/docs/transports/uni_grpc","docId":"transports/uni_grpc"}],"collapsible":true}],"Pro":[{"type":"link","label":"Centrifugo PRO","href":"/docs/pro/overview","docId":"pro/overview"},{"type":"link","label":"Install and run PRO version","href":"/docs/pro/install_and_run","docId":"pro/install_and_run"},{"type":"category","label":"PRO version features","collapsed":false,"items":[{"type":"link","label":"User and channel tracing","href":"/docs/pro/tracing","docId":"pro/tracing"},{"type":"link","label":"Analytics with ClickHouse","href":"/docs/pro/analytics","docId":"pro/analytics"},{"type":"link","label":"Operation rate limits","href":"/docs/pro/rate_limiting","docId":"pro/rate_limiting"},{"type":"link","label":"Push notification API","href":"/docs/pro/push_notifications","docId":"pro/push_notifications"},{"type":"link","label":"User status API","href":"/docs/pro/user_status","docId":"pro/user_status"},{"type":"link","label":"Connections API","href":"/docs/pro/connections","docId":"pro/connections"},{"type":"link","label":"User blocking API","href":"/docs/pro/user_block","docId":"pro/user_block"},{"type":"link","label":"Token revocation API","href":"/docs/pro/token_revocation","docId":"pro/token_revocation"},{"type":"link","label":"Channel state events","href":"/docs/pro/channel_state_events","docId":"pro/channel_state_events"},{"type":"link","label":"Channel capabilities","href":"/docs/pro/capabilities","docId":"pro/capabilities"},{"type":"link","label":"Channel patterns","href":"/docs/pro/channel_patterns","docId":"pro/channel_patterns"},{"type":"link","label":"CEL expressions","href":"/docs/pro/cel_expressions","docId":"pro/cel_expressions"},{"type":"link","label":"Faster performance","href":"/docs/pro/performance","docId":"pro/performance"},{"type":"link","label":"Singleflight","href":"/docs/pro/singleflight","docId":"pro/singleflight"},{"type":"link","label":"Message batching control","href":"/docs/pro/client_message_batching","docId":"pro/client_message_batching"},{"type":"link","label":"Observability enhancements","href":"/docs/pro/observability_enhancements","docId":"pro/observability_enhancements"},{"type":"link","label":"CPU and RSS stats","href":"/docs/pro/process_stats","docId":"pro/process_stats"}],"collapsible":true}]},"docs":{"attributions":{"id":"attributions","title":"Attributions","description":"Landing Page Images"},"faq/faq_index":{"id":"faq/faq_index","title":"Frequently Asked Questions","description":"Answers to popular questions here."},"flow_diagrams":{"id":"flow_diagrams","title":"flow_diagrams","description":"For swimlanes.io:"},"getting-started/client_api":{"id":"getting-started/client_api","title":"Client API showcase","description":"This chapter showcases the capabilities of Centrifugo\'s bidirectional client API \u2013 i.e., the real-time messaging primitives available on the front end (which can be a browser or a mobile device)."},"getting-started/community":{"id":"getting-started/community","title":"Join community","description":"If you find Centrifugo interesting, you are welcome to join our community rooms on Telegram (the most active) and Discord:","sidebar":"Introduction"},"getting-started/comparisons":{"id":"getting-started/comparisons","title":"Comparing with others","description":"Let\'s compare Centrifugo with various systems. These comparisons arose from popular questions raised in our communities. Here we are emphasizing things that make Centrifugo special.","sidebar":"Introduction"},"getting-started/design":{"id":"getting-started/design","title":"Design overview","description":"Let\'s discuss some architectural and design topics about Centrifugo.","sidebar":"Introduction"},"getting-started/ecosystem":{"id":"getting-started/ecosystem","title":"Ecosystem notes","description":"Some additional notes about our ecosystem which may help you develop with our tech.","sidebar":"Introduction"},"getting-started/highlights":{"id":"getting-started/highlights","title":"Main highlights","description":"At this point, you know how to build the simplest real-time app with Centrifugo. Beyond the core PUB/SUB functionality, Centrifugo provides more features and primitives to build scalable real-time applications. Let\'s summarize the main Centrifugo \u2728highlights\u2728 here. Every point is then extended throughout the documentation.","sidebar":"Introduction"},"getting-started/installation":{"id":"getting-started/installation","title":"Install Centrifugo","description":"Centrifugo server is written in the Go language. It\'s open-source software, and the source code is available on Github.","sidebar":"Introduction"},"getting-started/integration":{"id":"getting-started/integration","title":"Integration guide","description":"This chapter aims to help you get started with Centrifugo. We will look at a step-by-step workflow of integrating your application with Centrifugo, providing links to relevant parts of this documentation.","sidebar":"Introduction"},"getting-started/introduction":{"id":"getting-started/introduction","title":"Centrifugo introduction","description":"Centrifugo is an open-source scalable real-time messaging server. Centrifugo can instantly deliver messages to application online users connected over supported transports (WebSocket, HTTP-streaming, SSE/EventSource, WebTransport, GRPC, SockJS). Centrifugo has the concept of a channel \u2013 so it\'s a user-facing PUB/SUB server.","sidebar":"Introduction"},"getting-started/migration_v4":{"id":"getting-started/migration_v4","title":"Migrating to v4","description":"Centrifugo v4 development was concentrated around two main things:"},"getting-started/migration_v5":{"id":"getting-started/migration_v5","title":"Migrating to v5","description":"Centrifugo v5 migration from v4 should be smooth for most of the use cases.","sidebar":"Introduction"},"getting-started/quickstart":{"id":"getting-started/quickstart","title":"Quickstart tutorial \u23f1\ufe0f","description":"In this tutorial, we will build a very simple browser application with Centrifugo. Users will connect to Centrifugo over WebSocket, subscribe to a channel, and start receiving all channel publications (messages published to that channel). In our case, we will send a counter value to all channel subscribers to update the counter widget in all open browser tabs in real-time.","sidebar":"Introduction"},"pro/analytics":{"id":"pro/analytics","title":"Analytics with ClickHouse","description":"This feature allows exporting information about channel publications, client connections, channel subscriptions,  client operations and push notifications to ClickHouse thus providing an integration with a real-time (with seconds delay) analytics storage. ClickHouse is super fast for analytical queries, simple to operate with and it allows effective data keeping for a window of time. Also, it\'s relatively simple to create a high performance ClickHouse cluster.","sidebar":"Pro"},"pro/capabilities":{"id":"pro/capabilities","title":"Channel capabilities","description":"At this point you know that Centrifugo allows configuring channel permissions on a per-namespace level. When creating a new real-time feature it\'s recommended to create a new namespace for it and configure permissions. To achieve a better channel permission control inside a namespace Centrifugo PRO provides possibility to set capabilities on individual connection basis, or individual channel subscription basis.","sidebar":"Pro"},"pro/cel_expressions":{"id":"pro/cel_expressions","title":"CEL expressions","description":"Centrifugo PRO supports CEL expressions (Common Expression Language) for checking channel operation permissions.","sidebar":"Pro"},"pro/channel_patterns":{"id":"pro/channel_patterns","title":"Channel patterns","description":"Centrifugo PRO enhances a way to configure channels with Channel Patterns feature. This opens a road for building channel model similar to what developers got used to when writing HTTP servers and configuring routes for HTTP request processing.","sidebar":"Pro"},"pro/channel_state_events":{"id":"pro/channel_state_events","title":"Channel state events","description":"Centrifugo PRO has a feature to enable channel state event webhooks to be sent to your configured backend endpoint:","sidebar":"Pro"},"pro/client_message_batching":{"id":"pro/client_message_batching","title":"Message batching control","description":"Centrifugo PRO provides advanced options to tweak connection message write behaviour.","sidebar":"Pro"},"pro/connections":{"id":"pro/connections","title":"Connections API","description":"Centrifugo PRO offers an extra API call, connections, which enables retrieval of all active sessions (based on user ID or expression) without the need to activate the presence feature for channels. Furthermore, developers can attach any desired JSON payload to a connection that will then be visible in the result of the connections call. It\'s worth noting that this additional meta-information remains hidden from the client-side, unlike the info associated with the connection.","sidebar":"Pro"},"pro/distributed_rate_limit":{"id":"pro/distributed_rate_limit","title":"Distributed rate limit API","description":"In addition to connection operation rate limiting features Centrifugo PRO provides a generic high precision rate limiting API. It may be used for custom quota managing tasks not even related to real-time connections. Its distributed nature allows managing quotas across different instances of your application backend."},"pro/install_and_run":{"id":"pro/install_and_run","title":"Install and run PRO version","description":"Centrifugo PRO is distributed by Centrifugal Labs LTD under commercial license which is different from OSS version. By downloading Centrifugo PRO you automatically accept commercial license terms.","sidebar":"Pro"},"pro/observability_enhancements":{"id":"pro/observability_enhancements","title":"Observability enhancements","description":"Centrifugo PRO has some enhancements to exposed metrics. At this moment it provides channel namespace resolution to the following metrics:","sidebar":"Pro"},"pro/overview":{"id":"pro/overview","title":"Centrifugo PRO","description":"Centrifugo PRO is the enhanced version of Centrifugo provided by Centrifugal Labs LTD under commercial license. It\'s packed with a set of unique features that offer exceptional benefits to your business. It provides granular channel permission control, lower CPU utilization on Centrifugo nodes, backend protection from misusing, next level system observability, additional APIs (like push notifications), and more.","sidebar":"Pro"},"pro/performance":{"id":"pro/performance","title":"Faster performance","description":"Centrifugo PRO has performance improvements for several server parts. These improvements can help to reduce tail end-to-end latencies in the application, increase server throughput and/or reduce CPU usage on server machines. Our open-source version has a decent performance by itself, with PRO improvements Cenrifugo steps even further.","sidebar":"Pro"},"pro/process_stats":{"id":"pro/process_stats","title":"CPU and RSS stats","description":"A useful addition of Centrifugo PRO is an ability to show CPU and RSS memory usage of each node in admin web UI.","sidebar":"Pro"},"pro/push_notifications":{"id":"pro/push_notifications","title":"Push notification API","description":"Centrifugo excels in delivering real-time in-app messages to online users. Sometimes though you need a way to engage offline users to come back to your app. Or trigger some update in the app while it\'s running in the background. That\'s where push notifications may be used. Push notifications delivered over battery-efficient platform-dependent transport.","sidebar":"Pro"},"pro/rate_limiting":{"id":"pro/rate_limiting","title":"Operation rate limits","description":"The rate limit feature allows limiting the number of operations each connection or user can issue during a configured time interval. This is useful to protect the system from misusing, detecting and disconnecting abusive or broken (due to the bug in the frontend application) clients which add unwanted load on a server.","sidebar":"Pro"},"pro/singleflight":{"id":"pro/singleflight","title":"Singleflight","description":"Centrifugo PRO provides an additional boolean option use_singleflight (default false). When this option enabled Centrifugo will automatically try to merge identical requests to history, online presence or presence stats issued at the same time into one real network request. It will do this by using in-memory component called singleflight.","sidebar":"Pro"},"pro/token_revocation":{"id":"pro/token_revocation","title":"Token revocation API","description":"One more protective instrument in Centrifugo PRO is API to manage token revocations.","sidebar":"Pro"},"pro/tracing":{"id":"pro/tracing","title":"User and channel tracing","description":"That\'s a unique thing. The tracing feature of Centrifugo PRO allows attaching to any channel to see all messages flying towards subscribers or attach to a specific user ID to see all user-related events in real-time.","sidebar":"Pro"},"pro/user_block":{"id":"pro/user_block","title":"User blocking API","description":"One additional instrument for making protective actions in Centrifugo PRO is user blocking API which allows blocking a specific user on Centrifugo level.","sidebar":"Pro"},"pro/user_status":{"id":"pro/user_status","title":"User status API","description":"Centrifugo OSS provides a presence feature for channels. It works well (for channels with reasonably small number of active subscribers though), but sometimes you may need a bit different functionality.","sidebar":"Pro"},"server/admin_web":{"id":"server/admin_web","title":"Admin web UI","description":"Centrifugo comes with a built-in administrative web interface. It enables users to:","sidebar":"Guides"},"server/authentication":{"id":"server/authentication","title":"Client JWT authentication","description":"To authenticate an incoming connection (client), Centrifugo can use a JSON Web Token (JWT) provided by your application backend to the client-side. This allows Centrifugo to identify the user ID within your application in a secure way. Also, the application can pass additional data to Centrifugo inside JWT claims. This chapter explains this authentication mechanism.","sidebar":"Guides"},"server/channel_permissions":{"id":"server/channel_permissions","title":"Channel permission model","description":"When using Centrifugo server API you don\'t need to think about channel permissions at all \u2013 everything is allowed. In server API case, request to Centrifugo must be issued by your application backend \u2013 so you have all the power to check any required permissions before issuing API request to Centrifugo.","sidebar":"Guides"},"server/channel_token_auth":{"id":"server/channel_token_auth","title":"Channel JWT authorization","description":"In the chapter about channel permissions we mentioned that to subscribe on a channel client can provide subscription token. This chapter has more information about the subscription token mechanism in Centrifugo.","sidebar":"Guides"},"server/channels":{"id":"server/channels","title":"Channels and namespaces","description":"Upon connecting to a server, clients can subscribe to channels. A channel is one of the core concepts of Centrifugo. Most of the time when integrating Centrifugo, you will work with channels and determine the optimal channel configuration for your application.","sidebar":"Guides"},"server/codes":{"id":"server/codes","title":"Error and disconnect codes","description":"This chapter describes error and disconnect codes Centrifugo uses in a client protocol, also error codes which a server API can return in response.","sidebar":"Guides"},"server/configuration":{"id":"server/configuration","title":"Configure Centrifugo","description":"Let\'s look at how Centrifugo can be configured.","sidebar":"Guides"},"server/console_commands":{"id":"server/console_commands","title":"Helper CLI commands","description":"Here is a list of helpful command-line commands that come with Centrifugo executable.","sidebar":"Guides"},"server/consumers":{"id":"server/consumers","title":"Built-in API command async consumers","description":"In server API chapter we\'ve shown how to execute various Centrifugo server API commands (publish, broadcast, etc.) over HTTP or GRPC. In many cases you will call those APIs from your application business logic synchronously. But to deal with temporary network and availability issues, and achieve reliable execution of API commands upon changes in your primary application database you may want to use queuing techniques and call Centrifugo API asynchronously.","sidebar":"Guides"},"server/engines":{"id":"server/engines","title":"Engines and scalability","description":"The Engine in Centrifugo is responsible for publishing messages between nodes, handle PUB/SUB broker subscriptions, save/retrieve online presence and history data.","sidebar":"Guides"},"server/history_and_recovery":{"id":"server/history_and_recovery","title":"History and recovery","description":"Centrifugo engines can maintain publication history for channels with configured history size and TTL.","sidebar":"Guides"},"server/infra_tuning":{"id":"server/infra_tuning","title":"Infrastructure tuning","description":"As Centrifugo deals with lots of persistent connections your operating system and server infrastructure must be ready for it.","sidebar":"Guides"},"server/load_balancing":{"id":"server/load_balancing","title":"Load balancing","description":"This chapter shows how to deal with persistent connection load balancing.","sidebar":"Guides"},"server/monitoring":{"id":"server/monitoring","title":"Metrics monitoring","description":"Centrifugo supports reporting metrics in Prometheus format and can automatically export metrics to Graphite."},"server/observability":{"id":"server/observability","title":"Server observability","description":"To provide a better server observability Centrifugo supports reporting metrics in Prometheus format and can automatically export metrics to Graphite.","sidebar":"Guides"},"server/presence":{"id":"server/presence","title":"Online presence","description":"The online presence feature of Centrifugo is a powerful tool that allows you to monitor and manage active users inside a specific channel. It provides an instantaneous snapshot of users currently subscribed to a specific channel. Additionally, Centrifugo may emit join and leave events when clients subscribe to channel and unsubscribe from it.","sidebar":"Guides"},"server/proxy":{"id":"server/proxy","title":"Proxy events to the backend","description":"It\'s possible to proxy some client connection events from Centrifugo to the application backend and react to them in a custom way. For example, it\'s possible to authenticate connection via request from Centrifugo to application backend, refresh client sessions and answer to RPC calls sent by a client over bidirectional connection. Also, you may control subscription and publication permissions using these hooks.","sidebar":"Guides"},"server/proxy_streams":{"id":"server/proxy_streams","title":"Proxy subscription streams","description":"This is an experimental extension of Centrifugo proxy. We appreciate your feedback to make sure it\'s useful and solves real-world problems before marking it as stable and commit to the API.","sidebar":"Guides"},"server/server_api":{"id":"server/server_api","title":"Server API walkthrough","description":"Server API provides different methods to interact with Centrifugo. Specifically, in most cases this is an entry point for publications into channels coming from your application backend. There are two kinds of server API available at the moment:","sidebar":"Guides"},"server/server_subs":{"id":"server/server_subs","title":"Server-side subscriptions","description":"Centrifugo clients can initiate a subscription to a channel by calling the subscribe method of client API. In most cases, client-side subscriptions is a more flexible and recommended approach since a frontend usually knows which channels it needs to consume at a concrete moment.","sidebar":"Guides"},"server/tls":{"id":"server/tls","title":"Configure TLS","description":"TLS/SSL layer is very important not only for securing your connections but also to increase a","sidebar":"Guides"},"transports/client_api":{"id":"transports/client_api","title":"Client SDK API","description":"Centrifugo has several client SDKs to establish a real-time connection with a server. Centrifugo SDKs use WebSocket as the main data transport and send/receive messages encoded according to our bidirectional protocol. That protocol is built on top of the Protobuf schema (both JSON and binary Protobuf formats are supported). It provides asynchronous communication, sending RPC, multiplexing subscriptions to channels, etc. Client SDK wraps the protocol and exposes a set of APIs to developers.","sidebar":"Transports"},"transports/client_protocol":{"id":"transports/client_protocol","title":"Client protocol","description":"This chapter describes the core concepts of Centrifugo bidirectional client protocol \u2013 concentrating on framing level. If you want to find out details about exposed client API then look at client API document.","sidebar":"Transports"},"transports/client_sdk":{"id":"transports/client_sdk","title":"Client real-time SDKs","description":"In the previous chapter we investigated common principles of Centrifugo client SDK API. Here we will provide a list of available bidirectional connectors you can use to communicate with Centrifugo.","sidebar":"Transports"},"transports/http_stream":{"id":"transports/http_stream","title":"HTTP streaming, with bidirectional emulation","description":"HTTP streaming is a technique based on using a long-lived HTTP connection between a client and a server with a chunked transfer encoding. Usually it only allows unidirectional flow of messages from server to client but with Centrifugo bidirectional emulation layer it may be used as a full-featured fallback or alternative to WebSocket.","sidebar":"Transports"},"transports/overview":{"id":"transports/overview","title":"Real-time transports","description":"Centrifugo supports a variety of transports to deliver real-time messages to clients.","sidebar":"Transports"},"transports/sockjs":{"id":"transports/sockjs","title":"SockJS","description":"SockJS is a polyfill browser library which provides HTTP-based fallback transports in case when it\'s not possible to establish Websocket connection. This can happen in old client browsers or because of some proxy behind client and server that cuts of Websocket traffic. You can find more information on SockJS project Github page.","sidebar":"Transports"},"transports/sse":{"id":"transports/sse","title":"SSE (EventSource), with bidirectional emulation","description":"Server-Sent Events or EventSource is a well-known HTTP-based transport available in all modern browsers and loved by many developers. It\'s unidirectional in its nature but with Centrifugo bidirectional emulation layer it may be used as a fallback or alternative to WebSocket.","sidebar":"Transports"},"transports/uni_client_protocol":{"id":"transports/uni_client_protocol","title":"Unidirectional client protocol","description":"As we mentioned in overview you can avoid using Centrifugo SDKs if you stick with unidirectional approach. In this case though you will need to implement some basic parsing on client side to consume message types sent by Centrifugo into unidirectional connections.","sidebar":"Transports"},"transports/uni_grpc":{"id":"transports/uni_grpc","title":"Unidirectional GRPC","description":"It\'s possible to connect to GRPC unidirectional stream to consume real-time messages from Centrifugo. In this case you need to generate GRPC code for your language on client-side.","sidebar":"Transports"},"transports/uni_http_stream":{"id":"transports/uni_http_stream","title":"Unidirectional HTTP streaming","description":"HTTP streaming is a technique based on using a long-lived HTTP connection between a client and a server with a chunked transfer encoding. These days it\'s possible to use it from the web browser using modern Fetch and Readable Streams API.","sidebar":"Transports"},"transports/uni_sse":{"id":"transports/uni_sse","title":"Unidirectional SSE (EventSource)","description":"Server-Sent Events or EventSource is a well-known HTTP-based transport available in all modern browsers and loved by many developers.","sidebar":"Transports"},"transports/uni_websocket":{"id":"transports/uni_websocket","title":"Unidirectional WebSocket","description":"Default unidirectional WebSocket connection endpoint in Centrifugo is:","sidebar":"Transports"},"transports/websocket":{"id":"transports/websocket","title":"WebSocket","description":"Websocket is the main transport in Centrifugo. It\'s a very efficient low-overhead protocol on top of TCP.","sidebar":"Transports"},"transports/webtransport":{"id":"transports/webtransport","title":"WebTransport","description":"WebTransport is an API offering low-latency, bidirectional, client-server messaging on top of HTTP/3 (with QUIC under the hood). See Using WebTransport article that gives a good overview of it.","sidebar":"Transports"},"tutorial/backend":{"id":"tutorial/backend","title":"Setting up backend and database","description":"Let\'s start building the app. As the first step, create a directory for the new app:","sidebar":"Tutorial"},"tutorial/centrifugo":{"id":"tutorial/centrifugo","title":"Integrating Centrifugo for real-time event delivery","description":"It\'s finally time for the real-time! In some cases you already have an application and when integrating Centrifugo you start from here.","sidebar":"Tutorial"},"tutorial/frontend":{"id":"tutorial/frontend","title":"Creating SPA frontend with React","description":"On the frontend we will use Vite with React and Typescript. In this tutorial we are not paying a lot of attention to making all the types strict and using any a lot. Which is actually a point for improvement, but at least helps to make the tutorial slightly shorter. The prerequisites is NodeJS >= 18.","sidebar":"Tutorial"},"tutorial/improvements":{"id":"tutorial/improvements","title":"Appendix #1: Possible Improvements","description":"There are still many areas for improvement in GrandChat, but we had to halt at a certain point to prevent the tutorial from becoming a book. If you enjoyed the tutorial and wish to enhance GrandChat further, here are some bright ideas:","sidebar":"Tutorial"},"tutorial/intro":{"id":"tutorial/intro","title":"Building WebSocket chat (messenger) app from scratch","description":"In this tutorial, we show how to build a rather complex real-time application with Centrifugo. It features a modern and responsive frontend, user authentication, channel permission checks, and the main database as a source of truth.","sidebar":"Tutorial"},"tutorial/layout":{"id":"tutorial/layout","title":"App layout and behavior","description":"Before we start, we would like the reader to be more familiar with the layout and behavior of the application we are creating here. Let\'s look at it screen by screen, describe the behavior, and explain which parts will be endowed with real-time superpowers.","sidebar":"Tutorial"},"tutorial/outbox_cdc":{"id":"tutorial/outbox_cdc","title":"Broadcast using transactional outbox and CDC","description":"Some of you may notice one potential issue which could prevent event delivery to users when publishing messages to Centrifugo API. Since we do this after a transaction and via a network call (in our case, using HTTP), it means the broadcast API call may return an error.","sidebar":"Tutorial"},"tutorial/outro":{"id":"tutorial/outro","title":"Wrapping up \u2013 things learnt","description":"At this point, we have a working real-time app, so the tutorial comes to an end. We\'ve covered some concepts of Centrifugo, such as:","sidebar":"Tutorial"},"tutorial/recovery":{"id":"tutorial/recovery","title":"Missed messages recovery","description":"At this point, we already have a real-time application with the instant delivery of events to interested messenger users. Now, let\'s focus on ensuring reliable message delivery. The first step would be enabling Centrifugo\'s automatic message recovery for personal channels.","sidebar":"Tutorial"},"tutorial/reverse_proxy":{"id":"tutorial/reverse_proxy","title":"Adding Nginx as a reverse proxy","description":"As mentioned, we are building a single-page frontend application here, and the frontend will be completely decoupled from the backend. This separation is advantageous because Centrifugo users can theoretically swap only the backend or frontend components while following this tutorial. For example, one could keep the frontend part but attempt to implement the backend in Laravel, Rails, or another framework.","sidebar":"Tutorial"},"tutorial/scale":{"id":"tutorial/scale","title":"Scale to 100k cats in room","description":"Congratulations \u2013 we\'ve built an awesome app and we are done with the development within this tutorial! \ud83c\udf89","sidebar":"Tutorial"},"tutorial/tips_and_tricks":{"id":"tutorial/tips_and_tricks","title":"Appendix #2: Tips and tricks","description":"Making this tutorial took quite a lot of time for us. We want to collect some useful tips and tricks here for those who decide to play with the final example. Feel free to contribute if you find something which could help others.","sidebar":"Tutorial"}}}')}}]);