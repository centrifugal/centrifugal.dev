"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[1171],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(96540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},43755:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"pro/performance","title":"Faster performance","description":"Centrifugo PRO has performance improvements for several server parts. These improvements can help to reduce tail end-to-end latencies in the application, increase server throughput and/or reduce CPU usage on server machines. Our open-source version has a decent performance by itself, with PRO improvements Cenrifugo steps even further.","source":"@site/docs/pro/performance.md","sourceDirName":"pro","slug":"/pro/performance","permalink":"/docs/pro/performance","draft":false,"unlisted":false,"editUrl":"https://github.com/centrifugal/centrifugal.dev/edit/main/docs/pro/performance.md","tags":[],"version":"current","frontMatter":{"id":"performance","title":"Faster performance"},"sidebar":"Pro","previous":{"title":"Channel CEL expressions","permalink":"/docs/pro/cel_expressions"},"next":{"title":"Scalability optimizations","permalink":"/docs/pro/scalability"}}');var t=i(74848),r=i(28453),o=i(41306);const a={id:"performance",title:"Faster performance"},c=void 0,l={},d=[{value:"Faster connections runtime",id:"faster-connections-runtime",level:2},{value:"Faster HTTP API",id:"faster-http-api",level:2},{value:"Faster GRPC API",id:"faster-grpc-api",level:2},{value:"Faster HTTP proxy",id:"faster-http-proxy",level:2},{value:"Faster HTTP proxy client",id:"faster-http-proxy-client",level:3},{value:"Faster GRPC proxy",id:"faster-grpc-proxy",level:2},{value:"Faster async consumers",id:"faster-async-consumers",level:2},{value:"Faster JWT decoding",id:"faster-jwt-decoding",level:2},{value:"Faster GRPC unidirectional stream",id:"faster-grpc-unidirectional-stream",level:2},{value:"WebSocket compression optimizations",id:"websocket-compression-optimizations",level:2},{value:"Other optimizations",id:"other-optimizations",level:2},{value:"Examples",id:"examples",level:2},{value:"Publish HTTP API",id:"publish-http-api",level:3},{value:"History HTTP API",id:"history-http-api",level:3}];function p(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("img",{src:"/img/logo_animated_fast.svg",width:"100px",height:"100px",align:"left",style:{marginRight:"10px",float:"left"}}),"\n",(0,t.jsx)(n.p,{children:"Centrifugo PRO has performance improvements for several server parts. These improvements can help to reduce tail end-to-end latencies in the application, increase server throughput and/or reduce CPU usage on server machines. Our open-source version has a decent performance by itself, with PRO improvements Cenrifugo steps even further."}),"\n",(0,t.jsx)(n.h2,{id:"faster-connections-runtime",children:"Faster connections runtime"}),"\n",(0,t.jsx)(n.p,{children:"New in Centrifugo v6.2.0"}),"\n",(0,t.jsxs)(n.p,{children:["EXPERIMENTAL option on ",(0,t.jsx)(n.code,{children:"client"})," level is ",(0,t.jsx)(n.code,{children:"client.batch_periodic_events"})," (boolean, by default, ",(0,t.jsx)(n.code,{children:"false"}),"). To enable:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "client": {\n    "batch_periodic_events": true\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Once enabled Centrifugo will batch client connection periodic events such as ping and presence updates together instead of having them to work in isolated way. This may result into noticeable CPU savings when working with many mostly idle connections."}),"\n",(0,t.jsx)(n.p,{children:"In our local experiments we observed more than 2x CPU reduction for 10k mostly idle connections setup (only PING/PONG messages are being sent). First image is OSS CPU utilization, second one is PRO with periodic events batching enabled:"}),"\n","\n",(0,t.jsxs)("div",{style:{display:"flex",flexWrap:"wrap"},children:[(0,t.jsx)("img",{src:(0,o.Ay)("/img/cpu_idle_oss.jpg"),alt:"OSS",style:{width:"50%",objectFit:"contain"}}),(0,t.jsx)("img",{src:(0,o.Ay)("/img/cpu_idle_pro.jpg"),alt:"Pro",style:{width:"50%",objectFit:"contain"}})]}),"\n",(0,t.jsx)(n.p,{children:"Of course the ratio is highly dependent on the Centrifugo specific setup load profile and usage scenarios."}),"\n",(0,t.jsx)(n.h2,{id:"faster-http-api",children:"Faster HTTP API"}),"\n",(0,t.jsx)(n.p,{children:"Centrifugo PRO has an optimized JSON serialization/deserialization for HTTP API."}),"\n",(0,t.jsx)(n.p,{children:"The effect can be noticeable under load. The exact numbers heavily depend on usage scenario. According to our benchmarks you can expect 10-15% more requests/sec for small message publications over HTTP API, and up to several times throughput boost when you are frequently get lots of messages from a history, see a couple of examples below."}),"\n",(0,t.jsx)(n.h2,{id:"faster-grpc-api",children:"Faster GRPC API"}),"\n",(0,t.jsx)(n.p,{children:"Centrifugo PRO has an optimized Protobuf serialization/deserialization for GRPC API. The effect can be noticeable under load. The exact numbers heavily depend on usage scenario."}),"\n",(0,t.jsx)(n.h2,{id:"faster-http-proxy",children:"Faster HTTP proxy"}),"\n",(0,t.jsx)(n.p,{children:"Centrifugo PRO has an optimized JSON serialization/deserialization for HTTP proxy. The effect can be noticeable under load. The exact numbers heavily depend on usage scenario."}),"\n",(0,t.jsx)(n.h3,{id:"faster-http-proxy-client",children:"Faster HTTP proxy client"}),"\n",(0,t.jsxs)(n.p,{children:["Centrifugo PRO adds a boolean option ",(0,t.jsx)(n.code,{children:"use_fast_client"})," which enables using fast optimized HTTP client for proxy requests. In the benchmarks we did, the effect was up to 2x more request throughput for HTTP proxy and 10 times fewer allocations for each request. This will result into significant CPU and latency reductions under load."]}),"\n",(0,t.jsxs)(n.p,{children:["The option may be defined inside ",(0,t.jsx)(n.code,{children:"http"})," section of proxy object. For example, to enable it for a connect proxy:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "client": {\n    "proxy": {\n      "connect": {\n        "enabled": true,\n        "endpoint": "https://your_backend/centrifugo/connect",\n        "http": {\n          "use_fast_client": true\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"This is a separate option because the optimized version only supports HTTP 1.1, so we try to avoid unexpected side effects when migrating from Centrifugo OSS to Centrifugo PRO."}),"\n",(0,t.jsx)(n.h2,{id:"faster-grpc-proxy",children:"Faster GRPC proxy"}),"\n",(0,t.jsx)(n.p,{children:"Centrifugo PRO has an optimized Protobuf serialization/deserialization for GRPC API. The effect can be noticeable under load. The exact numbers heavily depend on usage scenario."}),"\n",(0,t.jsx)(n.h2,{id:"faster-async-consumers",children:"Faster async consumers"}),"\n",(0,t.jsx)(n.p,{children:"When asynchronous consumers are used and payload represents encoded request type Centrifugo PRO leverages optimized JSON decoder."}),"\n",(0,t.jsx)(n.h2,{id:"faster-jwt-decoding",children:"Faster JWT decoding"}),"\n",(0,t.jsx)(n.p,{children:"Centrifugo PRO has an optimized decoding of JWT claims."}),"\n",(0,t.jsx)(n.h2,{id:"faster-grpc-unidirectional-stream",children:"Faster GRPC unidirectional stream"}),"\n",(0,t.jsx)(n.p,{children:"Centrifugo PRO has an optimized Protobuf deserialization for GRPC unidirectional stream. This only affects deserialization of initial connect command."}),"\n",(0,t.jsx)(n.h2,{id:"websocket-compression-optimizations",children:"WebSocket compression optimizations"}),"\n",(0,t.jsxs)(n.p,{children:["Centrifugo PRO provides an integer option ",(0,t.jsx)(n.code,{children:"websocket.compression_prepared_message_size"})," (in bytes, default ",(0,t.jsx)(n.code,{children:"0"}),") which when set to a value > 0 tells Centrifugo to use a cache or prepared websocket messages when working with connections with WebSocket compression negotiated."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "websocket": {\n    "compression_prepared_message_size": 10485760\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This can significantly improve CPU and memory Centrifufo resource usage when using ",(0,t.jsx)(n.a,{href:"/docs/transports/websocket#websocketcompression",children:"WebSocket compression feature"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Check out blog post ",(0,t.jsx)(n.a,{href:"/blog/2024/08/19/optimizing-websocket-compression",children:"Performance optimizations of WebSocket compression in Go application"})," which describes the possible effect of this optimization."]}),"\n",(0,t.jsx)(n.h2,{id:"other-optimizations",children:"Other optimizations"}),"\n",(0,t.jsx)(n.p,{children:"Centrifugo PRO also provides other optimizations which can significantly affect resource usage and which are described individually, see:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/pro/scalability",children:"Scalability optimizations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/pro/bandwidth_optimizations",children:"Bandwidth optimizations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/pro/client_message_batching",children:"Message batching control"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.p,{children:"Let's look at quick live comparisons of Centrifugo OSS and Centrifugo PRO regarding HTTP API performance."}),"\n",(0,t.jsx)(n.h3,{id:"publish-http-api",children:"Publish HTTP API"}),"\n",(0,t.jsxs)("video",{width:"100%",controls:!0,children:[(0,t.jsx)("source",{src:"/img/pro_api_publish_perf.mp4",type:"video/mp4"}),(0,t.jsx)(n.p,{children:"Sorry, your browser doesn't support embedded video."})]}),"\n",(0,t.jsx)(n.p,{children:"In this video you can see a 13% speed up for publish operation. But for more complex API calls with larger payloads the difference can be much bigger. See next example that demonstrates this."}),"\n",(0,t.jsx)(n.h3,{id:"history-http-api",children:"History HTTP API"}),"\n",(0,t.jsxs)("video",{width:"100%",controls:!0,children:[(0,t.jsx)("source",{src:"/img/pro_api_history_perf.mp4",type:"video/mp4"}),(0,t.jsx)(n.p,{children:"Sorry, your browser doesn't support embedded video."})]}),"\n",(0,t.jsx)(n.p,{children:"In this video you can see an almost 2x overall speed up while asking 100 messages from Centrifugo history API."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}}}]);