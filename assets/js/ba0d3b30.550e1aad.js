"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[2309],{40966:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var t=i(85893),s=i(11151);const o={id:"overview",title:"Real-time transports"},r=void 0,c={id:"transports/overview",title:"Real-time transports",description:"Centrifugo supports a variety of transports to deliver real-time messages to clients.",source:"@site/versioned_docs/version-4/transports/overview.md",sourceDirName:"transports",slug:"/transports/overview",permalink:"/docs/4/transports/overview",draft:!1,unlisted:!1,editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/versioned_docs/version-4/transports/overview.md",tags:[],version:"4",frontMatter:{id:"overview",title:"Real-time transports"},sidebar:"Transports",next:{title:"Client SDK API",permalink:"/docs/4/transports/client_api"}},a={},l=[{value:"Bidirectional",id:"bidirectional",level:2},{value:"Unidirectional",id:"unidirectional",level:2},{value:"Unidirectional message types",id:"unidirectional-message-types",level:3},{value:"PING/PONG behavior",id:"pingpong-behavior",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Centrifugo supports a variety of transports to deliver real-time messages to clients."}),"\n",(0,t.jsx)(n.admonition,{title:"Every transport is a persistent connection",type:"info",children:(0,t.jsx)(n.p,{children:"Here we describe supported transports between your application frontend and Centrifugo itself. Every Centrifugo transport is a persistent connection so the server can push data towards clients at any moment."})}),"\n",(0,t.jsx)(n.p,{children:"The important distinction here is that all supported transports belong to one of two possible groups:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Bidirectional"}),"\n",(0,t.jsx)(n.li,{children:"Unidirectional"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"bidirectional",children:"Bidirectional"}),"\n",(0,t.jsx)(n.p,{children:"Bidirectional transports are capable to serve all Centrifugo features. These transports are the main Centrifugo focus."}),"\n",(0,t.jsxs)(n.p,{children:["Bidirectional transports come with a cost that developers need to use a special client connector library (SDK) which speaks Centrifugo ",(0,t.jsx)(n.a,{href:"/docs/4/transports/client_protocol",children:"client protocol"}),". The reason why we need a special client connector library is that a bidirectional connection is asynchronous \u2013 it's required to match requests to responses, properly manage connection state, handle request queueing/timeouts/errors, etc."]}),"\n",(0,t.jsxs)(n.p,{children:["Centrifugo has several official ",(0,t.jsx)(n.a,{href:"/docs/4/transports/client_sdk",children:"client SDKs"})," for popular environments. All of them work over ",(0,t.jsx)(n.a,{href:"/docs/4/transports/websocket",children:"WebSocket"})," transport. Our Javascript SDK also offers bidirectional fallbacks over ",(0,t.jsx)(n.a,{href:"/docs/4/transports/http_stream",children:"HTTP-Streaming"}),", ",(0,t.jsx)(n.a,{href:"/docs/4/transports/sse",children:"Server-Sent Events (SSE)"})," or ",(0,t.jsx)(n.a,{href:"/docs/4/transports/sockjs",children:"SockJS"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"unidirectional",children:"Unidirectional"}),"\n",(0,t.jsx)(n.p,{children:"Unidirectional transports suit well for simple use-cases with stable subscriptions, usually known at connection time."}),"\n",(0,t.jsxs)(n.p,{children:["The advantage is that unidirectional transports do not require special client connectors - developers can use native browser APIs (like ",(0,t.jsx)(n.a,{href:"/docs/4/transports/uni_websocket",children:"WebSocket"}),", ",(0,t.jsx)(n.a,{href:"/docs/4/transports/uni_sse",children:"EventSource/SSE"}),", ",(0,t.jsx)(n.a,{href:"/docs/4/transports/uni_http_stream",children:"HTTP-streaming"}),"), or ",(0,t.jsx)(n.a,{href:"/docs/4/transports/uni_grpc",children:"GRPC"})," generated code to receive real-time updates from Centrifugo. Thus avoiding dependency to a client connector that abstracts bidirectional communication."]}),"\n",(0,t.jsxs)(n.p,{children:["The drawback is that with unidirectional transports you are not inheriting all Centrifugo features out of the box (like dynamic subscriptions/unsubscriptions, automatic message recovery on reconnect, possibility to send RPC calls over persistent connection). But some of the missing client APIs can be mimicked by using calls to Centrifugo ",(0,t.jsx)(n.a,{href:"/docs/4/server/server_api",children:"server API"})," (i.e. over client -> application backend -> Centrifugo)."]}),"\n",(0,t.jsx)(n.h3,{id:"unidirectional-message-types",children:"Unidirectional message types"}),"\n",(0,t.jsxs)(n.p,{children:["In case of unidirectional transports Centrifugo will send ",(0,t.jsx)(n.code,{children:"Push"})," frames to the connection. Push frames defined by ",(0,t.jsx)(n.a,{href:"https://github.com/centrifugal/protocol/blob/master/definitions/client.proto",children:"client protocol schema"}),". I.e. Centrifugo reuses a part of its bidirectional protocol for unidirectional communication. Push message defined as:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"message Push {\n  string channel = 2;\n\n  Publication pub = 4;\n  Join join = 5;\n  Leave leave = 6;\n  Unsubscribe unsubscribe = 7;\n  Message message = 8;\n  Subscribe subscribe = 9;\n  Connect connect = 10;\n  Disconnect disconnect = 11;\n  Refresh refresh = 12;\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"Some numbers in Protobuf definitions skipped for backwards compatibility with previous client protocol version."})}),"\n",(0,t.jsxs)(n.p,{children:["So unidirectional connection will receive various pushes. Every push contains ",(0,t.jsx)(n.strong,{children:"one of"})," the following objects:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Publication"}),"\n",(0,t.jsx)(n.li,{children:"Join"}),"\n",(0,t.jsx)(n.li,{children:"Leave"}),"\n",(0,t.jsx)(n.li,{children:"Unsubscribe"}),"\n",(0,t.jsx)(n.li,{children:"Message"}),"\n",(0,t.jsx)(n.li,{children:"Subscribe"}),"\n",(0,t.jsx)(n.li,{children:"Connect"}),"\n",(0,t.jsx)(n.li,{children:"Disconnect"}),"\n",(0,t.jsx)(n.li,{children:"Refresh"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Some pushes belong to a ",(0,t.jsx)(n.code,{children:"channel"})," which may be set on Push top level."]}),"\n",(0,t.jsxs)(n.p,{children:["All you need to do is look at Push, process messages you are interested in and ignore others. In most cases you will be most interested in pushes which contain ",(0,t.jsx)(n.code,{children:"Connect"})," or ",(0,t.jsx)(n.code,{children:"Publication"})," messages."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, according to ",(0,t.jsx)(n.a,{href:"https://github.com/centrifugal/protocol/blob/master/definitions/client.proto",children:"protocol schema"})," Publication message type looks like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"message Publication {\n  bytes data = 4;\n  ClientInfo info = 5;\n  uint64 offset = 6;\n  map<string, string> tags = 7;\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["In JSON protocol case Centrifugo replaces ",(0,t.jsx)(n.code,{children:"bytes"})," type with embedded JSON."]})}),"\n",(0,t.jsx)(n.p,{children:"Just try using any unidirectional transport and you will quickly get the idea."}),"\n",(0,t.jsx)(n.h2,{id:"pingpong-behavior",children:"PING/PONG behavior"}),"\n",(0,t.jsx)(n.p,{children:"Centrifugo server periodically sends pings to clients and expects pong from clients that works over bidirectional transports. Sending ping and receiving pong allows to find broken connections faster. Centrifugo sends pings on the Centrifugo client protocol level, thus it's possible for clients to handle ping messages on the client side to make sure connection is not broken (our bidirectional SDKs do this automatically)."}),"\n",(0,t.jsxs)(n.p,{children:["By default Centrifugo sends pings every 25 seconds. This may be changed using ",(0,t.jsx)(n.code,{children:"ping_interval"})," option (",(0,t.jsx)(n.a,{href:"/docs/4/server/configuration#setting-time-duration-options",children:"duration"}),", default ",(0,t.jsx)(n.code,{children:'"25s"'}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["Centrifugo expects pong message from bidirectional client SDK after sending ping to it. By default, it waits no more than 8 seconds before closing a connection. This may be changed using ",(0,t.jsx)(n.code,{children:"pong_timeout"})," option (",(0,t.jsx)(n.a,{href:"/docs/4/server/configuration#setting-time-duration-options",children:"duration"}),", default ",(0,t.jsx)(n.code,{children:'"8s"'}),")."]}),"\n",(0,t.jsx)(n.p,{children:"In most cases default ping/pong intervals are fine so you don't really need to tweak them. Reducing timeouts may help you to find non-gracefully closed connections faster, but will increase network traffic and CPU resource usage since ping/pongs are sent faster."}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ping_interval"})," must be greater than ",(0,t.jsx)(n.code,{children:"pong_timeout"})," in the current implementation."]})}),"\n",(0,t.jsx)(n.p,{children:"Here is a scheme how ping/pong works in bidirectional and unidirectional client scenarios:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:i(73915).Z+"",width:"2396",height:"1435"})})]})}function p(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},73915:(e,n,i)=>{i.d(n,{Z:()=>t});const t=i.p+"assets/images/ping_pong-4f67ec945077864d9accb516406fb6d0.png"},11151:(e,n,i)=>{i.d(n,{Z:()=>c,a:()=>r});var t=i(67294);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);