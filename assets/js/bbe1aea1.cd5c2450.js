"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[6769],{28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var i=s(96540);const r={},t=i.createContext(r);function a(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(t.Provider,{value:n},e.children)}},51763:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/singleflight-35650f07c8cda65fec55fd490157a6a0.png"},68063:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"pro/scalability","title":"Scalability optimizations","description":"Centrifugo PRO scalability features: singleflight, shared position sync, Redis replica offloading, sharded PUB/SUB, per-namespace engines, and custom controllers.","source":"@site/docs/pro/scalability.md","sourceDirName":"pro","slug":"/pro/scalability","permalink":"/docs/pro/scalability","draft":false,"unlisted":false,"editUrl":"https://github.com/centrifugal/centrifugal.dev/edit/main/docs/pro/scalability.md","tags":[],"version":"current","frontMatter":{"description":"Centrifugo PRO scalability features: singleflight, shared position sync, Redis replica offloading, sharded PUB/SUB, per-namespace engines, and custom controllers.","id":"scalability","title":"Scalability optimizations"},"sidebar":"Pro","previous":{"title":"Faster performance","permalink":"/docs/pro/performance"},"next":{"title":"Bandwidth optimizations","permalink":"/docs/pro/bandwidth_optimizations"}}');var r=s(74848),t=s(28453);const a={description:"Centrifugo PRO scalability features: singleflight, shared position sync, Redis replica offloading, sharded PUB/SUB, per-namespace engines, and custom controllers.",id:"scalability",title:"Scalability optimizations"},o=void 0,l={},c=[{value:"Singleflight",id:"singleflight",level:2},{value:"Shared position sync",id:"shared-position-sync",level:2},{value:"Leverage Redis replicas",id:"leverage-redis-replicas",level:2},{value:"Subscribe on replica",id:"subscribe-on-replica",level:3},{value:"Read presence from replica",id:"read-presence-from-replica",level:3},{value:"Redis Cluster sharded PUB/SUB",id:"redis-cluster-sharded-pubsub",level:2},{value:"Per-namespace engines",id:"per-namespace-engines",level:2},{value:"Defining brokers",id:"defining-brokers",level:3},{value:"Defining presence managers",id:"defining-presence-managers",level:3},{value:"Setting custom Controller",id:"setting-custom-controller",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Centrifugo PRO comes with several options to reduce load on Engine \u2013 specifically on its history and presence API. This may have a positive effect on CPU resource usage on engine side and a positive effect on operation latencies."}),"\n",(0,r.jsx)(n.h2,{id:"singleflight",children:"Singleflight"}),"\n",(0,r.jsxs)(n.p,{children:["Centrifugo PRO provides an additional boolean option ",(0,r.jsx)(n.code,{children:"use_singleflight"})," (default ",(0,r.jsx)(n.code,{children:"false"}),"). When this option enabled Centrifugo will automatically try to merge identical requests to history, online presence or presence stats issued at the same time into one real network request. It will do this by using in-memory component called ",(0,r.jsx)(n.code,{children:"singleflight"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Singleflight",src:s(51763).A+"",width:"4259",height:"858"})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"While it can seem similar, singleflight is not a cache. It only combines identical parallel requests into one. If requests come one after another \u2013 they will be sent separately to the broker or presence storage."})}),"\n",(0,r.jsx)(n.p,{children:"This option can radically reduce a load on a broker in the following situations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Many clients subscribed to the same channel and in case of massive reconnect scenario try to access history simultaneously to restore a state (whether manually using history API or over automatic recovery feature)"}),"\n",(0,r.jsx)(n.li,{children:"Many clients subscribed to the same channel and positioning feature is on so Centrifugo tracks client position"}),"\n",(0,r.jsx)(n.li,{children:"Many clients subscribed to the same channel and in case of massive reconnect scenario try to call presence or presence stats simultaneously"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Using this option only makes sense with remote engine (such as Redis), it won't provide a benefit in case of using a Memory engine."}),"\n",(0,r.jsx)(n.p,{children:"To enable:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "singleflight": {\n    "enabled": true\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Or via ",(0,r.jsx)(n.code,{children:"CENTRIFUGO_USE_SINGLEFLIGHT"})," environment variable."]}),"\n",(0,r.jsx)(n.h2,{id:"shared-position-sync",children:"Shared position sync"}),"\n",(0,r.jsx)(n.p,{children:"Shared position synchronization feature allows reducing the load on the broker from position synchronization requests in channels with many subscribers and positioning/recovery enabled."}),"\n",(0,r.jsx)(n.p,{children:"Centrifugo uses periodic position synchronization requests to make sure there was no message loss between Engine PUB/SUB and Centrifugo. These requests create additional load on broker."}),"\n",(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"shared_position_sync"})," is enabled subscribers use an intermediary cache to only send position requests to the broker if another channel subscriber have not done it recently. So the benefit here is proportional to the number of channel subscribers on Centrifugo node."]}),"\n",(0,r.jsxs)(n.p,{children:["To enable in the specific channel namespace use boolean channel option ",(0,r.jsx)(n.code,{children:"shared_position_sync"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "channel": {\n    "namespaces": [\n      {\n        "name": "example",\n        "force_recovery": true,\n        "shared_position_sync": true\n      }\n    ]\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"leverage-redis-replicas",children:"Leverage Redis replicas"}),"\n",(0,r.jsx)(n.p,{children:"Centrifugo users have Redis setups with replication configured. Replication is usually used in Redis Sentinel based primary-replica setup, or Redis Cluster where each cluster shard may consist of primary and several replicas."}),"\n",(0,r.jsx)(n.p,{children:"Centrifugo PRO allows utilizing existing replicas for certain operations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"move all channel subscriptions to replica \u2013 thus primary becomes less utilized"}),"\n",(0,r.jsx)(n.li,{children:"move reading presence information to replica, again making primary more effective since potentially more slow requests are moved out."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This extends scalability options and may be very handy to stay on lower resources. Let's look how to configure those."}),"\n",(0,r.jsx)(n.h3,{id:"subscribe-on-replica",children:"Subscribe on replica"}),"\n",(0,r.jsx)(n.p,{children:"It's supported by Redis Engine and Redis Broker (only for Redis Sentinel and Redis Cluster setups)."}),"\n",(0,r.jsxs)(n.p,{children:["You need to enable ",(0,r.jsx)(n.code,{children:"replica_client"})," in Redis configuration and set ",(0,r.jsx)(n.code,{children:"subscribe_on_replica"})," boolean option:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "engine": {\n    "type": "redis",\n    "redis": {\n      "address": "redis+cluster://localhost:7000",\n      "replica_client": {\n        "enabled": true\n      },\n      "subscribe_on_replica": true\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Centrifugo PRO will automatically move channel subscriptions to discovered replica."}),"\n",(0,r.jsx)(n.p,{children:"The same may be used when configuring a separate Redis Broker."}),"\n",(0,r.jsx)(n.h3,{id:"read-presence-from-replica",children:"Read presence from replica"}),"\n",(0,r.jsxs)(n.p,{children:["To read presence information from replica you need to enable ",(0,r.jsx)(n.code,{children:"replica_client"})," in Redis configuration and set ",(0,r.jsx)(n.code,{children:"presence_read_from_replica"})," boolean option:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "engine": {\n    "type": "redis",\n    "redis": {\n      "address": "redis+cluster://localhost:7000",\n      "replica_client": {\n        "enabled": true\n      },\n      "presence_read_from_replica": true\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Centrifugo PRO will automatically move presence read operations to discovered replica."}),"\n",(0,r.jsx)(n.p,{children:"The same may be used when configuring a separate Redis Presence Manager."}),"\n",(0,r.jsx)(n.h2,{id:"redis-cluster-sharded-pubsub",children:"Redis Cluster sharded PUB/SUB"}),"\n",(0,r.jsxs)(n.p,{children:["Sharded PUB/SUB ",(0,r.jsx)(n.a,{href:"https://redis.io/docs/latest/develop/interact/pubsub/#sharded-pubsub",children:"was introduced in Redis 7.0"})," as an attempt to fix the problem with PUB/SUB scalability in Redis Cluster. With normal PUB/SUB all publications are spread towards all nodes of cluster. This makes Cluster PUB/SUB throughput less with adding more nodes to the cluster. The utilization of Redis shards is usually unequal when using PUB/SUB in Redis Cluster as subscriptions land to one of the shards. In sharded PUB/SUB case channel keyspace is divided to slots in the same way as normal keys, and PUB/SUB is split over Redis Cluster nodes based on channel name."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:s(96474).A+"",width:"2603",height:"1265"})}),"\n",(0,r.jsxs)(n.p,{children:["When using Centrifugo PRO with the sharded PUB/SUB feature, there are important considerations to keep in mind. This feature changes how Centrifugo constructs keys and channel names in Redis compared to the standard non-sharded setup. Specifically, Centrifugo divides the channel space into a configurable number of ",(0,r.jsx)(n.code,{children:"sharded_pub_sub_partitions"}),", typically 64 to 128 (but this is up to developer to decide on the number depending on the load and cluster size).  This partitioning is essential to ensure compatibility with Redis Cluster's slot system while keeping the number of connections from Centrifugo to Redis at a manageable level. Each partition uses a dedicated connection for PUB/SUB communication with the Redis Cluster."]}),"\n",(0,r.jsx)(n.p,{children:"Without this partitioning, each Centrifugo node could potentially create up to 16384 connections to the Redis Cluster\u2014one for each cluster slot\u2014a number that is impractically large. The partitioning strategy avoids this issue, maintaining efficient and scalable communication between Centrifugo and Redis."}),"\n",(0,r.jsx)(n.p,{children:"We generally recommend using Redis sharded PUB/SUB only if you are already using a Redis Cluster and are nearing its scalability limits. In such cases, switching to sharded PUB/SUB mode, despite the different keys/channel names in Redis, can significantly enhance the application's ability to handle larger workloads."}),"\n",(0,r.jsx)(n.p,{children:"Once the scalability limit of a single cluster with sharded PUB/SUB is reached, you can further scale by adding an additional, isolated Redis Cluster. Centrifugo can then be configured to use multiple clusters instead of one, enabling scaling similar to its consistent sharding mechanism over isolated single Redis instances. However, in this setup, the sharding occurs across multiple Redis Clusters."}),"\n",(0,r.jsx)(n.p,{children:"Here is how to enable sharded PUB/SUB in Centrifugo PRO:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "engine": {\n    "type": "redis",\n    "redis": {\n      "address": "redis+cluster://localhost:7000",\n      "sharded_pub_sub_partitions": 64\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Sharded PUB/SUB support is a powerful feature which will push your Redis Cluster to its PUB/SUB limits, but it requires careful consideration given the implementation details described above."}),"\n",(0,r.jsx)(n.h2,{id:"per-namespace-engines",children:"Per-namespace engines"}),"\n",(0,r.jsxs)(n.p,{children:["Centrifugo OSS allows ",(0,r.jsx)(n.a,{href:"/docs/server/engines",children:"specifying an engine"}),". Engine is responsible for PUB/SUB and channel stream/history features (we call this part ",(0,r.jsx)(n.code,{children:"Broker"}),"), and for online presence (this part is called ",(0,r.jsx)(n.code,{children:"Presence Manager"}),"). Engine in Centrifugo OSS is global for the entire Centrifugo setup \u2013 once defined, all channels use it to make operations."]}),"\n",(0,r.jsx)(n.p,{children:"Centrifugo PRO allows redefining brokers and presence managers on a namespace level. This may help with individual scaling based on channel activity, using different properties inside different channel namespaces within a single Centrifugo setup. This feature significantly enhances Centrifugo's adaptability, making it easier to meet diverse and evolving application demands."}),"\n",(0,r.jsx)(n.p,{children:"For example, you can configure Centrifugo to use Redis engine by default, but for some specific namespace use Nats for PUB/SUB \u2013 this may be handy if you need wildcard subscriptions for one of the features in the app, or maybe you want to consume from raw Nats topics for some app feature, but for other features you still need functionality implemented by Centrifugo Redis Engine - like history in channels, automatic recovery. Or, maybe you want to separate Redis setups used for broker purposes and online presence purposes."}),"\n",(0,r.jsx)(n.h3,{id:"defining-brokers",children:"Defining brokers"}),"\n",(0,r.jsx)(n.p,{children:"First, you need create configuration for additional brokers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  ...\n  "brokers": [\n    {\n      "enabled": true,\n      "name": "mycustomredis",\n      "type": "redis",\n      "redis": {\n        "address": "127.0.0.1:6379"\n      }\n    },\n    {\n      "enabled": true,\n      "name": "mycustomnats",\n      "type": "nats",\n      "nats": {\n        "url": "nats://localhost:4222"\n      }\n    }\n  ]\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"At this point Centrifugo PRO supports two broker types:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"redis"})," - inherits all the possibilities of Centrifugo ",(0,r.jsx)(n.a,{href:"/docs/server/engines#redis-engine",children:"built-in Redis Engine"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"nats"})," \u2013  inherits all the possibilities of Centrifugo ",(0,r.jsx)(n.a,{href:"/docs/server/engines#nats-broker",children:"integration with Nats broker"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["These brokers inherit all options described in ",(0,r.jsx)(n.a,{href:"/docs/server/engines",children:"Engines and scalability"})," chapter. The only difference that it's possible to specify which custom broker to use inside a channel namespace:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  ...\n  "channel": {\n    "namespaces": [\n      {\n        "name": "rates",\n        "broker_name": "mycustomnats"\n      }\n    ]\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"defining-presence-managers",children:"Defining presence managers"}),"\n",(0,r.jsx)(n.p,{children:"And for custom Presence Managers a similar approach may be applied. First, define a custom presence manager:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "presence_managers": [\n    {\n      "enabled": true,\n      "name": "mycustomredis",\n      "type": "redis",\n      "redis": {}\n    }\n  ]\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Centrifugo PRO only supports ",(0,r.jsx)(n.code,{children:"redis"})," type of Presence Manager."]}),"\n",(0,r.jsx)(n.p,{children:"And then enable it for namespace:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  ...\n  "channel": {\n    "namespaces": [\n      {\n        "name": "rates",\n        "broker_name": "mycustomnats",\n        "presence_manager_name": "mycustomredis"\n      }\n    ]\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"setting-custom-controller",children:"Setting custom Controller"}),"\n",(0,r.jsx)(n.p,{children:"Controller in Centrifugo is responsible for cross-node communication in cluster. Centrifugo PRO allows using a custom controller configuration. This may be useful to isolate controller load from channel load (i.e. from Broker), or to use Redis for channel operations and Nats for controller operations, or use Redis for channel operations, but sth like DragonflyDB for controller operations, etc."}),"\n",(0,r.jsxs)(n.p,{children:["To use a custom controller you need to set ",(0,r.jsx)(n.code,{children:"controller"})," configuration option and set ",(0,r.jsx)(n.code,{children:"enabled"})," to ",(0,r.jsx)(n.code,{children:"true"}),". You can use ",(0,r.jsx)(n.code,{children:"redis"})," or ",(0,r.jsx)(n.code,{children:"nats"})," as a controller type. Here is an example of using custom Redis setup as a controller:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "controller": {\n    "enabled": true,\n    "type": "redis",\n    "redis": {\n      "address": "redis://localhost:6379"\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Redis options are the same as for the Redis Engine configuration (except those which only make sense for Broker or PresenceManager)."}),"\n",(0,r.jsx)(n.p,{children:"Same for Nats:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "controller": {\n    "enabled": true,\n    "type": "nats",\n    "nats": {\n      "url": "nats://localhost:4222"\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Nats options are the same as for the Nats Broker configuration (except those which only make sense for Broker)."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},96474:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/redis_cluster_sharded_pub_sub-0e42f152d41e71791a7a0486d3f74e04.png"}}]);