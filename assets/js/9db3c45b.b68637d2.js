"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[1621],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var r=s(96540);const i={},t=r.createContext(i);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:n},e.children)}},48598:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"pro/user_block","title":"User blocking API","description":"One additional instrument for making protective actions in Centrifugo PRO is user blocking API which allows blocking a specific user on Centrifugo level.","source":"@site/docs/pro/user_block.md","sourceDirName":"pro","slug":"/pro/user_block","permalink":"/docs/pro/user_block","draft":false,"unlisted":false,"editUrl":"https://github.com/centrifugal/centrifugal.dev/edit/main/docs/pro/user_block.md","tags":[],"version":"current","frontMatter":{"id":"user_block","title":"User blocking API"},"sidebar":"Pro","previous":{"title":"Connections API","permalink":"/docs/pro/connections"},"next":{"title":"Token revocation API","permalink":"/docs/pro/token_revocation"}}');var i=s(74848),t=s(28453);const o={id:"user_block",title:"User blocking API"},l=void 0,c={},a=[{value:"How it works",id:"how-it-works",level:2},{value:"Configure",id:"configure",level:2},{value:"Redis persistence engine",id:"redis-persistence-engine",level:3},{value:"Database persistence engine",id:"database-persistence-engine",level:3},{value:"Block  API",id:"block--api",level:2},{value:"block_user",id:"block_user",level:3},{value:"BlockUserRequest",id:"blockuserrequest",level:4},{value:"BlockUserResult",id:"blockuserresult",level:4},{value:"unblock_user",id:"unblock_user",level:3},{value:"UnblockUserRequest",id:"unblockuserrequest",level:4},{value:"UnblockUserResult",id:"unblockuserresult",level:4}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"One additional instrument for making protective actions in Centrifugo PRO is user blocking API which allows blocking a specific user on Centrifugo level."}),"\n",(0,i.jsx)(n.p,{children:"When user is blocked it will be disconnected from Centrifugo immediately and also on the next connect attempt right after JWT decoded (so that Centrifugo got a user ID) or after result from connect proxy received. In case of using connect proxy you can actually disconnect user yourself by implementing blocking check on the application backend side \u2013 but possibility to block user in Centrifugo can still be helpful."}),"\n",(0,i.jsx)(n.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,i.jsx)(n.p,{children:"By default, information about user block/unblock requests shared throughout Centrifugo cluster and kept in memory. So user will be blocked until Centrifugo restart."}),"\n",(0,i.jsx)(n.p,{children:"But it's possible to enable blocking information persistence by configuring a persistence storage \u2013 in this case information will survive Centrifugo restarts."}),"\n",(0,i.jsx)(n.p,{children:"Centrifugo also automatically expires entries in the storage to keep working set of blocked users reasonably small. Keeping pool of blocked users small allows avoiding expensive database lookups on every check \u2013 information is loaded periodically from the storage and all checks performed over in-memory data structure \u2013 thus user blocking checks are cheap and have a small impact on the overall system performance."}),"\n",(0,i.jsx)(n.h2,{id:"configure",children:"Configure"}),"\n",(0,i.jsx)(n.p,{children:"User block feature is enabled by default in Centrifugo PRO (blocking information will be stored in process memory). To keep blocking information persistently you need to configure persistence engine."}),"\n",(0,i.jsx)(n.p,{children:"There are two types of persistent engines supported at the moment:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"redis"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"database"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"redis-persistence-engine",children:"Redis persistence engine"}),"\n",(0,i.jsx)(n.p,{children:"Blocking data can be kept in Redis. To enable this configuration should be:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "user_block": {\n    "storage_type": "redis",\n    "redis": {\n      "address": "localhost:6379" \n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"danger",children:(0,i.jsxs)(n.p,{children:["Unlike many other Redis features in Centrifugo consistent sharding is not supported for blocking data. The reason is that we don't want to loose blocking information when additional Redis node added. So only one Redis shard can be provided for ",(0,i.jsx)(n.code,{children:"user_block"})," feature. This should be fine given that working set of blocked users should be reasonably small and old entries expire. If you try to set several Redis shards here Centrifugo will exit with an error on start."]})}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:["One more thing you may notice is that Redis configuration here does not have ",(0,i.jsx)(n.code,{children:"use_redis_from_engine"})," option. The reason is that since Redis is not shardable here reusing Redis configuration here could cause problems at the moment of Redis scaling \u2013 which we want to avoid thus require explicit configuration here."]})}),"\n",(0,i.jsx)(n.h3,{id:"database-persistence-engine",children:"Database persistence engine"}),"\n",(0,i.jsx)(n.p,{children:"Blocking data can be kept in the relational database. Only PostgreSQL is supported."}),"\n",(0,i.jsx)(n.p,{children:"To enable this configuration should be like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "database": {\n    "enabled": true,\n    "postgresql": {\n      "dsn": "postgresql://postgres:pass@127.0.0.1:5432/postgres"\n    }\n  },\n  "user_block": {\n    "storage_type": "database"\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsx)(n.p,{children:"To quickly start local PostgreSQL database:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"docker run -it --rm -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=pass -p 5432:5432 postgres:15\n"})})]}),"\n",(0,i.jsx)(n.h2,{id:"block--api",children:"Block  API"}),"\n",(0,i.jsx)(n.h3,{id:"block_user",children:"block_user"}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'curl --header "Content-Type: application/json" \\\n  --header "X-API-Key: <API_KEY>" \\\n  --request POST \\\n  --data \'{"user": "2695", "expire_at": 1635845122}\' \\\n  http://localhost:8000/api/block_user\n'})}),"\n",(0,i.jsx)(n.h4,{id:"blockuserrequest",children:"BlockUserRequest"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter name"}),(0,i.jsx)(n.th,{children:"Parameter type"}),(0,i.jsx)(n.th,{children:"Required"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"user"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{children:"yes"}),(0,i.jsx)(n.td,{children:"User ID to block"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"expire_at"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsx)(n.td,{children:"no"}),(0,i.jsxs)(n.td,{children:["Unix time in the future when user blocking information should expire (Unix seconds). While optional ",(0,i.jsx)(n.strong,{children:"we recommend to use a reasonably small expiration time"})," to keep working set of blocked users small (since Centrifugo nodes periodically load all entries from the storage to construct in-memory cache)."]})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"blockuserresult",children:"BlockUserResult"}),"\n",(0,i.jsx)(n.p,{children:"Empty object at the moment."}),"\n",(0,i.jsx)(n.h3,{id:"unblock_user",children:"unblock_user"}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'curl --header "Content-Type: application/json" \\\n  --header "X-API-Key: <API_KEY>" \\\n  --request POST \\\n  --data \'{"user": "2695"}\' \\\n  http://localhost:8000/api/unblock_user\n'})}),"\n",(0,i.jsx)(n.h4,{id:"unblockuserrequest",children:"UnblockUserRequest"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter name"}),(0,i.jsx)(n.th,{children:"Parameter type"}),(0,i.jsx)(n.th,{children:"Required"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"user"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{children:"yes"}),(0,i.jsx)(n.td,{children:"User ID to unblock"})]})})]}),"\n",(0,i.jsx)(n.h4,{id:"unblockuserresult",children:"UnblockUserResult"}),"\n",(0,i.jsx)(n.p,{children:"Empty object at the moment."})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);