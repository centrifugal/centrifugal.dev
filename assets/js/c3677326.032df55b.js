"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[2569],{7092:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var r=t(7462),i=(t(7294),t(3905));const a={title:"Experimenting with QUIC and WebTransport",tags:["quic","webtransport","go"],description:"Experimenting with QUIC and WebTransport in Go",author:"Alexander Emelin",authorTitle:"Creator of Centrifugo",authorImageURL:"https://github.com/FZambia.png",image:"https://i.imgur.com/sH9zfhe.jpg",hide_table_of_contents:!1},o=void 0,s={permalink:"/blog/2020/10/16/experimenting-with-quic-transport",editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/blog/2020-10-16-experimenting-with-quic-transport.md",source:"@site/blog/2020-10-16-experimenting-with-quic-transport.md",title:"Experimenting with QUIC and WebTransport",description:"Experimenting with QUIC and WebTransport in Go",date:"2020-10-16T00:00:00.000Z",formattedDate:"October 16, 2020",tags:[{label:"quic",permalink:"/blog/tags/quic"},{label:"webtransport",permalink:"/blog/tags/webtransport"},{label:"go",permalink:"/blog/tags/go"}],readingTime:14.165,hasTruncateMarker:!0,authors:[{name:"Alexander Emelin",title:"Creator of Centrifugo",imageURL:"https://github.com/FZambia.png"}],frontMatter:{title:"Experimenting with QUIC and WebTransport",tags:["quic","webtransport","go"],description:"Experimenting with QUIC and WebTransport in Go",author:"Alexander Emelin",authorTitle:"Creator of Centrifugo",authorImageURL:"https://github.com/FZambia.png",image:"https://i.imgur.com/sH9zfhe.jpg",hide_table_of_contents:!1},prevItem:{title:"Scaling WebSocket in Go and beyond",permalink:"/blog/2020/11/12/scaling-websocket"},nextItem:{title:"Million connections with Centrifugo",permalink:"/blog/2020/02/10/million-connections-with-centrifugo"}},l={authorsImageUrls:[void 0]},c=[{value:"Overview",id:"overview",level:2},{value:"Install Chrome Canary",id:"install-chrome-canary",level:2},{value:"Generate self-signed TLS certificates",id:"generate-self-signed-tls-certificates",level:2},{value:"Run client example",id:"run-client-example",level:2},{value:"Writing a QUIC server",id:"writing-a-quic-server",level:2},{value:"Server skeleton",id:"server-skeleton",level:3},{value:"Accept QUIC connections",id:"accept-quic-connections",level:3},{value:"Connection Session handling",id:"connection-session-handling",level:3},{value:"Parsing client indication",id:"parsing-client-indication",level:3},{value:"Communicating over bidirectional streams",id:"communicating-over-bidirectional-streams",level:3},{value:"Full server example",id:"full-server-example",level:3},{value:"Conclusion",id:"conclusion",level:2}],p={toc:c};function u(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/sH9zfhe.jpg",alt:"post-cover"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"UPDATE: WebTransport spec is still evolving. Most information here is not actual anymore. For example the working group has no plan to implement both QuicTransport and HTTP3-based transports \u2013 only HTTP3 based WebTransport is going to be implemented. Maybe we will publish a follow-up of this post at some point.")),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"WebTransport is a new browser API offering low-latency, bidirectional, client-server messaging. If you have not heard about it before I suggest to first read a post called ",(0,i.kt)("a",{parentName:"p",href:"https://web.dev/quictransport/"},"Experimenting with QuicTransport")," published recently on web.dev \u2013 it gives a nice overview to WebTransport and shows client-side code examples. Here we will concentrate on implementing server side."),(0,i.kt)("p",null,"Some key points about WebTransport spec:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"WebTransport standard will provide a possibility to use streaming client-server communication using modern transports such as ",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/QUIC"},"QUIC")," and ",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/HTTP/3"},"HTTP/3")),(0,i.kt)("li",{parentName:"ul"},"It can be a good alternative to ",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/WebSocket"},"WebSocket")," messaging, standard provides some capabilities that are not possible with current WebSocket spec: possibility to get rid of head-of-line blocking problems using individual streams for different data, the possibility to reuse a single connection to a server in different browser tabs"),(0,i.kt)("li",{parentName:"ul"},"WebTransport also defines an unreliable stream API using UDP datagrams (which is possible since QUIC is UDP-based) \u2013 which is what browsers did not have before without a rather complex ",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/WebRTC"},"WebRTC")," setup involving ICE, STUN, etc. This is sweet for in-browser real-time games.")),(0,i.kt)("p",null,"To help you figure out things here are links to current WebTransport specs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://tools.ietf.org/html/draft-vvv-webtransport-overview-01"},"WebTransport overview")," \u2013 this spec gives an overview of WebTransport and provides requirements to transport layer"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://tools.ietf.org/html/draft-vvv-webtransport-quic"},"WebTransport over QUIC")," \u2013 this spec describes QUIC-based transport for WebTransport"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://tools.ietf.org/html/draft-vvv-webtransport-http3"},"WebTransport over HTTP/3")," \u2013 this spec describes HTTP/3-based transport for WebTransport (actually HTTP/3 is a protocol defined on top of QUIC)")),(0,i.kt)("p",null,"At moment Chrome only implements ",(0,i.kt)("a",{parentName:"p",href:"https://web.dev/quictransport/#register-for-ot"},"trial possibility")," to try out WebTransport standard and only implements WebTransport over QUIC. Developers can initialize transport with code like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const transport = new QuicTransport('quic-transport://localhost:4433/path');\n")),(0,i.kt)("p",null,"In case of HTTP/3 transport one will use URL like ",(0,i.kt)("inlineCode",{parentName:"p"},"'https://localhost:4433/path'")," in transport constructor. All WebTransport underlying transports should support instantiation over URL \u2013 that's one of the spec requirements. "),(0,i.kt)("p",null,"I decided that this is a cool possibility to finally play with QUIC protocol and its Go implementation ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lucas-clemente/quic-go"},"github.com/lucas-clemente/quic-go"),"."),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},"Please keep in mind that all things described in this post are work in progress. WebTransport drafts, Quic-Go library, even QUIC protocol itself are subjects to change. You should not use it in production yet.")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://web.dev/quictransport/"},"Experimenting with QuicTransport")," post contains links to a ",(0,i.kt)("a",{parentName:"p",href:"https://googlechrome.github.io/samples/quictransport/client.html"},"client example")," and companion ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/GoogleChrome/samples/blob/gh-pages/quictransport/quic_transport_server.py"},"Python server implementation"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/Hty00aG.png",alt:"client example"})),(0,i.kt)("p",null,"We will use a linked client example to connect to a server that runs on localhost and uses ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lucas-clemente/quic-go"},"github.com/lucas-clemente/quic-go")," library. To make our example work we need to open client example in Chrome, and actually, at this moment we need to install Chrome Canary. The reason behind this is that the  ",(0,i.kt)("inlineCode",{parentName:"p"},"quic-go")," library supports QUIC draft-29 while Chrome < 85 implements QuicTransport over draft-27. If you read this post at a time when Chrome stable 85 already released then most probably you don't need to install Canary release and just use your stable Chrome."),(0,i.kt)("p",null,"We also need to generate self-signed certificates since WebTransport only works with a TLS layer, and we should make Chrome trust our certificates. Let's prepare our client environment before writing a server and first install Chrome Canary."),(0,i.kt)("h2",{id:"install-chrome-canary"},"Install Chrome Canary"),(0,i.kt)("p",null,"Go to ",(0,i.kt)("a",{parentName:"p",href:"https://www.google.com/intl/en/chrome/canary/"},"https://www.google.com/intl/en/chrome/canary/"),", download and install Chrome Canary. We will use it to open ",(0,i.kt)("a",{parentName:"p",href:"https://googlechrome.github.io/samples/quictransport/client.html"},"client example"),"."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"If you have Chrome >= 85 then most probably you can skip this step.")),(0,i.kt)("h2",{id:"generate-self-signed-tls-certificates"},"Generate self-signed TLS certificates"),(0,i.kt)("p",null,"Since WebTransport based on modern network transports like QUIC and HTTP/3 security is a keystone. For our experiment we will create a self-signed TLS certificate using ",(0,i.kt)("inlineCode",{parentName:"p"},"openssl"),". "),(0,i.kt)("p",null,"Make sure you have ",(0,i.kt)("inlineCode",{parentName:"p"},"openssl")," installed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ which openssl\n/usr/bin/openssl\n")),(0,i.kt)("p",null,"Then run:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"openssl genrsa -des3 -passout pass:x -out server.pass.key 2048\nopenssl rsa -passin pass:x -in server.pass.key -out server.key\nrm server.pass.key\nopenssl req -new -key server.key -out server.csr\n")),(0,i.kt)("p",null,"Set ",(0,i.kt)("inlineCode",{parentName:"p"},"localhost")," for Common Name when asked."),(0,i.kt)("p",null,"The self-signed TLS certificate generated from the ",(0,i.kt)("inlineCode",{parentName:"p"},"server.key")," private key and ",(0,i.kt)("inlineCode",{parentName:"p"},"server.csr")," files:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"openssl x509 -req -sha256 -days 365 -in server.csr -signkey server.key -out server.crt\n")),(0,i.kt)("p",null,"After these manipulations you should have ",(0,i.kt)("inlineCode",{parentName:"p"},"server.crt")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"server.key")," files in your working directory."),(0,i.kt)("p",null,"To help you with process here is my console output during these steps (click to open):"),(0,i.kt)("p",null,'??? example "My console output generating self-signed certificates"'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"```bash\n$ openssl genrsa -des3 -passout pass:x -out server.pass.key 2048\nGenerating RSA private key, 2048 bit long modulus\n...........................................................................................+++\n.....................+++\ne is 65537 (0x10001)\n\n$ ls\nserver.pass.key\n\n$ openssl rsa -passin pass:x -in server.pass.key -out server.key\nwriting RSA key\n\n$ ls\nserver.key      server.pass.key\n\n$ rm server.pass.key\n\n$ openssl req -new -key server.key -out server.csr\nYou are about to be asked to enter information that will be incorporated\ninto your certificate request.\nWhat you are about to enter is what is called a Distinguished Name or a DN.\nThere are quite a few fields but you can leave some blank\nFor some fields there will be a default value,\nIf you enter '.', the field will be left blank.\n-----\nCountry Name (2 letter code) []:RU\nState or Province Name (full name) []:\nLocality Name (eg, city) []:\nOrganization Name (eg, company) []:\nOrganizational Unit Name (eg, section) []:\nCommon Name (eg, fully qualified host name) []:localhost\nEmail Address []:\n\nPlease enter the following 'extra' attributes\nto be sent with your certificate request\nA challenge password []:\n\n$ openssl x509 -req -sha256 -days 365 -in server.csr -signkey server.key -out server.crt\nSignature ok\nsubject=/C=RU/CN=localhost\nGetting Private key\n\n$ ls\nserver.crt server.csr server.key\n``` \n")),(0,i.kt)("h2",{id:"run-client-example"},"Run client example"),(0,i.kt)("p",null,"Now the last step. What we need to do is run Chrome Canary with some flags that will allow it to trust our self-signed certificates. I suppose there is an alternative way making Chrome trust your certificates, but I have not tried it."),(0,i.kt)("p",null,"First let's find out a fingerprint of our cert:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"openssl x509 -in server.crt -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64\n")),(0,i.kt)("p",null,"In my case base64 fingerprint was ",(0,i.kt)("inlineCode",{parentName:"p"},"pe2P0fQwecKFMc6kz3+Y5MuVwVwEtGXyST5vJeaOO/M="),", yours will be different."),(0,i.kt)("p",null,"Then run Chrome Canary with some additional flags that will make it trust out certs (close other Chrome Canary instances before running it):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ /Applications/Google\\ Chrome\\ Canary.app/Contents/MacOS/Google\\ Chrome\\ Canary \\\n    --origin-to-force-quic-on=localhost:4433 \\\n    --ignore-certificate-errors-spki-list=pe2P0fQwecKFMc6kz3+Y5MuVwVwEtGXyST5vJeaOO/M=\n")),(0,i.kt)("p",null,"This example is for MacOS, for your system see ",(0,i.kt)("a",{parentName:"p",href:"https://www.chromium.org/developers/how-tos/run-chromium-with-flags"},"docs on how to run Chrome/Chromium with custom flags"),"."),(0,i.kt)("p",null,"Now you can open ",(0,i.kt)("a",{parentName:"p",href:"https://googlechrome.github.io/samples/quictransport/client.html"},"https://googlechrome.github.io/samples/quictransport/client.html")," URL in started browser and click ",(0,i.kt)("inlineCode",{parentName:"p"},"Connect")," button. What? Connection not established? OK, this is fine since we need to run our server :)"),(0,i.kt)("h2",{id:"writing-a-quic-server"},"Writing a QUIC server"),(0,i.kt)("p",null,"Maybe in future we will have libraries that are specified to work with WebTransport over QUIC or HTTP/3, but for now we should implement server manually. As said above we will use ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lucas-clemente/quic-go"},"github.com/lucas-clemente/quic-go")," library to do this."),(0,i.kt)("h3",{id:"server-skeleton"},"Server skeleton"),(0,i.kt)("p",null,"First, let's define a simple skeleton for our server:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "errors"\n    "log"\n\n    "github.com/lucas-clemente/quic-go"\n)\n\n// Config for WebTransportServerQuic.\ntype Config struct {\n    // ListenAddr sets an address to bind server to.\n    ListenAddr string\n    // TLSCertPath defines a path to .crt cert file.\n    TLSCertPath string\n    // TLSKeyPath defines a path to .key cert file\n    TLSKeyPath string\n    // AllowedOrigins represents list of allowed origins to connect from.\n    AllowedOrigins []string\n}\n\n// WebTransportServerQuic can handle WebTransport QUIC connections according\n// to https://tools.ietf.org/html/draft-vvv-webtransport-quic-02.\ntype WebTransportServerQuic struct {\n    config Config\n}\n\n// NewWebTransportServerQuic creates new WebTransportServerQuic.\nfunc NewWebTransportServerQuic(config Config) *WebTransportServerQuic {\n    return &WebTransportServerQuic{\n        config: config,\n    }\n}\n\n// Run server.\nfunc (s *WebTransportServerQuic) Run() error {\n    return errors.New("not implemented")\n}\n\nfunc main() {\n    server := NewWebTransportServerQuic(Config{\n        ListenAddr:     "0.0.0.0:4433",\n        TLSCertPath:    "server.crt",\n        TLSKeyPath:     "server.key",\n        AllowedOrigins: []string{"localhost", "googlechrome.github.io"},\n    })\n    if err := server.Run(); err != nil {\n        log.Fatal(err)\n    }\n}\n')),(0,i.kt)("h3",{id:"accept-quic-connections"},"Accept QUIC connections"),(0,i.kt)("p",null,"Let's concentrate on implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"Run")," method. We need to accept QUIC client connections. This can be done by creating ",(0,i.kt)("inlineCode",{parentName:"p"},"quic.Listener")," instance and using its ",(0,i.kt)("inlineCode",{parentName:"p"},".Accept")," method to accept incoming client sessions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// Run server.\nfunc (s *WebTransportServerQuic) Run() error {\n    listener, err := quic.ListenAddr(s.config.ListenAddr, s.generateTLSConfig(), nil)\n    if err != nil {\n        return err\n    }\n    for {\n        sess, err := listener.Accept(context.Background())\n        if err != nil {\n            return err\n        }\n        log.Printf("session accepted: %s", sess.RemoteAddr().String())\n        go func() {\n            defer func() {\n                _ = sess.CloseWithError(0, "bye")\n                log.Println("close session")\n            }()\n            s.handleSession(sess)\n        }()\n    }\n}\n\nfunc (s *WebTransportServerQuic) handleSession(sess quic.Session) {\n    // Not implemented yet.    \n}\n')),(0,i.kt)("p",null,"An interesting thing to note is that QUIC allows closing connection with specific application-level integer code and custom string reason. Just like WebSocket if you worked with it."),(0,i.kt)("p",null,"Also note, that we are starting our ",(0,i.kt)("inlineCode",{parentName:"p"},"Listener")," with TLS configuration returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"s.generateTLSConfig()")," method. Let's take a closer look at how this method can be implemented."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// https://tools.ietf.org/html/draft-vvv-webtransport-quic-02#section-3.1\nconst alpnQuicTransport = "wq-vvv-01"\n\nfunc (s *WebTransportServerQuic) generateTLSConfig() *tls.Config {\n    cert, err := tls.LoadX509KeyPair(s.config.TLSCertPath, s.config.TLSKeyPath)\n    if err != nil {\n        log.Fatal(err)\n    }\n    return &tls.Config{\n        Certificates: []tls.Certificate{cert},\n        NextProtos:   []string{alpnQuicTransport},\n    }\n}\n')),(0,i.kt)("p",null,"Inside ",(0,i.kt)("inlineCode",{parentName:"p"},"generateTLSConfig")," we load x509 certs from cert files generated above. WebTransport uses ALPN (",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation"},"Application-Layer Protocol Negotiation")," to prevent handshakes with a server that does not support WebTransport spec. This is just a string ",(0,i.kt)("inlineCode",{parentName:"p"},"wq-vvv-01")," inside ",(0,i.kt)("inlineCode",{parentName:"p"},"NextProtos")," slice of our ",(0,i.kt)("inlineCode",{parentName:"p"},"*tls.Config"),"."),(0,i.kt)("h3",{id:"connection-session-handling"},"Connection Session handling"),(0,i.kt)("p",null,"At this moment if you run a server and open a client example in Chrome then click ",(0,i.kt)("inlineCode",{parentName:"p"},"Connect")," button \u2013 you should see that connection successfully established in event log area:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/PyEr9W9.png",alt:"client example"})),(0,i.kt)("p",null,"Now if you try to send data to a server nothing will happen. That's because we have not implemented reading data from session streams. "),(0,i.kt)("p",null,"Streams in QUIC provide a lightweight, ordered byte-stream abstraction to an application. Streams can be unidirectional or bidirectional."),(0,i.kt)("p",null,"Streams can be short-lived, streams can also be long-lived and can last the entire duration of a connection."),(0,i.kt)("p",null,"Client example provides three possible ways to communicate with a server:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Send a datagram"),(0,i.kt)("li",{parentName:"ul"},"Open a unidirectional stream"),(0,i.kt)("li",{parentName:"ul"},"Open a bidirectional stream")),(0,i.kt)("p",null,"Unfortunately, ",(0,i.kt)("inlineCode",{parentName:"p"},"quic-go")," library does not support sending UDP datagrams at this moment. To do this ",(0,i.kt)("inlineCode",{parentName:"p"},"quic-go")," should implement one more draft called ",(0,i.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/draft-pauly-quic-datagram-05"},"An Unreliable Datagram Extension to QUIC"),". There is already ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lucas-clemente/quic-go/pull/2162"},"an ongoing pull request")," that implements it. This means that it's too early for us to experiment with unreliable UDP WebTransport client-server communication in Go. By the way, the interesting facts about UDP over QUIC are that QUIC congestion control mechanism will ",(0,i.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/draft-ietf-quic-datagram-00#section-5.3"},"still apply")," and QUIC datagrams ",(0,i.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/draft-ietf-quic-datagram-00#section-5.1"},"can support acknowledgements"),"."),(0,i.kt)("p",null,"Implementing a unidirectional stream is possible with ",(0,i.kt)("inlineCode",{parentName:"p"},"quic-go")," since the library supports creating and accepting unidirectional streams, but I'll leave this for a reader (though we will need accepting one unidirectional stream for parsing client indication anyway \u2013 see below)."),(0,i.kt)("p",null,"Here we will only concentrate on implementing a server for a bidirectional case. We are in the Centrifugo blog, and this is the most interesting type of stream for me personally."),(0,i.kt)("h3",{id:"parsing-client-indication"},"Parsing client indication"),(0,i.kt)("p",null,"According to ",(0,i.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/draft-vvv-webtransport-quic-02#section-3.2"},"section-3.2")," of Quic WebTransport spec in order to verify that the client's origin allowed connecting to the server, the user agent has to communicate the origin to the server. This is accomplished by sending a special message, called client indication, on stream 2, which is the first client-initiated unidirectional stream."),(0,i.kt)("p",null,"Here we will implement this. In the beginning of our session handler we will accept a unidirectional stream initiated by a client."),(0,i.kt)("p",null,"At moment spec defines two client indication keys: ",(0,i.kt)("inlineCode",{parentName:"p"},"Origin")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Path"),". In our case an origin value will be ",(0,i.kt)("inlineCode",{parentName:"p"},"https://googlechrome.github.io")," and path will be ",(0,i.kt)("inlineCode",{parentName:"p"},"/counter"),"."),(0,i.kt)("p",null,"Let's define some constants and structures:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"// client indication stream can not exceed 65535 bytes in length.\n// https://tools.ietf.org/html/draft-vvv-webtransport-quic-02#section-3.2\nconst maxClientIndicationLength = 65535\n\n// define known client indication keys.\ntype clientIndicationKey int16\n\nconst (\n    clientIndicationKeyOrigin clientIndicationKey = 0\n    clientIndicationKeyPath                       = 1\n)\n\n// ClientIndication container.\ntype ClientIndication struct {\n    // Origin client indication value.\n    Origin string\n    // Path client indication value.\n    Path string\n}\n")),(0,i.kt)("p",null,"Now what we should do is accept unidirectional stream inside session handler:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'func (s *WebTransportServerQuic) handleSession(sess quic.Session) {\n    stream, err := sess.AcceptUniStream(context.Background())\n    if err != nil {\n        log.Println(err)\n        return\n    }\n    log.Printf("uni stream accepted, id: %d", stream.StreamID())\n\n    indication, err := receiveClientIndication(stream)\n    if err != nil {\n        log.Println(err)\n        return\n    }\n    log.Printf("client indication: %+v", indication)\n\n    if err := s.validateClientIndication(indication); err != nil {\n        log.Println(err)\n        return\n    }\n\n    // this method blocks.\n    if err := s.communicate(sess); err != nil {\n        log.Println(err)\n    }\n}\n\nfunc receiveClientIndication(stream quic.ReceiveStream) (ClientIndication, error) {\n    return ClientIndication{}, errors.New("not implemented yet")\n}\n\nfunc (s *WebTransportServerQuic) validateClientIndication(indication ClientIndication) error {\n    return errors.New("not implemented yet")\n}\n\nfunc (s *WebTransportServerQuic) communicate(sess quic.Session) error {\n    return errors.New("not implemented yet")\n}\n')),(0,i.kt)("p",null,"As you can see to accept a unidirectional stream with data we can use ",(0,i.kt)("inlineCode",{parentName:"p"},".AcceptUniStream")," method of ",(0,i.kt)("inlineCode",{parentName:"p"},"quic.Session"),". After accepting a stream we should read client indication data from it. "),(0,i.kt)("p",null,"According to spec it will contain a client indication in the following format:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Key (16)            |          Length (16)          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Value (*)                         ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n")),(0,i.kt)("p",null,"The code below parses client indication out of a stream data, we decode key-value pairs from uni stream until an end of stream (indicated by EOF):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'func receiveClientIndication(stream quic.ReceiveStream) (ClientIndication, error) {\n    var clientIndication ClientIndication\n\n    // read no more than maxClientIndicationLength bytes.\n    reader := io.LimitReader(stream, maxClientIndicationLength)\n\n    done := false\n\n    for {\n        if done {\n            break\n        }\n        var key int16\n        err := binary.Read(reader, binary.BigEndian, &key)\n        if err != nil {\n            if err == io.EOF {\n                done = true\n            } else {\n                return clientIndication, err\n            }\n        }\n        var valueLength int16\n        err = binary.Read(reader, binary.BigEndian, &valueLength)\n        if err != nil {\n            return clientIndication, err\n        }\n        buf := make([]byte, valueLength)\n        n, err := reader.Read(buf)\n        if err != nil {\n            if err == io.EOF {\n                // still need to process indication value.\n                done = true\n            } else {\n                return clientIndication, err\n            }\n        }\n        if int16(n) != valueLength {\n            return clientIndication, errors.New("read less than expected")\n        }\n        value := string(buf)\n\n        switch clientIndicationKey(key) {\n        case clientIndicationKeyOrigin:\n            clientIndication.Origin = value\n        case clientIndicationKeyPath:\n            clientIndication.Path = value\n        default:\n            log.Printf("skip unknown client indication key: %d: %s", key, value)\n        }\n    }\n    return clientIndication, nil\n}\n')),(0,i.kt)("p",null,"We also validate Origin inside ",(0,i.kt)("inlineCode",{parentName:"p"},"validateClientIndication")," method of our server:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'var errBadOrigin = errors.New("bad origin")\n\nfunc (s *WebTransportServerQuic) validateClientIndication(indication ClientIndication) error {\n    u, err := url.Parse(indication.Origin)\n    if err != nil {\n        return errBadOrigin\n    }\n    if !stringInSlice(u.Host, s.config.AllowedOrigins) {\n        return errBadOrigin\n    }\n    return nil\n}\n\nfunc stringInSlice(a string, list []string) bool {\n    for _, b := range list {\n        if b == a {\n            return true\n        }\n    }\n    return false\n}\n')),(0,i.kt)("p",null,"Do you have ",(0,i.kt)("inlineCode",{parentName:"p"},"stringInSlice")," function in every Go project? I do :)"),(0,i.kt)("h3",{id:"communicating-over-bidirectional-streams"},"Communicating over bidirectional streams"),(0,i.kt)("p",null,"The final part here is accepting a bidirectional stream from a client, reading it, and sending responses back. Here we will just echo everything a client sends to a server back to a client. You can implement whatever bidirectional communication you want actually."),(0,i.kt)("p",null,"Very similar to unidirectional case we can call ",(0,i.kt)("inlineCode",{parentName:"p"},".AcceptStream")," method of session to accept a bidirectional stream."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'func (s *WebTransportServerQuic) communicate(sess quic.Session) error {\n    for {\n        stream, err := sess.AcceptStream(context.Background())\n        if err != nil {\n            return err\n        }\n        log.Printf("stream accepted: %d", stream.StreamID())\n        if _, err := io.Copy(stream, stream); err != nil {\n            return err\n        }\n    }\n}\n')),(0,i.kt)("p",null,"When you press ",(0,i.kt)("inlineCode",{parentName:"p"},"Send")," button in client example it creates a bidirectional stream, sends data to it, then closes stream. Thus our code is sufficient. For a more complex communication that involves many concurrent streams you will have to write a more complex code that allows working with streams concurrently on server side."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/5299Vr4.png",alt:"client example"})),(0,i.kt)("h3",{id:"full-server-example"},"Full server example"),(0,i.kt)("p",null,"Full server code can be found ",(0,i.kt)("a",{parentName:"p",href:"https://gist.github.com/FZambia/07dca3a7a75a264746101cd5657f1150"},"in a Gist"),". Again \u2013 this is a toy example based on things that all work in progress."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"WebTransport is an interesting technology that can open new possibilities in modern Web development. At this moment it's possible to play with it using QUIC transport \u2013 here we looked at how one can do that. Though we still have to wait a bit until all these things will be suitable for production usage."),(0,i.kt)("p",null,"Also, even when ready we will still have to think about WebTransport fallback options \u2013 since wide adoption of browsers that support some new technology and infrastructure takes time. Actually WebTransport spec authors consider fallback options in design. This was mentioned in IETF slides (",(0,i.kt)("a",{parentName:"p",href:"https://www.ietf.org/proceedings/106/slides/slides-106-webtrans-webtrans-bof-slides-03"},"PDF, 2.6MB"),"), but I have not found any additional information beyond that."),(0,i.kt)("p",null,"Personally, I think the most exciting thing about WebTransport is the possibility to exchange UDP datagrams, which can help a lot to in-browser gaming. Unfortunately, we can't test it at this moment with Go (but it's already possible using Python as server as shown ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/GoogleChrome/samples/blob/gh-pages/quictransport/quic_transport_server.py"},"in the example"),")."),(0,i.kt)("p",null,"WebTransport could be a nice candidate for a new Centrifugo transport next to WebSocket and SockJS \u2013 time will show."))}u.isMDXComponent=!0},3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(t),m=i,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||a;return t?r.createElement(h,o(o({ref:n},p),{},{components:t})):r.createElement(h,o({ref:n},p))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,o=new Array(a);o[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<a;c++)o[c]=t[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);