"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[5358],{42462:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var t=i(85893),o=i(11151);const s={id:"highlights",title:"Main highlights"},r=void 0,a={id:"getting-started/highlights",title:"Main highlights",description:"At this point, you know how to build the simplest real-time app with Centrifugo. Beyond the core PUB/SUB functionality, Centrifugo provides more features and primitives to build scalable real-time applications. Let's summarize the main Centrifugo \u2728highlights\u2728 here. Every point is then extended throughout the documentation.",source:"@site/docs/getting-started/highlights.md",sourceDirName:"getting-started",slug:"/getting-started/highlights",permalink:"/docs/getting-started/highlights",draft:!1,unlisted:!1,editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/docs/getting-started/highlights.md",tags:[],version:"current",frontMatter:{id:"highlights",title:"Main highlights"},sidebar:"Introduction",previous:{title:"Quickstart tutorial",permalink:"/docs/getting-started/quickstart"},next:{title:"Integration guide",permalink:"/docs/getting-started/integration"}},c={},l=[{value:"Seamless integration",id:"seamless-integration",level:3},{value:"Great performance",id:"great-performance",level:3},{value:"Built-in scalability",id:"built-in-scalability",level:3},{value:"Strict client protocol",id:"strict-client-protocol",level:3},{value:"Variety of real-time transports",id:"variety-of-real-time-transports",level:3},{value:"Flexible authentication",id:"flexible-authentication",level:3},{value:"Connection management",id:"connection-management",level:3},{value:"Channel (room) concept",id:"channel-room-concept",level:3},{value:"Different types of subscriptions",id:"different-types-of-subscriptions",level:3},{value:"Message history in channels",id:"message-history-in-channels",level:3},{value:"Delta compression",id:"delta-compression",level:3},{value:"RPC over bidirectional connection",id:"rpc-over-bidirectional-connection",level:3},{value:"Online presence information",id:"online-presence-information",level:3},{value:"Embedded admin web UI",id:"embedded-admin-web-ui",level:3},{value:"Cross-platform",id:"cross-platform",level:3},{value:"Ready to deploy",id:"ready-to-deploy",level:3},{value:"Open-source",id:"open-source",level:3},{value:"PRO features",id:"pro-features",level:3}];function d(e){const n={a:"a",h3:"h3",li:"li",p:"p",ul:"ul",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"At this point, you know how to build the simplest real-time app with Centrifugo. Beyond the core PUB/SUB functionality, Centrifugo provides more features and primitives to build scalable real-time applications. Let's summarize the main Centrifugo \u2728highlights\u2728 here. Every point is then extended throughout the documentation."}),"\n",(0,t.jsx)(n.h3,{id:"seamless-integration",children:"Seamless integration"}),"\n",(0,t.jsx)(n.p,{children:"Centrifugo was originally designed to be used in conjunction with frameworks without built-in concurrency support (like Django, Laravel, etc.)."}),"\n",(0,t.jsxs)(n.p,{children:["It works as a standalone service with well-defined communication contracts. It nicely fits both monolithic and microservice architectures. Application developers should not change the backend philosophy and technology stack at all \u2013 just integrate with Centrifugo ",(0,t.jsx)(n.a,{href:"/docs/server/server_api",children:"HTTP or GRPC API"})," and let users enjoy real-time updates."]}),"\n",(0,t.jsx)(n.h3,{id:"great-performance",children:"Great performance"}),"\n",(0,t.jsx)(n.p,{children:"Centrifugo is fast. It's written in the Go language, built on top of fast and battle-tested open-source libraries, has some smart internal optimizations like message queuing on broadcasts, smart batching to reduce the number of RTTs with the broker, connection hub sharding to avoid lock contention, JSON and Protobuf encoding speedups through code generation, and others."}),"\n",(0,t.jsxs)(n.p,{children:["See the ",(0,t.jsx)(n.a,{href:"/blog/2020/02/10/million-connections-with-centrifugo",children:"Million WebSocket with Centrifugo"})," post on our blog to see some real-world numbers."]}),"\n",(0,t.jsx)(n.h3,{id:"built-in-scalability",children:"Built-in scalability"}),"\n",(0,t.jsx)(n.p,{children:"Centrifugo scales well to many machines with the help of PUB/SUB brokers. So as soon as you have more client connections in the application \u2013 you can spread them over different Centrifugo nodes which will be connected together into a cluster."}),"\n",(0,t.jsx)(n.p,{children:"The main PUB/SUB engine that Centrifugo integrates with is Redis. It supports client-side consistent sharding and Redis Cluster \u2013 so a single Redis instance won't be a bottleneck either."}),"\n",(0,t.jsxs)(n.p,{children:["There are other options to scale: KeyDB, Nats, Tarantool. ",(0,t.jsx)(n.a,{href:"/docs/server/engines",children:"See docs about available engines"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"strict-client-protocol",children:"Strict client protocol"}),"\n",(0,t.jsxs)(n.p,{children:["Centrifugo supports JSON and binary Protobuf protocols for client-server communication. The bidirectional protocol is defined by a strict schema and several ready-to-use SDKs wrap this protocol, handle asynchronous message passing, timeouts, reconnects, and various Centrifugo client API features. See detailed information about client real-time transports in a ",(0,t.jsx)(n.a,{href:"/docs/transports/overview",children:"dedicated section"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"variety-of-real-time-transports",children:"Variety of real-time transports"}),"\n",(0,t.jsx)(n.p,{children:"The main transport in Centrifugo is WebSocket. For web browsers with non-working WebSocket connection, Centrifugo provides its own bidirectional WebSocket emulation layer based on HTTP-streaming (using Fetch and Readable streams browser APIs) and SSE (EventSource). Additionally, WebTransport is supported in an experimental form."}),"\n",(0,t.jsx)(n.p,{children:"In addition to bidirectional transports, Centrifugo also supports a unidirectional approach for real-time updates: using SSE (EventSource), HTTP-streaming, and GRPC unidirectional stream. Utilizing a unidirectional transport is sufficient for many real-time applications and does not require using our client SDKs \u2013 just native standards or GRPC-generated code."}),"\n",(0,t.jsxs)(n.p,{children:["See detailed information about client real-time transports in a ",(0,t.jsx)(n.a,{href:"/docs/transports/overview",children:"dedicated section"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"flexible-authentication",children:"Flexible authentication"}),"\n",(0,t.jsxs)(n.p,{children:["Centrifugo can authenticate connections by checking ",(0,t.jsx)(n.a,{href:"/docs/server/authentication",children:"JWT (JSON Web Token)"})," or by ",(0,t.jsx)(n.a,{href:"/docs/server/proxy",children:"issuing an HTTP/GRPC"})," request to your application backend upon a client connection to Centrifugo. It's possible to proxy original request headers or request metadata (in the case of a GRPC connection)."]}),"\n",(0,t.jsxs)(n.p,{children:["It supports the ",(0,t.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/rfc7517",children:"JWK specification"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"connection-management",children:"Connection management"}),"\n",(0,t.jsx)(n.p,{children:"Connections can expire; developers can choose a way to handle connection refresh \u2013 using a client-side refresh workflow or a server-side call from Centrifugo to the application backend. Centrifugo provides APIs to disconnect users, unsubscribe users from channels, and inspect active channels. On the client side our SDKs automatically handle reconnections with backoff strategy, and even re-subscriptions with backoff to not disrupt the entire connection on individual subscription request temporary failure."}),"\n",(0,t.jsx)(n.h3,{id:"channel-room-concept",children:"Channel (room) concept"}),"\n",(0,t.jsxs)(n.p,{children:["Centrifugo is a PUB/SUB server \u2013 users subscribe to ",(0,t.jsx)(n.a,{href:"/docs/server/channels",children:"channels"})," to receive real-time updates. A message sent to a channel is delivered to all online channel subscribers."]}),"\n",(0,t.jsx)(n.h3,{id:"different-types-of-subscriptions",children:"Different types of subscriptions"}),"\n",(0,t.jsxs)(n.p,{children:["Centrifugo supports client-side (initiated by the client) and ",(0,t.jsx)(n.a,{href:"/docs/server/server_subs",children:"server-side"})," (forced by the server) channel subscriptions."]}),"\n",(0,t.jsx)(n.h3,{id:"message-history-in-channels",children:"Message history in channels"}),"\n",(0,t.jsxs)(n.p,{children:["Optionally, Centrifugo allows turning on history for publications in channels. This publication history has a limited size and retention period (TTL). With channel history, Centrifugo can help to survive the mass reconnect scenario \u2013 clients can automatically catch up on missed state from a fast cache thus reducing the load on your primary database. It's also possible to manually iterate over a history stream from the client or from the application backend side. See ",(0,t.jsx)(n.a,{href:"/docs/server/history_and_recovery",children:"history and recovery"})," and also a special ",(0,t.jsx)(n.a,{href:"/docs/server/cache_recovery",children:"cache recovery mode"})," which allows using Centrifugo as a real-time key-value cache."]}),"\n",(0,t.jsx)(n.h3,{id:"delta-compression",children:"Delta compression"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"/docs/server/delta_compression",children:"Delta compression"})," feature may help reducing bandwidth costs significantly if you publish similar messages."]}),"\n",(0,t.jsx)(n.h3,{id:"rpc-over-bidirectional-connection",children:"RPC over bidirectional connection"}),"\n",(0,t.jsx)(n.p,{children:"You can fully utilize bidirectional connections by sending RPC calls from the client-side to a configured endpoint on your backend. Calling RPC over WebSocket avoids sending headers on each request \u2013 thus reducing incoming traffic."}),"\n",(0,t.jsx)(n.h3,{id:"online-presence-information",children:"Online presence information"}),"\n",(0,t.jsx)(n.p,{children:"The online presence feature for channels provides information about active channel subscribers. Also, channel join and leave events (when someone subscribes/unsubscribes) can be received on the client side."}),"\n",(0,t.jsx)(n.h3,{id:"embedded-admin-web-ui",children:"Embedded admin web UI"}),"\n",(0,t.jsxs)(n.p,{children:["The built-in ",(0,t.jsx)(n.a,{href:"/docs/server/admin_web",children:"admin UI"})," allows publishing messages to channels, looking at Centrifugo cluster information, and more."]}),"\n",(0,t.jsx)(n.h3,{id:"cross-platform",children:"Cross-platform"}),"\n",(0,t.jsx)(n.p,{children:"Centrifugo works on Linux, MacOS, and Windows."}),"\n",(0,t.jsx)(n.h3,{id:"ready-to-deploy",children:"Ready to deploy"}),"\n",(0,t.jsxs)(n.p,{children:["Centrifugo supports various deployment methods: in Docker, using prepared RPM or DEB packages, via a Kubernetes Helm chart. It supports automatic TLS with Let's Encrypt TLS, outputs Prometheus/Graphite metrics, and has an official Grafana dashboard for the Prometheus data source - read more about ",(0,t.jsx)(n.a,{href:"/docs/server/observability",children:"observability"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"open-source",children:"Open-source"}),"\n",(0,t.jsxs)(n.p,{children:["Centrifugo stands on top of the open-source library ",(0,t.jsx)(n.a,{href:"https://github.com/centrifugal/centrifuge",children:"Centrifuge"})," (MIT license). The OSS version of Centrifugo is based on the permissive open-source license (Apache 2.0). All our official client SDKs and API libraries are MIT-licensed."]}),"\n",(0,t.jsx)(n.h3,{id:"pro-features",children:"PRO features"}),"\n",(0,t.jsx)(n.p,{children:"Centrifugo PRO extends Centrifugo with several unique features which can provide interesting advantages for business adopters. Some amazing features include into PRO version:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"push notifications API \u2013 to send mobile and browser pushes over FCM, APNs, HMS"}),"\n",(0,t.jsx)(n.li,{children:"real-time analytics with ClickHouse for more insights about your real-time ecosystem"}),"\n",(0,t.jsx)(n.li,{children:"performance optimizations to reduce resource usage and thus reducing overall costs"}),"\n",(0,t.jsxs)(n.li,{children:["many more, refer to the ",(0,t.jsx)(n.a,{href:"/docs/pro/overview",children:"Centrifugo PRO documentation"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>r});var t=i(67294);const o={},s=t.createContext(o);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);