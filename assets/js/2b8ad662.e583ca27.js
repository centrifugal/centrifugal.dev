"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[6764],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>c});var s=i(96540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},46372:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"transports/uni_client_protocol","title":"Unidirectional client protocol","description":"As mentioned earlier, you can bypass the need for Centrifugo bidirectional real-time SDKs by opting for the unidirectional approach. By using unidirectional Centrifugo transports, you can harness the power of native browser APIs while still benefiting of Centrifugo features, including efficient subscription multiplexing, scalability, a ready-to-use publication API, and more. This approach allows you to introduce real-time features with minimal dependencies on the client side, still having scalable and efficient real-time backend.","source":"@site/docs/transports/uni_client_protocol.md","sourceDirName":"transports","slug":"/transports/uni_client_protocol","permalink":"/docs/transports/uni_client_protocol","draft":false,"unlisted":false,"editUrl":"https://github.com/centrifugal/centrifugal.dev/edit/main/docs/transports/uni_client_protocol.md","tags":[],"version":"current","frontMatter":{"id":"uni_client_protocol","title":"Unidirectional client protocol","sidebar_label":"Unidirectional protocol"},"sidebar":"Transports","previous":{"title":"Client protocol","permalink":"/docs/transports/client_protocol"},"next":{"title":"WebSocket","permalink":"/docs/transports/uni_websocket"}}');var t=i(74848),r=i(28453);const o={id:"uni_client_protocol",title:"Unidirectional client protocol",sidebar_label:"Unidirectional protocol"},c=void 0,l={},d=[{value:"How to connect",id:"how-to-connect",level:2},{value:"Connection endpoint",id:"connection-endpoint",level:3},{value:"ConnectRequest",id:"connectrequest",level:3},{value:"SubscribeRequest",id:"subscriberequest",level:3},{value:"Unidirectional pushes",id:"unidirectional-pushes",level:2},{value:"connect",id:"connect",level:3},{value:"publication",id:"publication",level:3},{value:"join",id:"join",level:3},{value:"leave",id:"leave",level:3},{value:"disconnect",id:"disconnect",level:3},{value:"unsubscribe",id:"unsubscribe",level:3},{value:"subscribe",id:"subscribe",level:3},{value:"refresh",id:"refresh",level:3},{value:"ping",id:"ping",level:3}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["As mentioned earlier, you can bypass the need for Centrifugo bidirectional real-time SDKs by opting for the ",(0,t.jsx)(n.a,{href:"/docs/transports/overview#unidirectional",children:"unidirectional approach"}),". By using unidirectional Centrifugo transports, you can harness the power of native browser APIs while still benefiting of Centrifugo features, including efficient subscription multiplexing, scalability, a ready-to-use publication API, and more. This approach allows you to introduce real-time features with minimal dependencies on the client side, still having scalable and efficient real-time backend."]}),"\n",(0,t.jsx)(n.p,{children:"By sticking with the unidirectional approach, you'll need to implement some basic parsing on the client side to handle the message types sent by Centrifugo over unidirectional connections."}),"\n",(0,t.jsx)(n.p,{children:"Currently, Centrifugo supports unidirectional transports including WebSocket, HTTP streaming, Server-Sent Events (EventSource), and gRPC. All of these share the same protocol structure, ensuring consistency across different transport methods."}),"\n",(0,t.jsx)(n.p,{children:"First of all let's look at possible unidirectional transport session (in this example HTTP-streaming) with Centrifugo to show the simplicity and look at general structure before diving into the details."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'\u276f curl -X POST http://localhost:8000/connection/uni_http_stream -d \'{}\'\n{"connect":{"client":"bb56837...","version":"0.0.0 OSS","subs":{"#2694":{}},"ping":25,"session":"3159c4f8..."}}\n{"channel":"#2694","join":{"info":{"user":"2694","client":"bb56837e-5b93-4478-95b6-98f3d2269b29"}}}\n{"channel":"#2694","pub":{"data":{"input":1}}}\n{}\n{"channel":"#2694","pub":{"data":{"input":2}}}\n{"channel":"#2694","pub":{"data":{"input":3}}}\n{"disconnect":{"code":3001,"reason":"shutdown"}}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"how-to-connect",children:"How to connect"}),"\n",(0,t.jsx)(n.p,{children:"Each unidirectional transport must be explicitly enabled in Centrifugo configuration. Once enabled, you can connect using it."}),"\n",(0,t.jsx)(n.p,{children:"For example, to enable unidirectional SSE transport you need to add the following to your Centrifugo configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "uni_sse": {\n    "enabled": true\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Or, for unidirectional HTTP-streaming transport:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "uni_http_stream": {\n    "enabled": true\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"connection-endpoint",children:"Connection endpoint"}),"\n",(0,t.jsx)(n.p,{children:"For establishing the unidirectional connection, you need to use the appropriate transport endpoint, pass connection request payload, and then handle incoming push messages."}),"\n",(0,t.jsx)(n.p,{children:"The exact endpoint to connect varies depending on the transport you choose, you can find default in the documentation for a specific transport:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/transports/uni_websocket",children:"Unidirectional WebSocket"})," - ",(0,t.jsx)(n.code,{children:"/connection/uni_websocket"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/transports/uni_http_stream",children:"Unidirectional HTTP streaming"})," - ",(0,t.jsx)(n.code,{children:"/connection/uni_http_stream"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/transports/uni_sse",children:"Unidirectional Server-Sent Events (EventSource)"})," - ",(0,t.jsx)(n.code,{children:"/connection/uni_sse"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/transports/uni_grpc",children:"Unidirectional gRPC"})," - uses custom GRPC server and port to connect."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Upon connection, you can pass initial connection payload to Centrifugo. The way you send it varies for different unidirectional transports.  But generally the connect request structure is the same and is defined in ",(0,t.jsx)(n.a,{href:"https://github.com/centrifugal/protocol/blob/master/definitions/client.proto",children:"Centrifugo protocol Protobuf schema"})," - see ",(0,t.jsx)(n.code,{children:"ConnectRequest"})," message type. Let's describe it in more detail in relation to unidirectional transports."]}),"\n",(0,t.jsx)(n.h3,{id:"connectrequest",children:"ConnectRequest"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Field name"}),(0,t.jsx)(n.th,{children:"Field type"}),(0,t.jsx)(n.th,{children:"Required"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"token"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"string"})}),(0,t.jsx)(n.td,{children:"no"}),(0,t.jsx)(n.td,{children:"Connection JWT, not needed when using the connect proxy feature."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"data"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bytes"})}),(0,t.jsx)(n.td,{children:"no"}),(0,t.jsx)(n.td,{children:"Custom connection data (for JSON protocol just embed JSON object here)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"name"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"string"})}),(0,t.jsx)(n.td,{children:"no"}),(0,t.jsx)(n.td,{children:"Application name"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"version"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"string"})}),(0,t.jsx)(n.td,{children:"no"}),(0,t.jsx)(n.td,{children:"Application version"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"subs"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"map[string]SubscribeRequest"})}),(0,t.jsx)(n.td,{children:"no"}),(0,t.jsx)(n.td,{children:"Pass an information about desired subscriptions to a server"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"headers"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"map[string]string"})}),(0,t.jsx)(n.td,{children:"no"}),(0,t.jsx)(n.td,{children:"Headers for Headers Emulation feature (may be transformed by Centrifugo into proxy request HTTP headers)"})]})]})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/transports/uni_websocket",children:"Unidirectional WebSocket"})," - send as first WebSocket message to a server"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/transports/uni_http_stream",children:"Unidirectional HTTP streaming"})," - send as JSON body of HTTP-streaming POST request"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/transports/uni_sse",children:"Unidirectional Server-Sent Events (EventSource)"})," - send in URL parameter ",(0,t.jsx)(n.code,{children:"cf_connect"})," (also possible in JSON body of POST request \u2013 but web browsers do not allow that)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/transports/uni_grpc",children:"Unidirectional gRPC"})," - send as a part of gRPC unidirectional connect request."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"See more details in the corresponding transport documentation."}),"\n",(0,t.jsx)(n.p,{children:"For example, for HTTP-streaming transport you can send connect command as a JSON body of a POST request:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'curl -X POST http://localhost:8000/connection/uni_http_stream -d \'{"token": "<JWT>"}\'\n'})}),"\n",(0,t.jsx)(n.h3,{id:"subscriberequest",children:"SubscribeRequest"}),"\n",(0,t.jsxs)(n.p,{children:["Describes an object client may pass to the server for each desired channel in ",(0,t.jsx)(n.code,{children:"subs"})," map \u2013 to give server some hints about how to handle the subscription."]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Field name"}),(0,t.jsx)(n.th,{children:"Field type"}),(0,t.jsx)(n.th,{children:"Required"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"recover"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{children:"no"}),(0,t.jsx)(n.td,{children:"Whether a client wants to recover from a certain position"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"offset"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"integer"})}),(0,t.jsx)(n.td,{children:"no"}),(0,t.jsxs)(n.td,{children:["Known stream position offset when ",(0,t.jsx)(n.code,{children:"recover"})," is used"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"epoch"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"string"})}),(0,t.jsx)(n.td,{children:"no"}),(0,t.jsxs)(n.td,{children:["Known stream position epoch when ",(0,t.jsx)(n.code,{children:"recover"})," is used"]})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"Example for HTTP-streaming:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'curl -X POST http://localhost:8000/connection/uni_http_stream -d \\\n  \'{"token": "<JWT>", "subs": {"user#2694": {"recover": true, "offset": 12, "epoch": "xD5R"}}}\'\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Note, that Centrifugo won't simply accept subscriptions from ",(0,t.jsx)(n.code,{children:"subs"})," \u2013 only if current client connection has access to subscribe to them. Following ",(0,t.jsx)(n.a,{href:"/docs/server/channel_permissions",children:"the channel permission model"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"unidirectional-pushes",children:"Unidirectional pushes"}),"\n",(0,t.jsxs)(n.p,{children:["Once unidirectional connection is established, Centrifugo will send ",(0,t.jsx)(n.code,{children:"Push"})," frames over the connection. The structure of those ",(0,t.jsx)(n.code,{children:"Push"})," frames is defined in the ",(0,t.jsx)(n.a,{href:"https://github.com/centrifugal/protocol/blob/master/definitions/client.proto",children:"client protocol schema"}),", meaning Centrifugo leverages a portion of its bidirectional protocol for unidirectional communication. In bidirectional protocol Centrifugo uses ",(0,t.jsx)(n.code,{children:"Command"})," and ",(0,t.jsx)(n.code,{children:"Reply"})," messages on top level, and when sending asynchronous real-time messages it sends ",(0,t.jsx)(n.code,{children:"Reply"})," message with ",(0,t.jsx)(n.code,{children:"push"})," field (of ",(0,t.jsx)(n.code,{children:"Push"})," type). In unidirectional case command-reply pattern is not possible, so Centrifugo just always sends ",(0,t.jsx)(n.code,{children:"Push"})," types over the connection."]}),"\n",(0,t.jsxs)(n.p,{children:["This is how a ",(0,t.jsx)(n.code,{children:"Push"})," message is defined in the schema:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"message Push {\n  string channel = 2;\n\n  Publication pub = 4;\n  Join join = 5;\n  Leave leave = 6;\n  Unsubscribe unsubscribe = 7;\n  Message message = 8;\n  Subscribe subscribe = 9;\n  Connect connect = 10;\n  Disconnect disconnect = 11;\n  Refresh refresh = 12;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Every push contains ",(0,t.jsx)(n.strong,{children:"one of"})," the following fields with object corresponding to a type from Protobuf schema:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"connect"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"pub"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"join"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"leave"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"disconnect"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"unsubscribe"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"subscribe"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"refresh"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Some push messages sent (like publication) belong to a ",(0,t.jsx)(n.code,{children:"channel"})," which may be set on ",(0,t.jsx)(n.code,{children:"Push"})," top level. Pushes without any mentioned field and without ",(0,t.jsx)(n.code,{children:"channel"})," are periodic pings from server."]}),"\n",(0,t.jsxs)(n.p,{children:["All you need to do on the client side is look at received ",(0,t.jsx)(n.code,{children:"Push"}),", process messages you are interested in and ignore others. In most cases you will be most interested in pushes which contain ",(0,t.jsx)(n.code,{children:"connect"})," or ",(0,t.jsx)(n.code,{children:"pub"})," (publication)."]}),"\n",(0,t.jsx)(n.p,{children:"Some pseudocode you can use to process push messages:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const onMessage = (message) => {\n    const push = JSON.parse(message);\n    if (push.connect) {\n        // handle connect push.\n    } else if (push.pub) {\n        // handle publication push.\n    } else if (Object.keys(push).length === 0) {\n        // handle ping push.\n    } else {\n        // Ignore other pushes.\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Just try using any unidirectional transport and you will quickly get the idea."}),"\n",(0,t.jsx)(n.h3,{id:"connect",children:"connect"}),"\n",(0,t.jsxs)(n.p,{children:["Immediately after the unidirectional connection successfully established Centrifugo sends ",(0,t.jsx)(n.code,{children:"connect"})," Push frame."]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "connect":{\n    "client":"5c5b6011-b282-447d-8753-cee7269117e6",\n    "version":"0.0.0 OSS",\n    "subs":{\n      "personal:user#2694": {\n        "recoverable":true,\n        "offset": 12,\n        "epoch":"BXLK",\n        "positioned":true\n      },\n      "global": {}\n    },\n    "ping":25,\n    "session":"631a6f6e-02bc-473b-908f-8059a680e74c"\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"It contains information about client identifier, established server-side subscriptions (with pos), ping and session identifier information."}),"\n",(0,t.jsx)(n.h3,{id:"publication",children:"publication"}),"\n",(0,t.jsxs)(n.p,{children:["If something was published to the channel the unidirectional connection will receive ",(0,t.jsx)(n.code,{children:"pub"})," Push."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "channel":"test",\n  "pub": {\n    "data":{"input":1},\n    "offset":1\n  }\n}\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["Note, in Protobuf schema ",(0,t.jsx)(n.code,{children:"data"})," field of ",(0,t.jsx)(n.code,{children:"Publication"})," message is represented by ",(0,t.jsx)(n.code,{children:"bytes"})," type, but for JSON protocol case Centrifugo injects JSON (which is actually a sequence of bytes)."]})}),"\n",(0,t.jsx)(n.h3,{id:"join",children:"join"}),"\n",(0,t.jsx)(n.p,{children:"Sent if a channel has join/leave features enabled and someone joins (subscribes) to a channel."}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "channel":"#2694",\n  "join":{\n    "info":{"user":"2694","client":"99288691-e378-4a03-a34d-bf2c0dab6b51"}\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"leave",children:"leave"}),"\n",(0,t.jsx)(n.p,{children:"Sent if a channel has join/leave features enabled and someone leaves (unsubscribes) a channel."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "channel":"#2694",\n  "leave":{\n    "info":{"user":"2694","client":"99288691-e378-4a03-a34d-bf2c0dab6b51"}\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"disconnect",children:"disconnect"}),"\n",(0,t.jsx)(n.p,{children:"When connection can't be established or is closed by a server for some reason. Connection is closed by a server after sending this message."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "disconnect":{\n    "code":3004,\n    "reason":"internal server error"\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"unsubscribe",children:"unsubscribe"}),"\n",(0,t.jsx)(n.p,{children:"Sent when connection was unsubscribed from a channel during its lifetime."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "channel":"test",\n  "unsubscribe":{}\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"subscribe",children:"subscribe"}),"\n",(0,t.jsx)(n.p,{children:"Sent when connection was subscribed to a channel during its lifetime."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "channel":"test",\n  "subscribe":{}\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"refresh",children:"refresh"}),"\n",(0,t.jsx)(n.p,{children:"Sent when connection was refreshed. Generally, it's rarely needed in practice."}),"\n",(0,t.jsx)(n.h3,{id:"ping",children:"ping"}),"\n",(0,t.jsx)(n.p,{children:"From time to time connection will receive empty pushes - without any fields. Those are server ping frames."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}}}]);